import meow from 'meow';
import Path__default from 'path';
import url from 'url';
import express from 'express';
import * as fs from 'fs-extra';
import fs__default from 'fs-extra';
import fastGlob from 'fast-glob';
import prettier from 'prettier';
import resolve from 'resolve';
import { w as writeAdminFiles, s as serializePathForImport$1, c as createSystem } from '../../dist/createSystem-0871d001.esm.js';
import { d as devMigrations, p as pushPrismaSchemaToDatabase } from '../../dist/migrations-7717e45c.esm.js';
import { i as initConfig } from '../../dist/initConfig-f536b388.esm.js';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import { addHook } from 'pirates';
import * as babel from '@babel/core';
import sourceMapSupport from 'source-map-support';
import { d as defaults, c as createExpressServer, a as createAdminUIMiddleware } from '../../dist/createAdminUIMiddleware-456cab36.esm.js';
import { generateCommittedArtifacts, generateNodeModulesArtifacts, getSchemaPaths, requirePrismaClient, validateCommittedArtifacts } from '../../artifacts/dist/keystone.esm.js';
import { g as getConfigPath, a as getAdminPath, E as ExitError } from '../../dist/utils-b84e12de.esm.js';
import execa from 'execa';
import '../../dist/core-3f0f7b15.esm.js';
import '../../dist/sqlite-943cbaa7.esm.js';
import 'decimal.js';
import '@graphql-ts/schema/api-without-context';
import '@graphql-ts/schema';
import 'graphql-type-json';
import 'graphql-upload/public/GraphQLUpload.js';
import '@graphql-ts/schema/api-with-context';
import '@babel/runtime/helpers/objectWithoutProperties';
import 'graphql';
import '@emotion/hash';
import '../../dist/admin-meta-graphql-c4fe434c.esm.js';
import '@apollo/client';
import '../../session/dist/keystone.esm.js';
import 'cookie';
import '@hapi/iron';
import 'uid-safe';
import '@babel/runtime/helpers/classPrivateFieldInitSpec';
import '@babel/runtime/helpers/classPrivateFieldGet';
import '@babel/runtime/helpers/classPrivateFieldSet';
import 'p-limit';
import 'pluralize';
import 'apollo-server-errors';
import 'uuid';
import 'image-type';
import 'image-size';
import '../../fields/types/image/utils/dist/keystone.esm.js';
import 'node-fetch';
import 'form-data';
import 'crypto';
import 'stream';
import 'filenamify';
import '@sindresorhus/slugify';
import '../../fields/types/file/utils/dist/keystone.esm.js';
import '@prisma/sdk';
import '@prisma/migrate';
import 'chalk';
import 'cuid';
import '../../dist/package-path-7ba957ae.esm.js';
import 'cors';
import 'graphql-upload';
import '../../dist/createApolloServer-7b3e0bd8.esm.js';
import 'apollo-server-micro';
import 'apollo-server-express';
import 'prompts';
import '@babel/runtime/helpers/defineProperty';

const formatSource$1 = (src, parser = 'babel') => prettier.format(src, {
  parser,
  trailingComma: 'es5',
  singleQuote: true
});

function getDoesAdminConfigExist() {
  try {
    const configPath = Path__default.join(process.cwd(), 'admin', 'config');
    resolve.sync(configPath, {
      extensions: ['.ts', '.tsx', '.js'],
      preserveSymlinks: false
    });
    return true;
  } catch (err) {
    if (err.code === 'MODULE_NOT_FOUND') {
      return false;
    }

    throw err;
  }
}

async function writeAdminFile$1(file, projectAdminPath) {
  const outputFilename = Path__default.join(projectAdminPath, file.outputPath);

  if (file.mode === 'copy') {
    if (!Path__default.isAbsolute(file.inputPath)) {
      throw new Error(`An inputPath of "${file.inputPath}" was provided to copy but inputPaths must be absolute`);
    }

    await fs__default.ensureDir(Path__default.dirname(outputFilename)); // TODO: should we use copyFile or copy?

    await fs__default.copyFile(file.inputPath, outputFilename);
  }

  if (file.mode === 'write') {
    await fs__default.outputFile(outputFilename, formatSource$1(file.src));
  }

  return Path__default.normalize(outputFilename);
}

const generateAdminUI = async (config, graphQLSchema, adminMeta, projectAdminPath) => {
  var _config$ui$getAdditio, _config$ui, _config$ui$getAdditio2;

  // Nuke any existing files in our target directory
  await fs__default.remove(projectAdminPath);
  const publicDirectory = Path__default.join(projectAdminPath, 'public');

  if (config.images || config.files) {
    await fs__default.mkdir(publicDirectory, {
      recursive: true
    });
  }

  if (config.images) {
    var _config$images$local$, _config$images$local;

    const storagePath = Path__default.resolve((_config$images$local$ = (_config$images$local = config.images.local) === null || _config$images$local === void 0 ? void 0 : _config$images$local.storagePath) !== null && _config$images$local$ !== void 0 ? _config$images$local$ : './public/images');
    await fs__default.mkdir(storagePath, {
      recursive: true
    });
    await fs__default.symlink(Path__default.relative(publicDirectory, storagePath), Path__default.join(publicDirectory, 'images'), 'junction');
  }

  if (config.files) {
    var _config$files$local$s, _config$files$local;

    const storagePath = Path__default.resolve((_config$files$local$s = (_config$files$local = config.files.local) === null || _config$files$local === void 0 ? void 0 : _config$files$local.storagePath) !== null && _config$files$local$s !== void 0 ? _config$files$local$s : './public/files');
    await fs__default.mkdir(storagePath, {
      recursive: true
    });
    await fs__default.symlink(Path__default.relative(publicDirectory, storagePath), Path__default.join(publicDirectory, 'files'), 'junction');
  } // Write out the files configured by the user


  const userPages = (_config$ui$getAdditio = (_config$ui = config.ui) === null || _config$ui === void 0 ? void 0 : (_config$ui$getAdditio2 = _config$ui.getAdditionalFiles) === null || _config$ui$getAdditio2 === void 0 ? void 0 : _config$ui$getAdditio2.map(x => x(config))) !== null && _config$ui$getAdditio !== void 0 ? _config$ui$getAdditio : [];
  const userFilesToWrite = (await Promise.all(userPages)).flat();
  const savedFiles = await Promise.all(userFilesToWrite.map(file => writeAdminFile$1(file, projectAdminPath)));
  const uniqueFiles = new Set(savedFiles); // Write out the built-in admin UI files. Don't overwrite any user-defined pages.

  const configFileExists = getDoesAdminConfigExist();
  const adminFiles = writeAdminFiles(config, graphQLSchema, adminMeta, configFileExists, projectAdminPath);
  await Promise.all(adminFiles.filter(x => !uniqueFiles.has(Path__default.normalize(Path__default.join(projectAdminPath, x.outputPath)))).map(file => writeAdminFile$1(file, projectAdminPath))); // Add files to pages/ which point to any files which exist in admin/pages

  const userPagesDir = Path__default.join(process.cwd(), 'admin', 'pages');
  const files = await fastGlob('**/*.{js,jsx,ts,tsx}', {
    cwd: userPagesDir
  });
  await Promise.all(files.map(async filename => {
    const outputFilename = Path__default.join(projectAdminPath, 'pages', filename);
    const path = Path__default.relative(Path__default.dirname(outputFilename), Path__default.join(userPagesDir, filename));
    const importPath = serializePathForImport$1(path);
    await fs__default.outputFile(outputFilename, `export { default } from ${importPath}`);
  }));
};

async function buildAdminUI(projectAdminPath) {
  // importing next/dist/build is quite expensive so we're requiring it lazily

  /** We do this to stop webpack from bundling next inside of next */
  const next = 'next/dist/build';

  const build = require(next).default;

  await build(projectAdminPath);
}

const EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx'];
const babelPlugins = [require.resolve('@babel/plugin-transform-modules-commonjs')];

const hook = () => {
  let compiling = false;
  let sourceMaps = {};
  let needsToInstallSourceMapSupport = true;

  function compileHook(code, filename) {
    if (compiling) return code; // we do this lazily because jest has its own require implementation
    // which means preconstruct's require hook won't be run
    // so we don't want to install source map support because that will mess up
    // jest's source map support

    if (needsToInstallSourceMapSupport) {
      sourceMapSupport.install({
        environment: 'node',

        retrieveSourceMap(source) {
          let map = sourceMaps[source];

          if (map !== undefined) {
            return {
              url: source,
              map
            };
          } else {
            return null;
          }
        }

      });
      needsToInstallSourceMapSupport = false;
    }

    try {
      compiling = true;
      const partialConfig = babel.loadPartialConfig({
        plugins: babelPlugins,
        filename,
        sourceMaps: 'both',
        rootMode: 'upward-optional'
      });
      let options = partialConfig.options;

      if (!partialConfig.hasFilesystemConfig()) {
        options = _objectSpread(_objectSpread({}, options), {}, {
          // note that we're explicitly removing the plugin(@babel/plugin-transform-modules-commonjs)
          // we added above because for some reason, it interacts poorly with next/babel
          // and results in stray ESM imports of React when they should be CJS
          // note that we're never going to be removing a consumer's Babel config since
          // that would make hasFilesystemConfig() return true
          plugins: [],
          presets: [require.resolve('next/babel')]
        });
      }

      const output = babel.transformSync(code, options);
      sourceMaps[filename] = output.map;
      return output.code;
    } finally {
      compiling = false;
    }
  }

  return addHook(compileHook, {
    exts: EXTENSIONS
  });
};

const requireSource = filePath => {
  const unregister = hook();

  const result = require(filePath);

  unregister();
  return result;
};

const devLoadingHTMLFilepath = Path__default.join(Path__default.dirname(require.resolve('@keystone-next/keystone/package.json')), 'static', 'dev-loading.html');
const dev = async (cwd, shouldDropDatabase) => {
  var _config$server, _config$server2;

  console.log('âœ¨ Starting Keystone');
  const app = express();
  let expressServer = null;
  let adminUIMiddleware = null;

  const ready = () => !!(expressServer && adminUIMiddleware);

  let disconnect = null;
  const config = initConfig(requireSource(getConfigPath(cwd)).default);

  const initKeystone = async () => {
    var _config$ui;

    const {
      graphQLSchema,
      adminMeta,
      getKeystone
    } = createSystem(config); // Generate the Artifacts

    console.log('âœ¨ Generating GraphQL and Prisma schemas');
    const prismaSchema = (await generateCommittedArtifacts(graphQLSchema, config, cwd)).prisma;
    await generateNodeModulesArtifacts(graphQLSchema, config, cwd); // Set up the Database

    if (config.db.useMigrations) {
      await devMigrations(config.db.url, prismaSchema, getSchemaPaths(cwd).prisma, shouldDropDatabase);
    } else {
      await pushPrismaSchemaToDatabase(config.db.url, prismaSchema, getSchemaPaths(cwd).prisma, shouldDropDatabase);
    }

    const prismaClient = requirePrismaClient(cwd);
    const keystone = getKeystone(prismaClient);
    const {
      createContext
    } = keystone; // Connect to the Database

    console.log('âœ¨ Connecting to the database');
    await keystone.connect();

    disconnect = () => keystone.disconnect(); // Set up the Express Server


    console.log('âœ¨ Creating server');
    expressServer = await createExpressServer(config, graphQLSchema, createContext);
    console.log(`âœ… GraphQL API ready`); // Initialise the Admin UI

    if (!((_config$ui = config.ui) !== null && _config$ui !== void 0 && _config$ui.isDisabled)) {
      console.log('âœ¨ Generating Admin UI code');
      await generateAdminUI(config, graphQLSchema, adminMeta, getAdminPath(cwd));
      console.log('âœ¨ Preparing Admin UI app');
      adminUIMiddleware = await createAdminUIMiddleware(config, createContext, true, getAdminPath(cwd));
      expressServer.use(adminUIMiddleware);
      console.log(`âœ… Admin UI ready`);
    }
  }; // You shouldn't really be doing a healthcheck on the dev server, but we
  // respond on the endpoint with the correct error code just in case. This
  // doesn't send the configured data shape, because config doesn't allow
  // for the "not ready" case but that's probably OK.


  if ((_config$server = config.server) !== null && _config$server !== void 0 && _config$server.healthCheck) {
    const healthCheckPath = config.server.healthCheck === true ? defaults.healthCheckPath : config.server.healthCheck.path || defaults.healthCheckPath;
    app.use(healthCheckPath, (req, res, next) => {
      if (expressServer) return next();
      res.status(503).json({
        status: 'fail',
        timestamp: Date.now()
      });
    });
  } // Serve the dev status page for the Admin UI


  app.use('/__keystone_dev_status', (req, res) => {
    res.json({
      ready: ready() ? true : false
    });
  }); // Pass the request the express server, or serve the loading page

  app.use((req, res, next) => {
    var _config$graphql;

    // If both the express server and Admin UI Middleware are ready, we're go!
    if (expressServer && adminUIMiddleware) return expressServer(req, res, next); // Otherwise, we may be able to serve the GraphQL API

    const {
      pathname
    } = url.parse(req.url);

    if (expressServer && pathname === (((_config$graphql = config.graphql) === null || _config$graphql === void 0 ? void 0 : _config$graphql.path) || '/api/graphql')) {
      return expressServer(req, res, next);
    } // Serve the loading page


    res.sendFile(devLoadingHTMLFilepath);
  });
  const port = ((_config$server2 = config.server) === null || _config$server2 === void 0 ? void 0 : _config$server2.port) || process.env.PORT || 3000;
  let initKeystonePromiseResolve;
  let initKeystonePromiseReject;
  let initKeystonePromise = new Promise((resolve, reject) => {
    initKeystonePromiseResolve = resolve;
    initKeystonePromiseReject = reject;
  });
  const server = app.listen(port, err => {
    if (err) throw err;
    console.log(`â­ï¸ Dev Server Ready on http://localhost:${port}`); // We start initialising Keystone after the dev server is ready,
    // otherwise it slows down the first response significantly

    initKeystone().then(() => {
      initKeystonePromiseResolve();
    }).catch(err => {
      server.close(async closeErr => {
        if (closeErr) {
          console.log('There was an error while closing the server');
          console.log(closeErr);
        }

        try {
          var _disconnect;

          await ((_disconnect = disconnect) === null || _disconnect === void 0 ? void 0 : _disconnect());
        } catch (err) {
          console.log('There was an error while disconnecting from the database');
          console.log(err);
        }

        initKeystonePromiseReject(err);
      });
    });
  });
  await initKeystonePromise;
  return () => new Promise((resolve, reject) => {
    server.close(async err => {
      try {
        var _disconnect2;

        await ((_disconnect2 = disconnect) === null || _disconnect2 === void 0 ? void 0 : _disconnect2());
      } catch (disconnectionError) {
        if (!err) {
          err = disconnectionError;
        } else {
          console.log('There was an error while disconnecting from the database');
          console.log(disconnectionError);
        }
      }

      if (err) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
};

const start = async cwd => {
  var _config$ui, _config$server;

  console.log('âœ¨ Starting Keystone'); // This is the compiled version of the configuration which was generated during the build step.
  // See reexportKeystoneConfig().

  const apiFile = Path__default.join(getAdminPath(cwd), '.next/server/pages/api/__keystone_api_build.js');

  if (!fs.existsSync(apiFile)) {
    console.log('ðŸš¨ keystone-next build must be run before running keystone-next start');
    throw new ExitError(1);
  }

  const config = initConfig(require(apiFile).config);
  const {
    getKeystone,
    graphQLSchema
  } = createSystem(config);
  const prismaClient = requirePrismaClient(cwd);
  const keystone = getKeystone(prismaClient);
  console.log('âœ¨ Connecting to the database');
  await keystone.connect();
  console.log('âœ¨ Creating server');
  const server = await createExpressServer(config, graphQLSchema, keystone.createContext);
  console.log(`âœ… GraphQL API ready`);

  if (!((_config$ui = config.ui) !== null && _config$ui !== void 0 && _config$ui.isDisabled)) {
    console.log('âœ¨ Preparing Admin UI Next.js app');
    server.use(await createAdminUIMiddleware(config, keystone.createContext, false, getAdminPath(cwd)));
    console.log(`âœ… Admin UI ready`);
  }

  const port = ((_config$server = config.server) === null || _config$server === void 0 ? void 0 : _config$server.port) || process.env.PORT || 3000;
  server.listen(port, err => {
    if (err) throw err;
    console.log(`â­ï¸ Server Ready on http://localhost:${port}`);
  });
};

async function writeAdminFile(file, projectAdminPath) {
  const outputFilename = Path__default.join(projectAdminPath, file.outputPath);

  if (file.mode === 'copy') {
    if (!Path__default.isAbsolute(file.inputPath)) {
      throw new Error(`An inputPath of "${file.inputPath}" was provided to copy but inputPaths must be absolute`);
    }

    await fs__default.ensureDir(Path__default.dirname(outputFilename)); // TODO: should we use copyFile or copy?

    await fs__default.copyFile(file.inputPath, outputFilename);
  }

  if (file.mode === 'write') {
    await fs__default.outputFile(outputFilename, formatSource(file.src));
  }
} // FIXME: Duplicated from admin-ui package. Need to decide on a common home.


function serializePathForImport(path) {
  // JSON.stringify is important here because it will escape windows style paths(and any thing else that might potentionally be in there)
  return JSON.stringify(path // Next is unhappy about imports that include .ts/tsx in them because TypeScript is unhappy with them becasue when doing a TypeScript compilation with tsc, the imports won't be written so they would be wrong there
  .replace(/\.tsx?$/, ''));
} // FIXME: Duplicated from admin-ui package. Need to decide on a common home.

const formatSource = (src, parser = 'babel') => prettier.format(src, {
  parser,
  trailingComma: 'es5',
  singleQuote: true
});

const reexportKeystoneConfig = async (cwd, isDisabled) => {
  const projectAdminPath = getAdminPath(cwd);
  const configPath = getConfigPath(cwd);

  if (isDisabled) {
    // Nuke any existing files in our target directory
    await fs__default.remove(projectAdminPath);
  } // We re-export the Keystone config file into the Admin UI project folder
  // so that when we run the build step, we will end up with a compiled version
  // of the configuration file in the .next/ directory. Even if we're not building
  // an Admin UI, we still need to run the `build()` function so that this config
  // file is correctly compiled.


  const pkgDir = Path__default.dirname(require.resolve('@keystone-next/keystone/package.json'));
  const p = serializePathForImport(Path__default.relative(Path__default.join(projectAdminPath, 'pages', 'api'), configPath));
  const files = [{
    mode: 'write',
    src: `export { default as config } from ${p};
            export default function (req, res) { return res.status(500) }`,
    outputPath: Path__default.join('pages', 'api', '__keystone_api_build.js')
  }];

  if (isDisabled) {
    // These are the basic files required to have a valid Next.js project. If the
    // Admin UI is disabled then we need to do this ourselves here.
    files.push({
      mode: 'copy',
      inputPath: Path__default.join(pkgDir, 'static', 'next.config.js'),
      outputPath: 'next.config.js'
    }, {
      mode: 'copy',
      inputPath: Path__default.join(pkgDir, 'static', 'tsconfig.json'),
      outputPath: 'tsconfig.json'
    });
  }

  await Promise.all(files.map(file => writeAdminFile(file, projectAdminPath)));
};

async function build(cwd) {
  var _config$ui, _config$ui2;

  const config = initConfig(requireSource(getConfigPath(cwd)).default);
  const {
    graphQLSchema,
    adminMeta
  } = createSystem(config);
  await validateCommittedArtifacts(graphQLSchema, config, cwd);
  console.log('âœ¨ Building Keystone'); // FIXME: This needs to generate clients for the correct build target using binaryTarget
  // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#binarytargets-options

  await generateNodeModulesArtifacts(graphQLSchema, config, cwd);

  if ((_config$ui = config.ui) !== null && _config$ui !== void 0 && _config$ui.isDisabled) {
    console.log('âœ¨ Skipping Admin UI code generation');
  } else {
    console.log('âœ¨ Generating Admin UI code');
    await generateAdminUI(config, graphQLSchema, adminMeta, getAdminPath(cwd));
  }

  console.log('âœ¨ Generating Keystone config code');
  await reexportKeystoneConfig(cwd, (_config$ui2 = config.ui) === null || _config$ui2 === void 0 ? void 0 : _config$ui2.isDisabled);
  console.log('âœ¨ Building Admin UI');
  await buildAdminUI(getAdminPath(cwd));
}

async function prisma(cwd, args) {
  const config = initConfig(requireSource(getConfigPath(cwd)).default);
  const {
    graphQLSchema
  } = createSystem(config);
  await validateCommittedArtifacts(graphQLSchema, config, cwd);
  await generateNodeModulesArtifacts(graphQLSchema, config, cwd);
  const result = await execa('node', [require.resolve('prisma'), ...args], {
    cwd,
    stdio: 'inherit',
    reject: false,
    env: _objectSpread(_objectSpread({}, process.env), {}, {
      DATABASE_URL: config.db.url,
      PRISMA_HIDE_UPDATE_MESSAGE: '1'
    })
  });

  if (result.exitCode !== 0) {
    throw new ExitError(result.exitCode);
  }
}

// Thereâ€™s some files that we need to generate into node_modules and itâ€™s
// important to have them available immediately so things like TypeScript
// wonâ€™t fail.
// We want to validate that your Prisma and GraphQL schemas are up to date
// to prevent the awkward â€œthis is changing because of a previous PR that
// didnâ€™t update these thingsâ€.
// Why do validation in the postinstall rather than a separate validate command?
//
// It means that itâ€™s hard to get it wrong. You have to run the postinstall
// script anyway so it prevents â€œoh no, you forgot add this to your CIâ€
// node_modules
//   .prisma/client (this is where Prisma generates the client to by default,
//      this means we can have a conversation about whether we should tell
//      people to use @prisma/client directly for certain things though we
//      are not necessarily saying thatâ€™s what we should do)
//   .keystone
//     - All .js files will have a corresponding .d.ts file for TypeScript.
//       We are generating vanilla JavaScript because:
//         * the user may not be using TypeScript
//         * we canâ€™t/shouldnâ€™t rely on files in node_modules being transpiled even if they are
//     - types.{js,.ts}: .d.ts will be the same as current .keystone/schema-types.ts, the .js will be empty
//     - next/graphql-api.js: to be imported into a next app as an api route
//         * only generated with generateNextGraphqlAPI option
//     - api.js:  includes the lists API (full exports to be decided elsewhere
//         * only generated with generateNodeAPI option

async function postinstall(cwd, shouldFix) {
  const config = initConfig(requireSource(getConfigPath(cwd)).default);
  const {
    graphQLSchema
  } = createSystem(config);

  if (shouldFix) {
    await generateCommittedArtifacts(graphQLSchema, config, cwd);
    console.log('âœ¨ Generated GraphQL and Prisma schemas');
  } else {
    await validateCommittedArtifacts(graphQLSchema, config, cwd);
    console.log('âœ¨ GraphQL and Prisma schemas are up to date');
  }

  await generateNodeModulesArtifacts(graphQLSchema, config, cwd);
}

const commands = {
  dev,
  start,
  build,
  prisma,
  postinstall
};
async function cli(cwd, argv) {
  const {
    input,
    help,
    flags
  } = meow(`
    Usage
      $ keystone-next [command]
    Commands
        dev           start the project in development mode (default)
        postinstall   generate client APIs and types (optional)
        build         build the project (must be done before using start)
        start         start the project in production mode
        prisma        run Prisma CLI commands safely
    `, {
    flags: {
      fix: {
        default: false,
        type: 'boolean'
      },
      resetDb: {
        default: false,
        type: 'boolean'
      }
    },
    argv
  });
  const command = input[0] || 'dev';

  if (!isCommand(command)) {
    console.log(`${command} is not a command that keystone-next accepts`);
    console.log(help);
    throw new ExitError(1);
  }

  if (command === 'prisma') {
    return prisma(cwd, argv.slice(1));
  } else if (command === 'postinstall') {
    return postinstall(cwd, flags.fix);
  } else if (command === 'dev') {
    return dev(cwd, flags.resetDb);
  } else {
    return commands[command](cwd);
  }
}

function isCommand(command) {
  return command in commands;
}

cli(process.cwd(), process.argv.slice(2)).catch(err => {
  if (err instanceof ExitError) {
    process.exit(err.code);
  }

  console.log(err);
  process.exit(1);
});
