import type { KeystoneContext } from '..';
import type { BaseGeneratedListTypes } from '../utils';
export declare type ListHooks<TGeneratedListTypes extends BaseGeneratedListTypes> = {
    /**
     * Used to **modify the input** for create and update operations after default values and access control have been applied
     */
    resolveInput?: ResolveInputHook<TGeneratedListTypes>;
    /**
     * Used to **validate the input** for create and update operations once all resolveInput hooks resolved
     */
    validateInput?: ValidateInputHook<TGeneratedListTypes>;
    /**
     * Used to **cause side effects** before a create or update operation once all validateInput hooks have resolved
     */
    beforeChange?: BeforeChangeHook<TGeneratedListTypes>;
    /**
     * Used to **cause side effects** after a create or update operation operation has occurred
     */
    afterChange?: AfterChangeHook<TGeneratedListTypes>;
    /**
     * Used to **validate** that a delete operation can happen after access control has occurred
     */
    validateDelete?: ValidateDeleteHook<TGeneratedListTypes>;
    /**
     * Used to **cause side effects** before a delete operation operation has occurred
     */
    beforeDelete?: BeforeOrAfterDeleteHook<TGeneratedListTypes>;
    /**
     * Used to **cause side effects** after a delete operation operation has occurred
     */
    afterDelete?: BeforeOrAfterDeleteHook<TGeneratedListTypes>;
};
declare type AddFieldPathToObj<T extends (arg: any) => any> = T extends (args: infer Args) => infer Result ? (args: Args & {
    fieldKey: string;
}) => Result : never;
declare type AddFieldPathArgToAllPropsOnObj<T extends Record<string, (arg: any) => any>> = {
    [Key in keyof T]: AddFieldPathToObj<T[Key]>;
};
export declare type FieldHooks<TGeneratedListTypes extends BaseGeneratedListTypes> = AddFieldPathArgToAllPropsOnObj<ListHooks<TGeneratedListTypes>>;
declare type ArgsForCreateOrUpdateOperation<TGeneratedListTypes extends BaseGeneratedListTypes> = ({
    operation: 'create';
    existingItem?: TGeneratedListTypes['backing'];
    /**
     * The GraphQL input **before** default values are applied
     */
    originalInput: TGeneratedListTypes['inputs']['create'];
    /**
     * The GraphQL input **after** default values are applied
     */
    resolvedData: TGeneratedListTypes['inputs']['create'];
} | {
    operation: 'update';
    existingItem: TGeneratedListTypes['backing'];
    /**
     * The GraphQL input **before** default values are applied
     */
    originalInput: TGeneratedListTypes['inputs']['update'];
    /**
     * The GraphQL input **after** default values are applied
     */
    resolvedData: TGeneratedListTypes['inputs']['update'];
}) & {
    context: KeystoneContext;
    /**
     * The key of the list that the operation is occurring on
     */
    listKey: string;
};
declare type ValidationArgs = {
    addValidationError: (error: string, data?: {}, internalData?: {}) => void;
};
declare type ResolveInputHook<TGeneratedListTypes extends BaseGeneratedListTypes> = (args: ArgsForCreateOrUpdateOperation<TGeneratedListTypes>) => Promise<TGeneratedListTypes['inputs']['create'] | TGeneratedListTypes['inputs']['update']> | TGeneratedListTypes['inputs']['create'] | TGeneratedListTypes['inputs']['update'] | Record<string, any> | string | number | boolean | null;
declare type ValidateInputHook<TGeneratedListTypes extends BaseGeneratedListTypes> = (args: ArgsForCreateOrUpdateOperation<TGeneratedListTypes> & ValidationArgs) => Promise<void> | void;
declare type BeforeChangeHook<TGeneratedListTypes extends BaseGeneratedListTypes> = (args: ArgsForCreateOrUpdateOperation<TGeneratedListTypes>) => Promise<void> | void;
declare type AfterChangeHook<TGeneratedListTypes extends BaseGeneratedListTypes> = (args: ArgsForCreateOrUpdateOperation<TGeneratedListTypes> & {
    updatedItem: TGeneratedListTypes['backing'];
}) => Promise<void> | void;
declare type ArgsForDeleteOperation<TGeneratedListTypes extends BaseGeneratedListTypes> = {
    operation: 'delete';
    existingItem: TGeneratedListTypes['backing'];
    context: KeystoneContext;
    listKey: string;
};
declare type ValidateDeleteHook<TGeneratedListTypes extends BaseGeneratedListTypes> = (args: ArgsForDeleteOperation<TGeneratedListTypes> & ValidationArgs) => Promise<void> | void;
declare type BeforeOrAfterDeleteHook<TGeneratedListTypes extends BaseGeneratedListTypes> = (args: ArgsForDeleteOperation<TGeneratedListTypes>) => Promise<void> | void;
export {};
