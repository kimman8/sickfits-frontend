{
  "version": 3,
  "sources": ["../src/Migrate.ts"],
  "sourcesContent": ["import { parseEnvValue } from '@prisma/sdk'\nimport { getSchemaPathSync, getGenerators } from '@prisma/sdk'\nimport chalk from 'chalk'\nimport Debug from '@prisma/debug'\nimport fs from 'fs'\nimport logUpdate from 'log-update'\nimport path from 'path'\nimport { MigrateEngine } from './MigrateEngine'\nimport { EngineResults, EngineArgs } from './types'\nimport { formatms } from './utils/formatms'\nimport { enginesVersion } from '@prisma/engines-version'\nimport { NoSchemaFoundError } from './utils/errors'\n\nconst debug = Debug('prisma:migrate')\nconst packageJson = eval(`require('../package.json')`) // tslint:disable-line\n\nexport class Migrate {\n  get devMigrationsDir(): string {\n    return path.join(path.dirname(this.schemaPath), 'migrations/dev')\n  }\n  public engine: MigrateEngine\n  private schemaPath: string\n  public migrationsDirectoryPath: string\n  constructor(schemaPath?: string, enabledPreviewFeatures?: string[]) {\n    this.schemaPath = this.getSchemaPath(schemaPath)\n    this.migrationsDirectoryPath = path.join(\n      path.dirname(this.schemaPath),\n      'migrations',\n    )\n    this.engine = new MigrateEngine({\n      projectDir: path.dirname(this.schemaPath),\n      schemaPath: this.schemaPath,\n      enabledPreviewFeatures,\n    })\n  }\n\n  public stop(): void {\n    this.engine.stop()\n  }\n\n  public getSchemaPath(schemaPathFromOptions?): string {\n    const schemaPath = getSchemaPathSync(schemaPathFromOptions)\n\n    if (!schemaPath) {\n      throw new NoSchemaFoundError()\n    }\n\n    return schemaPath\n  }\n\n  public getDatamodel(): string {\n    return fs.readFileSync(this.schemaPath, 'utf-8')\n  }\n\n  public reset(): Promise<void> {\n    return this.engine.reset()\n  }\n\n  public createMigration(\n    params: EngineArgs.CreateMigrationInput,\n  ): Promise<EngineResults.CreateMigrationOutput> {\n    return this.engine.createMigration(params)\n  }\n\n  public diagnoseMigrationHistory({\n    optInToShadowDatabase,\n  }: {\n    optInToShadowDatabase: boolean\n  }): Promise<EngineResults.DiagnoseMigrationHistoryOutput> {\n    return this.engine.diagnoseMigrationHistory({\n      migrationsDirectoryPath: this.migrationsDirectoryPath,\n      optInToShadowDatabase,\n    })\n  }\n\n  public listMigrationDirectories(): Promise<EngineResults.ListMigrationDirectoriesOutput> {\n    return this.engine.listMigrationDirectories({\n      migrationsDirectoryPath: this.migrationsDirectoryPath,\n    })\n  }\n\n  public devDiagnostic(): Promise<EngineResults.DevDiagnosticOutput> {\n    return this.engine.devDiagnostic({\n      migrationsDirectoryPath: this.migrationsDirectoryPath,\n    })\n  }\n\n  public async markMigrationApplied({\n    migrationId,\n  }: {\n    migrationId: string\n  }): Promise<void> {\n    return await this.engine.markMigrationApplied({\n      migrationsDirectoryPath: this.migrationsDirectoryPath,\n      migrationName: migrationId,\n    })\n  }\n\n  public markMigrationRolledBack({\n    migrationId,\n  }: {\n    migrationId: string\n  }): Promise<void> {\n    return this.engine.markMigrationRolledBack({\n      migrationName: migrationId,\n    })\n  }\n\n  public applyMigrations(): Promise<EngineResults.ApplyMigrationsOutput> {\n    return this.engine.applyMigrations({\n      migrationsDirectoryPath: this.migrationsDirectoryPath,\n    })\n  }\n\n  public evaluateDataLoss(): Promise<EngineResults.EvaluateDataLossOutput> {\n    const datamodel = this.getDatamodel()\n\n    return this.engine.evaluateDataLoss({\n      migrationsDirectoryPath: this.migrationsDirectoryPath,\n      prismaSchema: datamodel,\n    })\n  }\n\n  public async push({\n    force = false,\n  }: {\n    force?: boolean\n  }): Promise<EngineResults.SchemaPush> {\n    const datamodel = this.getDatamodel()\n\n    const { warnings, unexecutable, executedSteps } =\n      await this.engine.schemaPush({\n        force,\n        schema: datamodel,\n      })\n\n    return {\n      executedSteps,\n      warnings,\n      unexecutable,\n    }\n  }\n\n  public async tryToRunGenerate(): Promise<void> {\n    const message: string[] = []\n\n    console.info() // empty line\n    logUpdate(\n      `Running generate... ${chalk.dim(\n        '(Use --skip-generate to skip the generators)',\n      )}`,\n    )\n\n    const generators = await getGenerators({\n      schemaPath: this.schemaPath,\n      printDownloadProgress: true,\n      version: enginesVersion,\n      cliVersion: packageJson.version,\n    })\n\n    for (const generator of generators) {\n      const toStr = generator.options!.generator.output!\n        ? chalk.dim(\n            ` to .${path.sep}${path.relative(\n              process.cwd(),\n              parseEnvValue(generator.options!.generator.output),\n            )}`,\n          )\n        : ''\n      const name = generator.manifest\n        ? generator.manifest.prettyName\n        : parseEnvValue(generator.options!.generator.provider)\n\n      logUpdate(`Running generate... - ${name}`)\n\n      const before = Date.now()\n      try {\n        await generator.generate()\n        const after = Date.now()\n        const version = generator.manifest?.version\n        message.push(\n          `\u2714 Generated ${chalk.bold(name!)}${\n            version ? ` (${version})` : ''\n          }${toStr} in ${formatms(after - before)}`,\n        )\n        generator.stop()\n      } catch (err) {\n        message.push(`${err.message}`)\n        generator.stop()\n      }\n    }\n\n    logUpdate(message.join('\\n'))\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
