import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { forwardRef, Fragment, useMemo, useContext, createContext, useCallback } from 'react';
import { useTheme, jsx, VisuallyHidden, forwardRefWithAs } from '@keystone-ui/core';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import ReactSelect, { mergeStyles } from 'react-select';
export { components as selectComponents } from 'react-select';
import FocusLock from 'react-focus-lock';
import { usePopover, PopoverDialog } from '@keystone-ui/popover';
import { formatISO, format } from 'date-fns';
import DayPicker from 'react-day-picker';
import { XIcon } from '@keystone-ui/icons/icons/XIcon';
import { CalendarIcon } from '@keystone-ui/icons/icons/CalendarIcon';

/** @jsxRuntime classic */
const ControlLabel = ({
  children,
  className,
  control,
  size: sizeKey = 'medium'
}) => {
  const {
    controlSizes,
    spacing,
    typography
  } = useTheme();
  const size = controlSizes[sizeKey];
  return jsx("label", {
    className: className,
    css: {
      alignItems: 'flex-start',
      display: 'inline-flex'
    }
  }, control, children && jsx("div", {
    css: {
      fontSize: size.fontSize,
      lineHeight: typography.leading.tight,
      marginLeft: spacing.small,
      paddingTop: spacing.xsmall,
      userSelect: 'none'
    }
  }, children));
};

/** @jsxRuntime classic */

const Svg = ({
  children,
  size,
  stroke = 'none',
  fill = 'none'
}) => jsx("svg", {
  "aria-hidden": "true",
  focusable: "false",
  css: {
    verticalAlign: 'text-bottom',
    // removes whitespace inside buttons
    fill,
    stroke,
    strokeLinejoin: 'round',
    strokeLinecap: 'round',
    strokeWidth: 3
  },
  height: `${size}px`,
  width: `${size}px`,
  role: "img",
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, children);

const checkSizeMap = {
  small: 14,
  medium: 18,
  large: 24
};
const CheckIcon = ({
  size = 'medium'
}) => {
  return jsx(Svg, {
    size: checkSizeMap[size],
    stroke: "currentColor"
  }, jsx("polyline", {
    points: "20 6 10 18 4 12"
  }));
};
const dotSizeMap = {
  small: 12,
  medium: 16,
  large: 20
};
const DotIcon = ({
  size = 'medium'
}) => {
  return jsx(Svg, {
    size: dotSizeMap[size],
    fill: "currentColor"
  }, jsx("circle", {
    cx: "12",
    cy: "12",
    r: "8"
  }));
};

const useIndicatorTokens = ({
  size: sizeKey,
  type
}) => {
  const {
    controlSizes,
    fields
  } = useTheme();
  const size = controlSizes[sizeKey];
  return {
    background: fields.controlBackground,
    borderColor: fields.controlBorderColor,
    borderRadius: type === 'checkbox' ? fields.controlBorderRadius : '50%',
    borderWidth: fields.controlBorderWidth,
    boxSize: size.indicatorBoxSize,
    foreground: fields.controlBackground,
    // visually hide the icon unless the control is checked
    hover: {
      background: fields.hover.controlBackground,
      borderColor: fields.hover.controlBorderColor,
      shadow: fields.hover.shadow,
      foreground: fields.hover.controlForeground
    },
    focus: {
      background: fields.focus.controlBackground,
      borderColor: fields.focus.controlBorderColor,
      shadow: fields.focus.shadow,
      foreground: fields.focus.controlForeground
    },
    selected: {
      background: type === 'checkbox' ? fields.selected.controlBackground : fields.selected.controlForeground,
      borderColor: fields.selected.controlBorderColor,
      shadow: fields.selected.shadow,
      foreground: type === 'checkbox' ? fields.selected.controlForeground : fields.selected.controlBackground
    },
    disabled: {
      background: fields.disabled.controlBackground,
      borderColor: fields.disabled.controlBorderColor,
      shadow: fields.disabled.shadow,
      foreground: fields.disabled.controlForeground
    }
  };
};
const useIndicatorStyles = ({
  tokens
}) => {
  return {
    alignItems: 'center',
    backgroundColor: tokens.background,
    borderColor: tokens.borderColor,
    borderRadius: tokens.borderRadius,
    borderStyle: 'solid',
    borderWidth: tokens.borderWidth,
    boxSizing: 'border-box',
    color: tokens.foreground,
    cursor: 'pointer',
    display: 'flex',
    flexShrink: 0,
    height: tokens.boxSize,
    justifyContent: 'center',
    transition: tokens.transition,
    width: tokens.boxSize,
    'input:hover + &': {
      backgroundColor: tokens.hover.background,
      borderColor: tokens.hover.borderColor,
      boxShadow: tokens.hover.shadow,
      color: tokens.hover.foreground
    },
    'input:focus + &': {
      backgroundColor: tokens.focus.background,
      borderColor: tokens.focus.borderColor,
      boxShadow: tokens.focus.shadow,
      color: tokens.focus.foreground
    },
    'input:checked + &': {
      backgroundColor: tokens.selected.background,
      borderColor: tokens.selected.borderColor,
      boxShadow: tokens.selected.shadow,
      color: tokens.selected.foreground
    },
    'input:disabled + &': {
      backgroundColor: tokens.disabled.background,
      borderColor: tokens.disabled.borderColor,
      boxShadow: tokens.disabled.shadow,
      color: tokens.disabled.background,
      cursor: 'default'
    },
    'input:checked:disabled + &': {
      color: tokens.disabled.foreground
    }
  };
};

const _excluded$b = ["children", "className", "size"],
      _excluded2$3 = ["className", "size"],
      _excluded3$1 = ["className", "size"];
const Checkbox = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    className,
    size
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded$b);

  return jsx(ControlLabel, {
    className: className,
    size: size,
    control: jsx(CheckboxControl, _extends({
      ref: ref,
      size: size
    }, props))
  }, children);
});
const CheckboxControl = /*#__PURE__*/forwardRef((_ref2, ref) => {
  let {
    className,
    size
  } = _ref2,
      props = _objectWithoutProperties(_ref2, _excluded2$3);

  return jsx(Fragment, null, jsx(VisuallyHidden, _extends({
    ref: ref,
    as: "input",
    type: "checkbox"
  }, props)), jsx(Indicator$1, {
    className: className,
    size: size
  }, jsx(CheckIcon, {
    size: size
  })));
});

const Indicator$1 = _ref3 => {
  let {
    className,
    size
  } = _ref3,
      props = _objectWithoutProperties(_ref3, _excluded3$1);

  const tokens = useIndicatorTokens({
    type: 'checkbox',
    size: size || 'medium'
  });
  const styles = useIndicatorStyles({
    tokens
  });
  return jsx("div", _extends({
    className: className,
    css: styles
  }, props));
};

const _excluded$a = ["as"];
const FieldContainer = forwardRefWithAs((_ref, ref) => {
  let {
    as: Tag = 'div'
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded$a);

  return jsx(Tag, _extends({
    ref: ref
  }, props));
});

const _excluded$9 = ["as", "children"];
const FieldLabel = forwardRefWithAs((_ref, ref) => {
  let {
    as: Tag = 'label',
    children
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded$9);

  const {
    typography,
    fields,
    spacing
  } = useTheme();
  return jsx(Tag, _extends({
    ref: ref,
    css: {
      color: fields.labelColor,
      display: 'block',
      fontWeight: typography.fontWeight.semibold,
      marginBottom: spacing.xsmall,
      minWidth: 120
    }
  }, props), children);
});

const FieldLegend = props => {
  const {
    typography,
    fields,
    spacing
  } = useTheme();
  return jsx("legend", _extends({
    css: {
      color: fields.legendColor,
      display: 'block',
      fontSize: typography.fontSize.small,
      fontWeight: typography.fontWeight.bold,
      marginBottom: spacing.xsmall,
      minWidth: 120,
      textTransform: 'uppercase'
    }
  }, props));
};

const _excluded$8 = ["children", "className", "size"],
      _excluded2$2 = ["size"],
      _excluded3 = ["size"];
const Radio = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    className,
    size
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded$8);

  return jsx(ControlLabel, {
    className: className,
    size: size,
    control: jsx(RadioControl, _extends({
      ref: ref,
      size: size
    }, props))
  }, children);
});
const RadioControl = /*#__PURE__*/forwardRef((_ref2, ref) => {
  let {
    size
  } = _ref2,
      props = _objectWithoutProperties(_ref2, _excluded2$2);

  return jsx(Fragment, null, jsx(VisuallyHidden, _extends({
    ref: ref,
    as: "input",
    type: "radio"
  }, props)), jsx(Indicator, {
    size: size
  }, jsx(DotIcon, {
    size: size
  })));
});

const Indicator = _ref3 => {
  let {
    size
  } = _ref3,
      props = _objectWithoutProperties(_ref3, _excluded3);

  const tokens = useIndicatorTokens({
    type: 'radio',
    size: size || 'medium'
  });
  const styles = useIndicatorStyles({
    tokens
  });
  return jsx("div", _extends({
    css: styles
  }, props));
};

const _excluded$7 = ["children", "className"],
      _excluded2$1 = ["a11yLabels", "checked", "onChange"];
const Switch = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    className
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded$7);

  return jsx(ControlLabel, {
    className: className,
    control: jsx(SwitchControl, _extends({
      ref: ref
    }, props))
  }, children);
});
const SwitchControl = /*#__PURE__*/forwardRef((_ref2, ref) => {
  let {
    a11yLabels = {
      on: 'On',
      off: 'Off'
    },
    checked = false,
    onChange
  } = _ref2,
      props = _objectWithoutProperties(_ref2, _excluded2$1);

  let onClick = () => {
    if (onChange) {
      onChange(!checked);
    }
  };

  return jsx(Button, _extends({
    "aria-checked": checked,
    role: "switch",
    onClick: onClick,
    ref: ref
  }, props), jsx(VisuallyHidden, null, checked ? a11yLabels.on : a11yLabels.off));
});
const Button = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    animation,
    fields,
    sizing
  } = useTheme();
  let gutter = 3;
  let trackHeight = sizing.xsmall + gutter;
  let trackWidth = trackHeight * 2 - 2 * gutter;
  let handleSize = trackHeight - gutter * 2;
  return jsx("button", _extends({
    ref: ref,
    css: {
      backgroundColor: fields.controlBorderColor,
      borderRadius: 9999,
      padding: gutter,
      border: 0,
      boxSizing: 'border-box',
      display: 'block',
      outline: 0,
      overflow: 'hidden',
      position: 'relative',
      whiteSpace: 'nowrap',
      // height: trackHeight,
      width: trackWidth,
      cursor: 'pointer',
      '&[aria-checked="true"]': {
        backgroundColor: fields.selected.controlBorderColor,
        '::before': {
          transform: 'translateX(100%)'
        }
      },
      '::before': {
        height: handleSize,
        width: handleSize,
        marginTop: -1,
        backgroundColor: fields.switchForeground,
        borderRadius: '50%',
        content: '" "',
        display: 'block',
        position: 'relative',
        transition: `transform ${animation.duration400} ${animation.easeOut}`
      }
    }
  }, props));
});

const useInputTokens = ({
  size: sizeKey = 'medium',
  // width: widthKey = 'large',
  isMultiline = false,
  shape = 'square'
}) => {
  const {
    animation,
    controlSizes,
    fields,
    radii,
    spacing,
    typography
  } = useTheme(); // const width = widthMap[widthKey];

  const size = controlSizes[sizeKey];
  return {
    background: fields.inputBackground,
    borderColor: fields.inputBorderColor,
    borderRadius: shape === 'round' ? radii.full : fields.inputBorderRadius,
    borderWidth: fields.inputBorderWidth,
    fontSize: size.fontSize,
    foreground: fields.inputForeground,
    height: isMultiline ? undefined : size.height,
    lineHeight: isMultiline ? typography.leading.base : `${size.height}px`,
    paddingX: spacing.medium,
    paddingY: isMultiline ? spacing.small : 0,
    placeholder: fields.inputPlaceholder,
    shadow: fields.shadow,
    transition: `
      background-color ${animation.duration100},
      box-shadow ${animation.duration100},
      border-color ${animation.duration100}
    `,
    // width,
    hover: {
      background: fields.hover.inputBackground,
      borderColor: fields.hover.inputBorderColor,
      shadow: fields.hover.shadow,
      foreground: fields.hover.inputForeground
    },
    focus: {
      background: fields.focus.inputBackground,
      borderColor: fields.focus.inputBorderColor,
      shadow: fields.focus.shadow,
      foreground: fields.focus.inputForeground
    },
    invalid: {
      background: fields.invalid.inputBackground,
      borderColor: fields.invalid.inputBorderColor,
      shadow: fields.invalid.shadow,
      foreground: fields.invalid.inputForeground
    },
    disabled: {
      background: fields.disabled.inputBackground,
      borderColor: fields.disabled.inputBorderColor,
      shadow: fields.disabled.shadow,
      foreground: fields.disabled.inputForeground
    }
  };
};
function useInputStyles({
  invalid,
  tokens
}) {
  const styles = {
    appearance: 'none',
    backgroundColor: invalid ? tokens.invalid.background : tokens.background,
    borderColor: invalid ? tokens.invalid.borderColor : tokens.borderColor,
    borderRadius: tokens.borderRadius,
    borderStyle: 'solid',
    borderWidth: tokens.borderWidth,
    boxShadow: invalid ? tokens.invalid.shadow : tokens.shadow,
    boxSizing: 'border-box',
    color: invalid ? tokens.invalid.foreground : tokens.foreground,
    fontSize: tokens.fontSize,
    height: tokens.height,
    lineHeight: tokens.lineHeight,
    // maxWidth: tokens.width,
    outline: 0,
    paddingBottom: tokens.paddingY,
    paddingLeft: tokens.paddingX,
    paddingRight: tokens.paddingX,
    paddingTop: tokens.paddingY,
    resize: 'vertical',
    // applies to textarea
    transition: tokens.transition,
    width: '100%',
    ':hover': {
      backgroundColor: tokens.hover.background,
      borderColor: tokens.hover.borderColor,
      boxShadow: tokens.hover.shadow,
      color: tokens.hover.foreground
    },
    ':focus': {
      backgroundColor: tokens.focus.background,
      borderColor: tokens.focus.borderColor,
      boxShadow: tokens.focus.shadow,
      color: tokens.focus.foreground
    },
    ':disabled': {
      backgroundColor: tokens.disabled.background,
      borderColor: tokens.disabled.borderColor,
      boxShadow: tokens.disabled.shadow,
      color: tokens.disabled.foreground
    },
    '&::placeholder': {
      color: tokens.placeholder
    }
  };
  return styles;
}

const _excluded$6 = ["invalid", "size", "width"];
const TextArea = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    invalid = false,
    size = 'medium',
    width = 'large'
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded$6);

  const tokens = useInputTokens({
    size,
    width,
    shape: 'square',
    isMultiline: true
  });
  const styles = useInputStyles({
    invalid,
    tokens
  });
  return jsx("textarea", _extends({
    rows: 4,
    ref: ref,
    css: styles
  }, props));
});

const _excluded$5 = ["invalid", "shape", "size", "type", "width"];
const TextInput = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    invalid = false,
    shape = 'square',
    size = 'medium',
    type = 'text',
    width = 'large'
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded$5);

  const tokens = useInputTokens({
    size,
    width,
    shape
  });
  const styles = useInputStyles({
    invalid,
    tokens
  });
  return jsx("input", _extends({
    ref: ref,
    type: type,
    css: styles
  }, props));
});

const _excluded$4 = ["id", "onChange", "value", "width", "portalMenu", "styles"],
      _excluded2 = ["id", "onChange", "value", "width", "portalMenu", "styles"];

const useStyles = ({
  tokens,
  multi = false
}) => {
  const {
    palette
  } = useTheme();

  const indicatorStyles = (provided, state) => _objectSpread(_objectSpread({}, provided), {}, {
    color: state.isFocused ? palette.neutral600 : palette.neutral500,
    ':hover': {
      color: state.isFocused ? palette.neutral800 : palette.neutral700
    }
  });

  return {
    control: (provided, state) => {
      const base = _objectSpread(_objectSpread({}, provided), {}, {
        backgroundColor: tokens.background,
        borderColor: tokens.borderColor,
        borderRadius: tokens.borderRadius,
        borderWidth: tokens.borderWidth,
        fontSize: tokens.fontSize,
        boxShadow: tokens.shadow,
        transition: tokens.transition
      });

      const variant = state.isDisabled ? {
        backgroundColor: tokens.disabled.background || tokens.background,
        borderColor: tokens.disabled.borderColor || tokens.borderColor,
        boxShadow: tokens.disabled.shadow || tokens.shadow,
        color: tokens.disabled.foreground || tokens.foreground
      } : state.isFocused ? {
        backgroundColor: tokens.focus.background || tokens.background,
        borderColor: tokens.focus.borderColor || tokens.borderColor,
        boxShadow: tokens.focus.shadow || tokens.shadow,
        color: tokens.focus.foreground || tokens.foreground
      } : {
        ':hover': {
          backgroundColor: tokens.hover.background,
          borderColor: tokens.hover.borderColor,
          boxShadow: tokens.hover.shadow,
          color: tokens.hover.foreground
        }
      };
      return _objectSpread(_objectSpread(_objectSpread({}, provided), base), variant);
    },
    clearIndicator: indicatorStyles,
    dropdownIndicator: indicatorStyles,
    menu: provided => _objectSpread(_objectSpread({}, provided), {}, {
      border: `1px solid ${palette.neutral400}`,
      boxShadow: '0 4px 11px hsla(0, 0%, 0%, 0.1)',
      borderRadius: tokens.borderRadius,
      zIndex: 9999
    }),
    menuPortal: provided => _objectSpread(_objectSpread({}, provided), {}, {
      zIndex: 9999
    }),
    multiValue: provided => _objectSpread(_objectSpread({}, provided), {}, {
      backgroundColor: palette.neutral300,
      borderRadius: tokens.borderRadius
    }),
    multiValueLabel: provided => _objectSpread(_objectSpread({}, provided), {}, {
      // fontSize: typography.fontSize.medium,
      fontSize: '90%'
    }),
    multiValueRemove: provided => _objectSpread(_objectSpread({}, provided), {}, {
      borderRadius: tokens.borderRadius
    }),
    placeholder: provided => _objectSpread(_objectSpread({}, provided), {}, {
      color: tokens.placeholder
    }),
    valueContainer: provided => _objectSpread(_objectSpread({}, provided), {}, {
      padding: multi ? `0 4px` : `0 6px`
    })
  };
};

const portalTarget = typeof document !== 'undefined' ? document.body : undefined;
function Select(_ref) {
  let {
    id,
    onChange,
    value,
    width: widthKey = 'large',
    portalMenu,
    styles
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded$4);

  const tokens = useInputTokens({
    width: widthKey
  });
  const defaultStyles = useStyles({
    tokens
  });
  const composedStyles = styles ? mergeStyles(defaultStyles, styles) : defaultStyles;
  return jsx(ReactSelect, _extends({
    inputId: id,
    value: value // css={{ width: tokens.width }}
    ,
    styles: composedStyles,
    onChange: value => {
      if (!value) {
        onChange(null);
      } else {
        onChange(value);
      }
    }
  }, props, {
    isMulti: false,
    menuPortalTarget: portalMenu && portalTarget
  }));
}
function MultiSelect(_ref2) {
  let {
    id,
    onChange,
    value,
    width: widthKey = 'large',
    portalMenu,
    styles
  } = _ref2,
      props = _objectWithoutProperties(_ref2, _excluded2);

  const tokens = useInputTokens({
    width: widthKey
  });
  const defaultStyles = useStyles({
    tokens,
    multi: true
  });
  const composedStyles = styles ? mergeStyles(defaultStyles, styles) : defaultStyles;
  return jsx(ReactSelect // css={{ width: tokens.width }}
  , _extends({
    inputId: id,
    styles: composedStyles,
    value: value,
    onChange: value => {
      if (!value) {
        onChange([]);
      } else if (Array.isArray(value)) {
        onChange(value);
      } else {
        onChange([value]);
      }
    }
  }, props, {
    isMulti: true,
    menuPortalTarget: portalMenu && portalTarget
  }));
}

/**
 * Un-formatted date for server side storage (ISO8601), like '2019-09-18'
 */
const formatDateType = date => {
  return formatISO(date, {
    representation: 'date'
  });
};
/**
 * Format day, month, year, like "Dec 01 2010" as "12/01/2010"
 * Note, subject to localisation, such as Jan 02 2009, can read 02/01/2009.
 *
 * @usage formatDMY(new Date('2019-09-18T19:00:52')) => "09/18/2019"
 */

const formatDMY = date => format(date, 'MM/dd/yyyy');

function parseHex(hex) {
  let result = hex; // remove hash symbol

  if (result.startsWith('#')) {
    result = result.slice(1);
  } // resolve hex shortcuts


  if (result.length === 3) {
    result = result[0].repeat(2) + result[1].repeat(2) + result[2].repeat(2);
  }

  return result;
} // eslint-disable-next-line @typescript-eslint/no-unused-vars


function hexToTriplet(dirtyHex, alpha) {
  const cleanHex = parseHex(dirtyHex);
  const r = parseInt(cleanHex.slice(0, 2), 16);
  const g = parseInt(cleanHex.slice(2, 4), 16);
  const b = parseInt(cleanHex.slice(4, 6), 16);
  return [r, g, b];
} // values taken from contrast algorithms from w3
// https://www.w3.org/TR/AERT/#color-contrast

function hexToRgb(dirtyHex, alpha) {
  const [r, g, b] = hexToTriplet(dirtyHex);
  const value = `${r}, ${g}, ${b}`;

  if (alpha) {
    return `rgba(${value}, ${alpha})`;
  }

  return `rgb(${value})`;
}

function getContrastText(color) {
  const [r, g, b] = hexToTriplet(color); // calculate contrast against grayscale

  var contrast = (Math.round(r * 299) + Math.round(g * 587) + Math.round(b * 114)) / 1000;
  return contrast >= 128 ? 'black' : 'white';
}

const _excluded$3 = ["modifiers"];
const Calendar = _ref => {
  let {
    modifiers
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded$3);

  const styles = useCalendarStyles();
  const indexOfMonday = 1;
  const augmentedModifiers = useMemo(() => _objectSpread(_objectSpread({}, modifiers), {}, {
    weekend: {
      daysOfWeek: [0, 6]
    }
  }), [modifiers]);
  return jsx("div", {
    css: styles
  }, jsx(DayPicker, _extends({
    firstDayOfWeek: indexOfMonday,
    modifiers: augmentedModifiers
  }, props)));
}; // Styles
// ------------------------------

const useCalendarStyles = () => {
  const {
    colors,
    palette
  } = useTheme();
  const cellSize = 40; // theme.sizing.base;

  const navButtonSize = 24; // theme.sizing.xsmall;

  const interactionColor = '#007AFF'; //theme.palette.actions.active;

  const rangeBetweenColor = hexToRgb('#007AFF', 0.2); //hexToRgb(interactionColor, 0.2);

  return {
    padding: 8,
    //theme.spacing.small,
    // resets and wrapper stuff
    '.DayPicker': {
      display: 'inline-block',
      fontSize: '1rem'
    },
    '.DayPicker-wrapper': {
      position: 'relative',
      flexDirection: 'row',
      userSelect: 'none',
      outline: 0
    },
    '.DayPicker-Months': {
      display: 'flex',
      flexWrap: 'wrap',
      justifyContent: 'center'
    },
    '.DayPicker-Month': {
      display: 'table',
      // separate weeks for easier parsing of range selection
      borderSpacing: '0 2px',
      borderCollapse: 'separate',
      // separate months for easier parsing of range selection
      margin: 8,
      // theme.spacing.small,
      // NOTE: resolve weird safari bug:
      // https://bugs.webkit.org/show_bug.cgi?id=187903
      position: 'relative',
      '.DayPicker-Caption > div': {
        position: 'absolute'
      }
    },
    // the caption is the day/month title e.g. "July 2020"
    '.DayPicker-Caption': {
      display: 'table-caption',
      height: navButtonSize,
      marginBottom: '0.5em',
      padding: '0 0.5em',
      textAlign: 'left'
    },
    '.DayPicker-Caption > div': {
      fontWeight: 500,
      //theme.typography.fontWeight.medium,
      fontSize: '1rem' //theme.typography.fontSize.medium,

    },
    // weekdays
    '.DayPicker-Weekdays': {
      display: 'table-header-group',
      marginTop: '1em'
    },
    '.DayPicker-WeekdaysRow': {
      display: 'table-row'
    },
    '.DayPicker-Weekday': {
      color: colors.foregroundDim,
      //theme.palette.text.dim,
      display: 'table-cell',
      fontSize: '0.875rem',
      //theme.typography.fontSize.small,
      fontWeight: 500,
      //theme.typography.fontWeight.medium,
      padding: '0.5em',
      textAlign: 'center'
    },
    '.DayPicker-Weekday abbr[title]': {
      borderBottom: 'none',
      textDecoration: 'none'
    },
    '.DayPicker-Body': {
      display: 'table-row-group',
      fontSize: '0.875rem',
      //theme.typography.fontSize.small,
      fontWeight: 500 // theme.typography.fontWeight.medium,

    },
    '.DayPicker-Week': {
      display: 'table-row'
    },
    '.DayPicker-WeekNumber': {
      display: 'table-cell',
      padding: '0.5em',
      minWidth: '1em',
      borderRight: '1px solid #EAECEC',
      color: colors.foregroundDim,
      //theme.palette.text.dim,
      verticalAlign: 'middle',
      textAlign: 'right',
      fontSize: '0.75em',
      cursor: 'pointer'
    },
    '.DayPicker--interactionDisabled .DayPicker-Day': {
      cursor: 'default'
    },
    // nav buttons
    '.DayPicker-NavBar': {
      display: 'flex',
      position: 'absolute',
      right: 4,
      //theme.spacing.xsmall,
      top: 4,
      //theme.spacing.xsmall,
      zIndex: 1
    },
    '.DayPicker-NavButton': {
      backgroundPosition: 'center',
      backgroundRepeat: 'no-repeat',
      // backgroundSize: '66.667%',
      borderRadius: 4,
      //theme.radii.xsmall,
      color: colors.foreground,
      // theme.palette.listItem.text,
      cursor: 'pointer',
      display: 'inline-block',
      height: 32,
      //theme.sizing.small,
      left: 'auto',
      width: 32,
      //theme.sizing.small,
      ':hover, &.focus-visible': {
        backgroundColor: 'grey',
        // theme.palette.listItem.backgroundFocused,
        color: colors.foreground,
        // theme.palette.listItem.textFocused,
        outline: 0
      },
      ':active': {
        backgroundColor: 'grey',
        //theme.palette.listItem.backgroundPressed,
        color: colors.foreground //theme.palette.listItem.textPressed,

      }
    },
    '.DayPicker-NavButton--next': {
      backgroundImage: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24' stroke='${encodeURIComponent(colors.foreground //theme.palette.listItem.text
      )}' stroke-width='2' fill='none' stroke-linecap='round' stroke-linejoin='round' %3E%3Cpolyline points='9 18 15 12 9 6'%3E%3C/polyline%3E%3C/svg%3E")`
    },
    '.DayPicker-NavButton--prev': {
      backgroundImage: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24' stroke='${encodeURIComponent(colors.foreground //theme.palette.listItem.text
      )}' stroke-width='2' fill='none' stroke-linecap='round' stroke-linejoin='round' %3E%3Cpolyline points='15 18 9 12 15 6'%3E%3C/polyline%3E%3C/svg%3E")`
    },
    // "day" or grid cell
    '.DayPicker-Day--outside': {
      color: colors.foregroundDim,
      // theme.palette.text.dim,
      cursor: 'default'
    },
    '.DayPicker-Day--disabled': {
      color: colors.foregroundDim,
      // theme.palette.text.dim,
      cursor: 'default'
    },
    '.DayPicker-Day': {
      borderRadius: '50%',
      display: 'table-cell',
      height: cellSize,
      outline: 0,
      // we handle focus below, with box-shadow
      padding: 0,
      position: 'relative',
      textAlign: 'center',
      verticalAlign: 'middle',
      width: cellSize
    },
    '.DayPicker-Day--weekend': {
      color: colors.foregroundMuted // theme.palette.text.muted,

    },
    '.DayPicker-Day:not(.DayPicker-Day--disabled):not(.DayPicker-Day--outside)': {
      cursor: 'pointer',
      '&:hover, &.focus-visible': {
        // backgroundColor: 'transparent',
        outline: 0,
        '&::after': {
          borderRadius: '50%',
          boxShadow: `inset 0 0 0 2px ${interactionColor}`,
          content: '" "',
          height: cellSize,
          left: 0,
          position: 'absolute',
          top: 0,
          width: cellSize
        }
      }
    },
    '.DayPicker-Day--today': {
      color: palette.red400,
      // theme.palette.text.critical,
      fontWeight: 700 // theme.typography.fontWeight.bold,

    },
    '.DayPicker-Day--selected:not(.DayPicker-Day--outside)': {
      color: getContrastText(interactionColor),
      '&, &:hover, &.focus-visible': {
        backgroundColor: interactionColor
      }
    },
    // range-specific day styles
    '.DayPicker-Day--rangeStart:not(.DayPicker-Day--outside), .DayPicker-Day--rangeEnd:not(.DayPicker-Day--outside)': {
      '&::before': {
        backgroundColor: rangeBetweenColor,
        position: 'absolute',
        content: '" "',
        width: cellSize / 2,
        height: cellSize,
        top: 0,
        zIndex: -1
      }
    },
    '.DayPicker-Day--rangeStart': {
      '&::before': {
        right: 0
      }
    },
    '.DayPicker-Day--rangeEnd': {
      '&::before': {
        left: 0
      }
    },
    '.DayPicker-Day--rangeBetween.DayPicker-Day--selected:not(.DayPicker-Day--outside)': {
      '&, &:hover, &.focus-visible': {
        backgroundColor: rangeBetweenColor,
        borderRadius: 0,
        color: colors.foreground // theme.palette.text.base,

      }
    },
    '.DayPicker-Day--rangeBetween.DayPicker-Day--firstOfMonth:not(.DayPicker-Day--outside)': {
      '&, &:hover, &.focus-visible': {
        // background: `linear-gradient(to left, ${rangeBetweenColor}, ${theme.palette.background.dialog})`,
        background: `linear-gradient(to left, ${rangeBetweenColor}, ${colors.overlayBackground})`
      }
    },
    '.DayPicker-Day--rangeBetween.DayPicker-Day--lastOfMonth:not(.DayPicker-Day--outside)': {
      '&, &:hover, &.focus-visible': {
        // background: `linear-gradient(to right, ${rangeBetweenColor}, ${theme.palette.background.dialog})`,
        background: `linear-gradient(to right, ${rangeBetweenColor}, ${colors.overlayBackground})`
      }
    }
  };
};

const _excluded$2 = ["align", "as"];

/**
 * What is this thing?
 * ------------------------------
 * We expose primitive components for adorning inputs with icons and buttons.
 * There's some awkard requirements surrounding size and shape that's best to
 * consolidate in one place.
 */
const AdornmentContext = /*#__PURE__*/createContext({
  shape: 'square',
  size: 'medium'
});

const useAdornmentContext = () => useContext(AdornmentContext); // Adornment Wrapper
// ------------------------------


const AdornmentWrapper = ({
  children,
  shape,
  size
}) => {
  return jsx(AdornmentContext.Provider, {
    value: {
      shape,
      size
    }
  }, jsx("div", {
    css: {
      alignItems: 'center',
      display: 'flex',
      position: 'relative',
      width: '100%'
    }
  }, children));
}; // Adornment Element
// ------------------------------

const alignmentPaddingMap = {
  left: 'marginLeft',
  right: 'marginRight'
};
const Adornment = forwardRefWithAs((_ref, ref) => {
  let {
    align,
    as: Tag = 'div'
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded$2);

  const {
    shape,
    size
  } = useAdornmentContext();
  const {
    controlSizes
  } = useTheme();
  const {
    indicatorBoxSize,
    paddingX
  } = controlSizes[size]; // optical alignment shifts towards the middle of the container with the large
  // border radius on "round" inputs. use padding rather than margin to optimise
  // the hit-area of interactive elements

  const offsetStyles = shape === 'round' ? {
    [alignmentPaddingMap[align]]: paddingX / 4
  } : null;
  return jsx(Tag, _extends({
    ref: ref,
    css: _objectSpread({
      [align]: 0,
      alignItems: 'center',
      display: 'flex',
      height: indicatorBoxSize,
      justifyContent: 'center',
      position: 'absolute',
      top: 0,
      width: indicatorBoxSize
    }, offsetStyles)
  }, props));
});

const _excluded$1 = ["invalid", "isSelected", "onClear"];
const InputButton = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    invalid = false,
    isSelected,
    onClear
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded$1);

  const {
    spacing
  } = useTheme();
  const inputTokens = useInputTokens({
    size: 'medium'
  });
  const inputStyles = useInputStyles({
    invalid,
    tokens: inputTokens
  });
  const focusStyles = isSelected ? _objectSpread(_objectSpread({}, inputStyles[':focus']), {}, {
    ':hover': inputStyles[':focus'],
    ':focus': inputStyles[':focus']
  }) : null;

  const buttonStyles = _objectSpread(_objectSpread(_objectSpread({}, inputStyles), focusStyles), {}, {
    cursor: 'pointer',
    lineHeight: 'initial',
    // let the button vertically align its text; the have different native behaviour to inputs
    textAlign: 'left'
  });

  return jsx(AdornmentWrapper, {
    shape: "square",
    size: "medium"
  }, jsx("button", _extends({
    "aria-invalid": invalid,
    ref: ref,
    css: buttonStyles,
    type: "button"
  }, props)), onClear && jsx(ClearButton, {
    onClick: onClear
  }), jsx(Adornment, {
    align: "right",
    css: {
      paddingRight: spacing.small,
      pointerEvents: 'none'
    }
  }, jsx(CalendarIcon, {
    color: "dim"
  })));
});

const ClearButton = props => {
  const {
    colors
  } = useTheme();
  return jsx(Adornment, _extends({
    as: "button",
    align: "right",
    type: "button",
    tabIndex: -1,
    css: {
      alignItems: 'center',
      background: 0,
      border: 0,
      borderRadius: '50%',
      color: colors.foregroundDim,
      display: 'flex',
      justifyContent: 'center',
      outline: 0,
      padding: 0,
      right: '6px',
      // TODO ? sizes.medium.boxSize,
      top: '6px',
      // TODO - magic number
      // No focus styles because this button is not focusable
      ':focus': {
        color: 'hotpink'
      },
      ':hover': {
        color: colors.foregroundMuted
      }
    }
  }, props), jsx(VisuallyHidden, {
    as: "span"
  }, "clear date value"), jsx(XIcon, {
    size: "small"
  }));
};

const _excluded = ["value", "onUpdate", "onClear", "onBlur"];
const DatePicker = _ref => {
  let {
    value,
    onUpdate,
    onClear,
    onBlur
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded);

  const {
    isOpen,
    setOpen,
    dialog,
    trigger,
    arrow
  } = usePopover({
    placement: 'bottom-start',
    modifiers: [{
      name: 'offset',
      options: {
        offset: [0, 8]
      }
    }]
  });
  const handleDayClick = useCallback(day => {
    onUpdate(formatDateType(day)); // wait a moment so the user has time to see the day become selected

    setTimeout(() => {
      setOpen(false);
    }, 300);
  }, [onUpdate, setOpen]);
  const selectedDay = new Date(value);
  const formattedDate = value ? formatDMY(new Date(value)) : undefined;
  return jsx(Fragment, null, jsx(InputButton, _extends({
    "aria-label": 'Choose date' + (formattedDate ? `, selected date is ${formattedDate}` : ''),
    onClick: () => setOpen(true),
    onClear: value ? onClear : undefined,
    isSelected: isOpen,
    ref: trigger.ref
  }, props, trigger.props, {
    // todo - magic number - align instead to parent Field ?
    style: {
      minWidth: 200
    }
  }), formattedDate || 'dd/mm/yyyy'), jsx(PopoverDialog, _extends({
    arrow: arrow,
    isVisible: isOpen,
    ref: dialog.ref
  }, dialog.props), jsx(FocusLock, {
    autoFocus: true,
    returnFocus: true,
    disabled: !isOpen
  }, jsx(Calendar, {
    onDayClick: handleDayClick,
    selectedDays: selectedDay
  }))));
};

export { Checkbox, CheckboxControl, DatePicker, FieldContainer, FieldLabel, FieldLegend, MultiSelect, Radio, Select, Switch, TextArea, TextInput, useIndicatorStyles, useIndicatorTokens, useInputStyles, useInputTokens };
