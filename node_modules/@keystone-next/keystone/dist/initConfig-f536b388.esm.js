import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import Path__default from 'path';
import { validate } from 'uuid';
import { isCuid } from 'cuid';
import { f as fieldType, o as orderDirectionEnum } from './sqlite-943cbaa7.esm.js';
import '@babel/runtime/helpers/objectWithoutProperties';
import { p as packagePath } from './package-path-7ba957ae.esm.js';
import { arg, ID, list, nonNull, inputObject } from '@graphql-ts/schema/api-without-context';
import { field } from '@graphql-ts/schema/api-with-context';

const views = Path__default.join(packagePath, '___internal-do-not-use-will-break-in-patch/admin-ui/id-field-view');
const idParsers = {
  autoincrement(val) {
    if (val === null) {
      throw new Error('Only an integer can be passed to id filters');
    }

    const parsed = parseInt(val);

    if (Number.isInteger(parsed)) {
      return parsed;
    }

    throw new Error('Only an integer can be passed to id filters');
  },

  cuid(val) {
    // isCuid is just "it's a string and it starts with c"
    // https://github.com/ericelliott/cuid/blob/215b27bdb78d3400d4225a4eeecb3b71891a5f6f/index.js#L69-L73
    if (typeof val === 'string' && isCuid(val)) {
      return val;
    }

    throw new Error('Only a cuid can be passed to id filters');
  },

  uuid(val) {
    if (typeof val === 'string' && validate(val)) {
      return val.toLowerCase();
    }

    throw new Error('Only a uuid can be passed to id filters');
  }

};
const nonCircularFields = {
  equals: arg({
    type: ID
  }),
  in: arg({
    type: list(nonNull(ID))
  }),
  notIn: arg({
    type: list(nonNull(ID))
  }),
  lt: arg({
    type: ID
  }),
  lte: arg({
    type: ID
  }),
  gt: arg({
    type: ID
  }),
  gte: arg({
    type: ID
  })
};
const IDFilter = inputObject({
  name: 'IDFilter',
  fields: () => _objectSpread(_objectSpread({}, nonCircularFields), {}, {
    not: arg({
      type: IDFilter
    })
  })
});
const filterArg = arg({
  type: IDFilter
});

function resolveVal(input, kind) {
  if (input === null) {
    throw new Error('id filter cannot be null');
  }

  const idParser = idParsers[kind];
  const obj = {};

  for (const key of ['equals', 'gt', 'gte', 'lt', 'lte']) {
    const val = input[key];

    if (val !== undefined) {
      const parsed = idParser(val);
      obj[key] = parsed;
    }
  }

  for (const key of ['in', 'notIn']) {
    const val = input[key];

    if (val !== undefined) {
      if (val === null) {
        throw new Error(`${key} id filter cannot be null`);
      }

      obj[key] = val.map(x => idParser(x));
    }
  }

  if (input.not !== undefined) {
    obj.not = resolveVal(input.not, kind);
  }

  return obj;
}

const idFieldType = config => meta => {
  const parseVal = idParsers[config.kind];
  return fieldType({
    kind: 'scalar',
    mode: 'required',
    scalar: config.kind === 'autoincrement' ? 'Int' : 'String',
    nativeType: meta.provider === 'postgresql' && config.kind === 'uuid' ? 'Uuid' : undefined,
    default: {
      kind: config.kind
    }
  })(_objectSpread(_objectSpread({}, config), {}, {
    // The ID field is always filterable and orderable.
    isFilterable: true,
    isOrderable: true,
    input: {
      where: {
        arg: filterArg,

        resolve(val) {
          return resolveVal(val, config.kind);
        }

      },
      uniqueWhere: {
        arg: arg({
          type: ID
        }),
        resolve: parseVal
      },
      orderBy: {
        arg: arg({
          type: orderDirectionEnum
        })
      }
    },
    output: field({
      type: nonNull(ID),

      resolve({
        value
      }) {
        return value.toString();
      }

    }),
    views,
    getAdminMeta: () => ({
      kind: config.kind
    }),
    ui: {
      createView: {
        fieldMode: 'hidden'
      },
      itemView: {
        fieldMode: 'hidden'
      }
    }
  }));
};

/* Validate lists config and default the id field */

function applyIdFieldDefaults(config) {
  var _config$db$idField;

  const lists = {};
  const defaultIdField = (_config$db$idField = config.db.idField) !== null && _config$db$idField !== void 0 ? _config$db$idField : {
    kind: 'cuid'
  };
  Object.keys(config.lists).forEach(key => {
    var _listConfig$db$idFiel, _listConfig$db;

    const listConfig = config.lists[key];

    if (listConfig.fields.id) {
      throw new Error(`A field with the \`id\` path is defined in the fields object on the ${JSON.stringify(key)} list. This is not allowed, use the idField option instead.`);
    }

    const idField = idFieldType((_listConfig$db$idFiel = (_listConfig$db = listConfig.db) === null || _listConfig$db === void 0 ? void 0 : _listConfig$db.idField) !== null && _listConfig$db$idFiel !== void 0 ? _listConfig$db$idFiel : defaultIdField);

    const fields = _objectSpread({
      id: idField
    }, listConfig.fields);

    lists[key] = _objectSpread(_objectSpread({}, listConfig), {}, {
      fields
    });
  });
  return lists;
}

/*
  This function executes the validation and other initialisation logic that
  needs to be run on Keystone Config before it can be used.
*/

function initConfig(config) {
  return _objectSpread(_objectSpread({}, config), {}, {
    lists: applyIdFieldDefaults(config)
  });
}

export { initConfig as i };
