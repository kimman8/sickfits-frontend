'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var Path = require('path');
var uuid = require('uuid');
var cuid = require('cuid');
var sqlite = require('./sqlite-b63545bc.cjs.dev.js');
require('@babel/runtime/helpers/objectWithoutProperties');
var packagePath = require('./package-path-d511a573.cjs.dev.js');
var apiWithoutContext = require('@graphql-ts/schema/api-without-context');
var apiWithContext = require('@graphql-ts/schema/api-with-context');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var Path__default = /*#__PURE__*/_interopDefault(Path);

const views = Path__default['default'].join(packagePath.packagePath, '___internal-do-not-use-will-break-in-patch/admin-ui/id-field-view');
const idParsers = {
  autoincrement(val) {
    if (val === null) {
      throw new Error('Only an integer can be passed to id filters');
    }

    const parsed = parseInt(val);

    if (Number.isInteger(parsed)) {
      return parsed;
    }

    throw new Error('Only an integer can be passed to id filters');
  },

  cuid(val) {
    // isCuid is just "it's a string and it starts with c"
    // https://github.com/ericelliott/cuid/blob/215b27bdb78d3400d4225a4eeecb3b71891a5f6f/index.js#L69-L73
    if (typeof val === 'string' && cuid.isCuid(val)) {
      return val;
    }

    throw new Error('Only a cuid can be passed to id filters');
  },

  uuid(val) {
    if (typeof val === 'string' && uuid.validate(val)) {
      return val.toLowerCase();
    }

    throw new Error('Only a uuid can be passed to id filters');
  }

};
const nonCircularFields = {
  equals: apiWithoutContext.arg({
    type: apiWithoutContext.ID
  }),
  in: apiWithoutContext.arg({
    type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.ID))
  }),
  notIn: apiWithoutContext.arg({
    type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.ID))
  }),
  lt: apiWithoutContext.arg({
    type: apiWithoutContext.ID
  }),
  lte: apiWithoutContext.arg({
    type: apiWithoutContext.ID
  }),
  gt: apiWithoutContext.arg({
    type: apiWithoutContext.ID
  }),
  gte: apiWithoutContext.arg({
    type: apiWithoutContext.ID
  })
};
const IDFilter = apiWithoutContext.inputObject({
  name: 'IDFilter',
  fields: () => _objectSpread(_objectSpread({}, nonCircularFields), {}, {
    not: apiWithoutContext.arg({
      type: IDFilter
    })
  })
});
const filterArg = apiWithoutContext.arg({
  type: IDFilter
});

function resolveVal(input, kind) {
  if (input === null) {
    throw new Error('id filter cannot be null');
  }

  const idParser = idParsers[kind];
  const obj = {};

  for (const key of ['equals', 'gt', 'gte', 'lt', 'lte']) {
    const val = input[key];

    if (val !== undefined) {
      const parsed = idParser(val);
      obj[key] = parsed;
    }
  }

  for (const key of ['in', 'notIn']) {
    const val = input[key];

    if (val !== undefined) {
      if (val === null) {
        throw new Error(`${key} id filter cannot be null`);
      }

      obj[key] = val.map(x => idParser(x));
    }
  }

  if (input.not !== undefined) {
    obj.not = resolveVal(input.not, kind);
  }

  return obj;
}

const idFieldType = config => meta => {
  const parseVal = idParsers[config.kind];
  return sqlite.fieldType({
    kind: 'scalar',
    mode: 'required',
    scalar: config.kind === 'autoincrement' ? 'Int' : 'String',
    nativeType: meta.provider === 'postgresql' && config.kind === 'uuid' ? 'Uuid' : undefined,
    default: {
      kind: config.kind
    }
  })(_objectSpread(_objectSpread({}, config), {}, {
    // The ID field is always filterable and orderable.
    isFilterable: true,
    isOrderable: true,
    input: {
      where: {
        arg: filterArg,

        resolve(val) {
          return resolveVal(val, config.kind);
        }

      },
      uniqueWhere: {
        arg: apiWithoutContext.arg({
          type: apiWithoutContext.ID
        }),
        resolve: parseVal
      },
      orderBy: {
        arg: apiWithoutContext.arg({
          type: sqlite.orderDirectionEnum
        })
      }
    },
    output: apiWithContext.field({
      type: apiWithoutContext.nonNull(apiWithoutContext.ID),

      resolve({
        value
      }) {
        return value.toString();
      }

    }),
    views,
    getAdminMeta: () => ({
      kind: config.kind
    }),
    ui: {
      createView: {
        fieldMode: 'hidden'
      },
      itemView: {
        fieldMode: 'hidden'
      }
    }
  }));
};

/* Validate lists config and default the id field */

function applyIdFieldDefaults(config) {
  var _config$db$idField;

  const lists = {};
  const defaultIdField = (_config$db$idField = config.db.idField) !== null && _config$db$idField !== void 0 ? _config$db$idField : {
    kind: 'cuid'
  };
  Object.keys(config.lists).forEach(key => {
    var _listConfig$db$idFiel, _listConfig$db;

    const listConfig = config.lists[key];

    if (listConfig.fields.id) {
      throw new Error(`A field with the \`id\` path is defined in the fields object on the ${JSON.stringify(key)} list. This is not allowed, use the idField option instead.`);
    }

    const idField = idFieldType((_listConfig$db$idFiel = (_listConfig$db = listConfig.db) === null || _listConfig$db === void 0 ? void 0 : _listConfig$db.idField) !== null && _listConfig$db$idFiel !== void 0 ? _listConfig$db$idFiel : defaultIdField);

    const fields = _objectSpread({
      id: idField
    }, listConfig.fields);

    lists[key] = _objectSpread(_objectSpread({}, listConfig), {}, {
      fields
    });
  });
  return lists;
}

/*
  This function executes the validation and other initialisation logic that
  needs to be run on Keystone Config before it can be used.
*/

function initConfig(config) {
  return _objectSpread(_objectSpread({}, config), {}, {
    lists: applyIdFieldDefaults(config)
  });
}

exports.initConfig = initConfig;
