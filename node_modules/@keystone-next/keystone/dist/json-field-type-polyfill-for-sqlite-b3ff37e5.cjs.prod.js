'use strict';

var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var sqlite = require('./sqlite-bb0466dc.cjs.prod.js');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var apiWithContext = require('@graphql-ts/schema/api-with-context');

const _excluded = ["mode"];
const objectEntriesButAssumeNoExtraProperties = Object.entries;

function internalResolveFilter(entries, mode) {
  const entry = entries.shift();
  if (entry === undefined) return {};
  const [key, val] = entry;

  if (val == null) {
    return {
      AND: [{
        [key]: val
      }, internalResolveFilter(entries, mode)]
    };
  }

  switch (key) {
    case 'equals':
    case 'lt':
    case 'lte':
    case 'gt':
    case 'gte':
    case 'in':
    case 'contains':
    case 'startsWith':
    case 'endsWith':
      {
        return {
          AND: [{
            [key]: val,
            mode
          }, {
            not: null
          }, internalResolveFilter(entries, mode)]
        };
      }

    case 'notIn':
      {
        return {
          AND: [{
            NOT: [internalResolveFilter(objectEntriesButAssumeNoExtraProperties({
              in: val
            }), mode)]
          }, internalResolveFilter(entries, mode)]
        };
      }

    case 'not':
      {
        return {
          AND: [{
            NOT: [internalResolveFilter(objectEntriesButAssumeNoExtraProperties(val), mode)]
          }, internalResolveFilter(entries, mode)]
        };
      }
  }
}

function resolveCommon(val) {
  if (val === null) return null;
  return internalResolveFilter(objectEntriesButAssumeNoExtraProperties(val), undefined);
}
function resolveString(val) {
  if (val === null) return null;

  let {
    mode
  } = val,
      rest = _objectWithoutProperties(val, _excluded);

  return internalResolveFilter(objectEntriesButAssumeNoExtraProperties(rest), mode);
}

var filters = /*#__PURE__*/Object.freeze({
  __proto__: null,
  postgresql: sqlite.postgresql,
  sqlite: sqlite.sqlite,
  resolveCommon: resolveCommon,
  resolveString: resolveString
});

function mapOutputFieldToSQLite(field) {
  const innerResolver = field.resolve || (({
    value
  }) => value);

  return apiWithContext.fields()({
    value: apiWithContext.field({
      type: field.type,
      args: field.args,
      deprecationReason: field.deprecationReason,
      description: field.description,
      extensions: field.extensions,

      resolve(rootVal, ...extra) {
        if (rootVal.value === null) {
          return innerResolver(rootVal, ...extra);
        }

        let value = null;

        try {
          value = JSON.parse(rootVal.value);
        } catch (err) {}

        return innerResolver({
          item: rootVal.item,
          value
        }, ...extra);
      }

    })
  }).value;
}

function mapUpdateInputArgToSQLite(arg) {
  if (arg === undefined) {
    return undefined;
  }

  return {
    arg: arg.arg,

    async resolve(input, context, relationshipInputResolver) {
      const resolvedInput = arg.resolve === undefined ? input : await arg.resolve(input, context, relationshipInputResolver);

      if (resolvedInput === undefined || resolvedInput === null) {
        return resolvedInput;
      }

      return JSON.stringify(resolvedInput);
    }

  };
}

function mapCreateInputArgToSQLite(arg) {
  if (arg === undefined) {
    return undefined;
  }

  return {
    arg: arg.arg,

    async resolve(input, context, relationshipInputResolver) {
      const resolvedInput = arg.resolve === undefined ? input : await arg.resolve(input, context, relationshipInputResolver);

      if (resolvedInput === undefined || resolvedInput === null) {
        return resolvedInput;
      }

      return JSON.stringify(resolvedInput);
    }

  };
}

function jsonFieldTypePolyfilledForSQLite(provider, config) {
  if (provider === 'sqlite') {
    var _config$input, _config$input2;

    return sqlite.fieldType({
      kind: 'scalar',
      mode: 'optional',
      scalar: 'String'
    })(_objectSpread(_objectSpread({}, config), {}, {
      input: {
        create: mapCreateInputArgToSQLite((_config$input = config.input) === null || _config$input === void 0 ? void 0 : _config$input.create),
        update: mapUpdateInputArgToSQLite((_config$input2 = config.input) === null || _config$input2 === void 0 ? void 0 : _config$input2.update)
      },
      output: mapOutputFieldToSQLite(config.output),
      extraOutputFields: Object.fromEntries(Object.entries(config.extraOutputFields || {}).map(([key, field]) => [key, mapOutputFieldToSQLite(field)]))
    }));
  }

  return sqlite.fieldType({
    kind: 'scalar',
    mode: 'optional',
    scalar: 'Json'
  })(config);
}

exports.filters = filters;
exports.jsonFieldTypePolyfilledForSQLite = jsonFieldTypePolyfilledForSQLite;
exports.resolveCommon = resolveCommon;
exports.resolveString = resolveString;
