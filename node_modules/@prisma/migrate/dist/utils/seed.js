var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
__export(exports, {
  detectSeedFiles: () => detectSeedFiles,
  getScriptsFromPackageJson: () => getScriptsFromPackageJson,
  isPackageInstalledGlobally: () => isPackageInstalledGlobally,
  tryToRunSeed: () => tryToRunSeed
});
var import_fs = __toModule(require("fs"));
var import_path = __toModule(require("path"));
var import_execa = __toModule(require("execa"));
var import_resolve_pkg = __toModule(require("resolve-pkg"));
var import_has_yarn = __toModule(require("has-yarn"));
var import_chalk = __toModule(require("chalk"));
var import_global_dirs = __toModule(require("global-dirs"));
var import_pkg_up = __toModule(require("pkg-up"));
var import_util = __toModule(require("util"));
const readFileAsync = (0, import_util.promisify)(import_fs.default.readFile);
function isPackageInstalledGlobally(packageName) {
  try {
    const usingGlobalYarn = import_fs.default.existsSync(import_path.default.join(import_global_dirs.default.yarn.packages, packageName));
    const usingGlobalNpm = import_fs.default.existsSync(import_path.default.join(import_global_dirs.default.npm.packages, packageName));
    if (usingGlobalNpm) {
      return "npm";
    }
    if (usingGlobalYarn) {
      return "yarn";
    } else {
      false;
    }
  } catch (e) {
  }
  return false;
}
function detectSeedFiles(schemaPath) {
  let parentDirectory = import_path.default.relative(process.cwd(), import_path.default.join(process.cwd(), "prisma"));
  if (schemaPath) {
    parentDirectory = import_path.default.relative(process.cwd(), import_path.default.dirname(schemaPath));
  }
  const seedPath = import_path.default.join(parentDirectory, "seed.");
  const detected = {
    seedPath,
    numberOfSeedFiles: 0,
    js: "",
    ts: "",
    sh: ""
  };
  const extensions = ["js", "ts", "sh"];
  for (const extension of extensions) {
    const fullPath = seedPath + extension;
    if (!import_fs.default.existsSync(fullPath)) {
      continue;
    }
    detected[extension] = fullPath;
    detected.numberOfSeedFiles++;
  }
  return detected;
}
function getSeedScript(type, seedFilepath) {
  let script = `
console.info('Result:')

const __seed = require('./${seedFilepath}')
const __keys = Object.keys(__seed)

async function runSeed() {
  // Execute "seed" named export or default export
  if (__keys && __keys.length) {
    if (__keys.indexOf('seed') !== -1) {
      return __seed.seed()
    } else if (__keys.indexOf('default') !== -1) {
      return __seed.default()
    }
  }
}

runSeed()
  .then(function (result) {
    if (result) {
      console.log(result)
    }
  })
  .catch(function (e) {
    console.error('Error from seed:')
    throw e
  })
`;
  if (type === "TS") {
    script = `
// @ts-ignore
declare const require: any

${script}

export {}
`;
  }
  return script;
}
async function tryToRunSeed(schemaPath) {
  const detected = detectSeedFiles(schemaPath);
  if (detected.numberOfSeedFiles === 0) {
    throw new Error(`No seed file found.
Create a \`seed.ts\`, \`.js\` or \`.sh\` file in the prisma directory.`);
  } else if (detected.numberOfSeedFiles > 1) {
    throw new Error(`More than one seed file was found in \`${import_path.default.relative(process.cwd(), import_path.default.dirname(detected.seedPath))}\` directory.
This command only supports one seed file: Use \`seed.ts\`, \`.js\` or \`.sh\`.`);
  } else {
    if (detected.js) {
      console.info(`Running seed from ${import_chalk.default.bold(`"${detected.js}"`)} ...`);
      return await (0, import_execa.default)("node", [`-e "${getSeedScript("JS", detected.js)}"`], {
        shell: true,
        stdio: "inherit"
      });
    } else if (detected.ts) {
      const hasTypescriptPkg = (0, import_resolve_pkg.default)("typescript") || isPackageInstalledGlobally("typescript");
      const hasTsNodePkg = (0, import_resolve_pkg.default)("ts-node") || isPackageInstalledGlobally("ts-node");
      const hasTypesNodePkg = (0, import_resolve_pkg.default)("@types/node");
      const missingPkgs = [];
      if (!hasTypescriptPkg) {
        missingPkgs.push("typescript");
      }
      if (!hasTsNodePkg) {
        missingPkgs.push("ts-node");
      }
      if (!hasTypesNodePkg) {
        missingPkgs.push("@types/node");
      }
      if (missingPkgs.length > 0) {
        const packageManager = (0, import_has_yarn.default)() ? "yarn add -D" : "npm i -D";
        console.info(`We detected a seed file at \`${detected.ts}\` but it seems that you do not have the following dependencies installed:
${missingPkgs.map((name) => `- ${name}`).join("\n")}

To install them run: ${import_chalk.default.green(`${packageManager} ${missingPkgs.join(" ")}`)}
`);
      }
      const scripts = await getScriptsFromPackageJson();
      let tsNodeCommand = "ts-node";
      let tsNodeArgs = `--eval "${getSeedScript("TS", detected.ts)}"`;
      if (scripts == null ? void 0 : scripts["ts-node"]) {
        tsNodeCommand = scripts["ts-node"];
        tsNodeArgs = `"${detected.ts}"`;
        console.info(`Running seed: ${import_chalk.default.bold(`${tsNodeCommand} ${tsNodeArgs}`)} ...`);
      } else {
        console.info(`Running seed from ${import_chalk.default.bold(`${detected.ts}`)} ...`);
      }
      return await (0, import_execa.default)(tsNodeCommand, [tsNodeArgs], {
        shell: true,
        stdio: "inherit"
      });
    } else if (detected.sh) {
      console.info(`Running seed: ${import_chalk.default.bold(`sh "${detected.sh}"`)} ...`);
      return await (0, import_execa.default)("sh", [`"${detected.sh}"`], {
        shell: true,
        stdio: "inherit"
      });
    }
  }
  return void 0;
}
async function getScriptsFromPackageJson(cwd = process.cwd()) {
  try {
    const pkgJsonPath = await (0, import_pkg_up.default)({ cwd });
    if (!pkgJsonPath) {
      return null;
    }
    const pkgJsonString = await readFileAsync(pkgJsonPath, "utf-8");
    const pkgJson = JSON.parse(pkgJsonString);
    const { "ts-node": tsnode } = pkgJson.scripts;
    return { "ts-node": tsnode };
  } catch (e) {
    return null;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  detectSeedFiles,
  getScriptsFromPackageJson,
  isPackageInstalledGlobally,
  tryToRunSeed
});
