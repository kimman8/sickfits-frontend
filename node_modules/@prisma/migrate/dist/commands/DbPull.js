var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
__export(exports, {
  DbPull: () => DbPull
});
var import_sdk = __toModule(require("@prisma/sdk"));
var import_chalk = __toModule(require("chalk"));
var import_path = __toModule(require("path"));
var import_sdk2 = __toModule(require("@prisma/sdk"));
var import_formatms = __toModule(require("../utils/formatms"));
var import_fs = __toModule(require("fs"));
var import_convertCredentials = __toModule(require("@prisma/sdk/dist/convertCredentials"));
var import_printDatasources = __toModule(require("../utils/printDatasources"));
var import_removeDatasource = __toModule(require("../utils/removeDatasource"));
var import_errors = __toModule(require("../utils/errors"));
var import_printDatasource = __toModule(require("../utils/printDatasource"));
const _DbPull = class {
  static new() {
    return new _DbPull();
  }
  printUrlAsDatasource(url) {
    const provider = (0, import_convertCredentials.protocolToConnectorType)(`${url.split(":")[0]}:`);
    return (0, import_printDatasources.printDatasources)([
      {
        config: {},
        provider,
        name: "db",
        url
      }
    ]);
  }
  async parse(argv) {
    const args = (0, import_sdk.arg)(argv, {
      "--help": Boolean,
      "-h": "--help",
      "--url": String,
      "--print": Boolean,
      "--schema": String,
      "--force": Boolean,
      "--experimental-reintrospection": Boolean,
      "--clean": Boolean
    });
    const log = (...messages) => {
      if (!args["--print"]) {
        console.info(...messages);
      }
    };
    if (args instanceof Error) {
      return this.help(args.message);
    }
    if (args["--help"]) {
      return this.help();
    }
    if (args["--clean"] || args["--experimental-reintrospection"]) {
      const renamedMessages = [];
      if (args["--experimental-reintrospection"]) {
        renamedMessages.push(`The ${import_chalk.default.redBright("--experimental-reintrospection")} flag has been removed and is now the default behavior of ${import_chalk.default.greenBright("prisma db pull")}.`);
      }
      if (args["--clean"]) {
        renamedMessages.push(`The ${import_chalk.default.redBright("--clean")} flag has been renamed to ${import_chalk.default.greenBright("--force")}.`);
      }
      console.error(`
${renamedMessages.join("\n")}
`);
      process.exit(1);
    }
    const url = args["--url"];
    let schemaPath = await (0, import_sdk.getSchemaPath)(args["--schema"]);
    if (schemaPath && !args["--print"]) {
      console.info(import_chalk.default.dim(`Prisma schema loaded from ${import_path.default.relative(process.cwd(), schemaPath)}`));
      await (0, import_printDatasource.printDatasource)(schemaPath);
    }
    if (!url && !schemaPath) {
      throw new import_errors.NoSchemaFoundError();
    }
    let schema = null;
    if (url && schemaPath) {
      schema = this.printUrlAsDatasource(url);
      const rawSchema = import_fs.default.readFileSync(schemaPath, "utf-8");
      schema += (0, import_removeDatasource.removeDatasource)(rawSchema);
    } else if (url) {
      schema = this.printUrlAsDatasource(url);
    } else if (schemaPath) {
      schema = import_fs.default.readFileSync(schemaPath, "utf-8");
    } else {
      throw new Error("Could not find a `schema.prisma` file");
    }
    const engine = new import_sdk2.IntrospectionEngine({
      cwd: schemaPath ? import_path.default.dirname(schemaPath) : void 0
    });
    const basedOn = !args["--url"] && schemaPath ? ` based on datasource defined in ${import_chalk.default.underline(import_path.default.relative(process.cwd(), schemaPath))}` : "";
    log(`
Introspecting${basedOn} \u2026`);
    const before = Date.now();
    let introspectionSchema = "";
    let introspectionWarnings;
    let introspectionSchemaVersion;
    try {
      const introspectionResult = await engine.introspect(schema, args["--force"]);
      introspectionSchema = introspectionResult.datamodel;
      introspectionWarnings = introspectionResult.warnings;
      introspectionSchemaVersion = introspectionResult.version;
    } catch (e) {
      if (e.code === "P4001") {
        if (introspectionSchema.trim() === "") {
          throw new Error(`
${import_chalk.default.red.bold("P4001 ")}${import_chalk.default.red("The introspected database was empty:")} ${url ? import_chalk.default.underline(url) : ""}

${import_chalk.default.bold("prisma db pull")} could not create any models in your ${import_chalk.default.bold("schema.prisma")} file and you will not be able to generate Prisma Client with the ${import_chalk.default.bold((0, import_sdk.getCommandWithExecutor)("prisma generate"))} command.

${import_chalk.default.bold("To fix this, you have two options:")}

- manually create a table in your database (using SQL).
- make sure the database connection URL inside the ${import_chalk.default.bold("datasource")} block in ${import_chalk.default.bold("schema.prisma")} points to a database that is not empty (it must contain at least one table).

Then you can run ${import_chalk.default.green((0, import_sdk.getCommandWithExecutor)("prisma db pull"))} again. 
`);
        }
      } else if (e.code === "P1012") {
        console.info();
        throw new Error(`${import_chalk.default.red(`${e.code} Introspection failed as your current Prisma schema file is invalid`)}

Please fix your current schema manually, use ${import_chalk.default.green((0, import_sdk.getCommandWithExecutor)("prisma validate"))} to confirm it is valid and then run this command again.
Or run this command with the ${import_chalk.default.green("--force")} flag to ignore your current schema and overwrite it. All local modifications will be lost.
`);
      }
      throw e;
    }
    function getWarningMessage(warnings) {
      if (warnings.length > 0) {
        let message = `
*** WARNING ***
`;
        for (const warning of warnings) {
          message += `
${warning.message}
`;
          if (warning.code === 0) {
          } else if (warning.code === 1) {
            message += warning.affected.map((it) => `- "${it.model}"`).join("\n");
          } else if (warning.code === 2) {
            const modelsGrouped = warning.affected.reduce((acc, it) => {
              if (!acc[it.model]) {
                acc[it.model] = [];
              }
              acc[it.model].push(it.field);
              return acc;
            }, {});
            message += Object.entries(modelsGrouped).map(([model, fields]) => `- Model: "${model}"
  Field(s): "${fields.join('", "')}"`).join("\n");
          } else if (warning.code === 3) {
            message += warning.affected.map((it) => `- Model "${it.model}", field: "${it.field}", original data type: "${it.tpe}"`).join("\n");
          } else if (warning.code === 4) {
            message += warning.affected.map((it) => `- Enum "${it.enm}", value: "${it.value}"`).join("\n");
          } else if (warning.code === 5 || warning.code === 6 || warning.code === 8 || warning.code === 11 || warning.code === 12 || warning.code === 13) {
            message += warning.affected.map((it) => `- Model "${it.model}", field: "${it.field}"`).join("\n");
          } else if (warning.code === 7) {
            message += warning.affected.map((it) => `- Model "${it.model}"`).join("\n");
          } else if (warning.code === 9 || warning.code === 10) {
            message += warning.affected.map((it) => `- Enum "${it.enm}"`).join("\n");
          } else if (warning.affected) {
            message += `Code ${warning.code}
${JSON.stringify(warning.affected, null, 2)}`;
          }
          message += `
`;
        }
        return message;
      }
      return void 0;
    }
    const introspectionWarningsMessage = getWarningMessage(introspectionWarnings) || "";
    const prisma1UpgradeMessage = introspectionSchemaVersion.includes("Prisma1") ? `
${import_chalk.default.bold("Upgrading from Prisma 1 to Prisma 2?")}
      
The database you introspected could belong to a Prisma 1 project.

Please run the following command to upgrade to Prisma 2.0:
${import_chalk.default.green("npx prisma-upgrade [path-to-prisma-yml] [path-to-schema-prisma]")}

Note: \`prisma.yml\` and \`schema.prisma\` paths are optional.
 
Learn more about the upgrade process in the docs:
${(0, import_sdk.link)("https://pris.ly/d/upgrading-to-prisma2")}
` : "";
    if (args["--print"]) {
      console.log(introspectionSchema);
      introspectionSchemaVersion && console.log(`
// introspectionSchemaVersion: ${introspectionSchemaVersion}`, prisma1UpgradeMessage.replace(/(\n)/gm, "\n// "));
      if (introspectionWarningsMessage.trim().length > 0) {
        console.error(introspectionWarningsMessage.replace(/(\n)/gm, "\n// "));
      }
    } else {
      schemaPath = schemaPath || "schema.prisma";
      import_fs.default.writeFileSync(schemaPath, introspectionSchema);
      const modelsCount = (introspectionSchema.match(/^model\s+/gm) || []).length;
      const prisma1UpgradeMessageBox = prisma1UpgradeMessage ? "\n\n" + (0, import_sdk.drawBox)({
        height: 16,
        width: 74,
        str: prisma1UpgradeMessage + "\nOnce you upgraded your database schema to Prisma 2.0, \ncontinue with the instructions below.\n",
        horizontalPadding: 2
      }) : "";
      log(`
\u2714 Introspected ${modelsCount} ${modelsCount > 1 ? "models and wrote them" : "model and wrote it"} into ${import_chalk.default.underline(import_path.default.relative(process.cwd(), schemaPath))} in ${import_chalk.default.bold((0, import_formatms.formatms)(Date.now() - before))}${prisma1UpgradeMessageBox}
      ${import_chalk.default.keyword("orange")(introspectionWarningsMessage)}
${`Run ${import_chalk.default.green((0, import_sdk.getCommandWithExecutor)("prisma generate"))} to generate Prisma Client.`}`);
    }
    engine.stop();
    return "";
  }
  help(error) {
    if (error) {
      return new import_sdk.HelpError(`
${import_chalk.default.bold.red(`!`)} ${error}
${_DbPull.help}`);
    }
    return _DbPull.help;
  }
};
let DbPull = _DbPull;
DbPull.help = (0, import_sdk.format)(`
Pull the state from the database to the Prisma schema using introspection

${import_chalk.default.bold("Usage")}

  ${import_chalk.default.dim("$")} prisma db pull [options]

${import_chalk.default.bold("Options")}

  -h, --help   Display this help message
    --schema   Custom path to your Prisma schema
     --force   Ignore current Prisma schema file
     --print   Print the introspected Prisma schema to stdout

${import_chalk.default.bold("Examples")}

With an existing Prisma schema
  ${import_chalk.default.dim("$")} prisma db pull

Or specify a Prisma schema path
  ${import_chalk.default.dim("$")} prisma db pull --schema=./schema.prisma

Instead of saving the result to the filesystem, you can also print it to stdout
  ${import_chalk.default.dim("$")} prisma db pull --print

`);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DbPull
});
