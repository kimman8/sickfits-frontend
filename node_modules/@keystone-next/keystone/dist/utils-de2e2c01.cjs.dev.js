'use strict';

var prompts = require('prompts');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var Path = require('path');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var prompts__default = /*#__PURE__*/_interopDefault(prompts);
var Path__default = /*#__PURE__*/_interopDefault(Path);

// prompts also returns an undefined value on SIGINT which we really just want to exit on

async function confirmPromptImpl(message) {
  const {
    value
  } = await prompts__default['default']({
    name: 'value',
    type: 'confirm',
    message,
    initial: true
  });

  if (value === undefined) {
    process.exit(1);
  }

  return value;
}

async function textPromptImpl(message) {
  const {
    value
  } = await prompts__default['default']({
    name: 'value',
    type: 'text',
    message
  });

  if (value === undefined) {
    process.exit(1);
  }

  return value;
}

let shouldPrompt = process.stdout.isTTY && !process.env.SKIP_PROMPTS;
let confirmPrompt = confirmPromptImpl;
let textPrompt = textPromptImpl; // we could do this with jest.mock but i find jest.mock unpredictable and this is much easier to understand

function getConfigPath(cwd) {
  return Path__default['default'].join(cwd, 'keystone');
}
function getAdminPath(cwd) {
  return Path__default['default'].join(cwd, '.keystone/admin');
}
class ExitError extends Error {
  constructor(code) {
    super(`The process should exit with ${code}`);

    _defineProperty(this, "code", void 0);

    this.code = code;
  }

}

exports.ExitError = ExitError;
exports.confirmPrompt = confirmPrompt;
exports.getAdminPath = getAdminPath;
exports.getConfigPath = getConfigPath;
exports.shouldPrompt = shouldPrompt;
exports.textPrompt = textPrompt;
