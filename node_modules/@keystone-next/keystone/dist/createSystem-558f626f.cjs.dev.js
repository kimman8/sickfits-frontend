'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var core = require('./core-c8ecce23.cjs.dev.js');
var sqlite = require('./sqlite-b63545bc.cjs.dev.js');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var graphql$1 = require('graphql');
var Path = require('path');
var fs = require('fs-extra');
require('fast-glob');
require('prettier');
require('resolve');
var hashString = require('@emotion/hash');
var adminMetaGraphql = require('./admin-meta-graphql-1e30b380.cjs.dev.js');
var graphqlTsSchema = require('@graphql-ts/schema');
var session_dist_keystone = require('../session/dist/keystone.cjs.dev.js');
var _classPrivateFieldInitSpec = require('@babel/runtime/helpers/classPrivateFieldInitSpec');
var _classPrivateFieldGet = require('@babel/runtime/helpers/classPrivateFieldGet');
var _classPrivateFieldSet = require('@babel/runtime/helpers/classPrivateFieldSet');
var pLimit = require('p-limit');
var pluralize = require('pluralize');
var apolloServerErrors = require('apollo-server-errors');
var apiWithContext = require('@graphql-ts/schema/api-with-context');
var apiWithoutContext = require('@graphql-ts/schema/api-without-context');
var uuid = require('uuid');
var fromBuffer = require('image-type');
var imageSize = require('image-size');
var fields_types_image_utils_dist_keystone = require('../fields/types/image/utils/dist/keystone.cjs.dev.js');
var fetch = require('node-fetch');
var FormData = require('form-data');
var crypto = require('crypto');
var stream = require('stream');
var filenamify = require('filenamify');
var slugify = require('@sindresorhus/slugify');
var fields_types_file_utils_dist_keystone = require('../fields/types/file/utils/dist/keystone.cjs.dev.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var Path__namespace = /*#__PURE__*/_interopNamespace(Path);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var hashString__default = /*#__PURE__*/_interopDefault(hashString);
var pLimit__default = /*#__PURE__*/_interopDefault(pLimit);
var pluralize__default = /*#__PURE__*/_interopDefault(pluralize);
var fromBuffer__default = /*#__PURE__*/_interopDefault(fromBuffer);
var imageSize__default = /*#__PURE__*/_interopDefault(imageSize);
var fetch__default = /*#__PURE__*/_interopDefault(fetch);
var FormData__default = /*#__PURE__*/_interopDefault(FormData);
var crypto__default = /*#__PURE__*/_interopDefault(crypto);
var filenamify__default = /*#__PURE__*/_interopDefault(filenamify);
var slugify__default = /*#__PURE__*/_interopDefault(slugify);

/**
 * Converts the first character of a string to uppercase.
 * @param {String} str The string to convert.
 * @returns The new string
 */
const upcase = str => str.substr(0, 1).toUpperCase() + str.substr(1);
/**
 * Turns a passed in string into
 * a human readable label
 * @param {String} str The string to convert.
 * @returns The new string
 */

const humanize = str => {
  return str.replace(/([a-z])([A-Z]+)/g, '$1 $2').split(/\s|_|\-/).filter(i => i).map(upcase).join(' ');
};

function createAdminMeta(config, initialisedLists) {
  const {
    ui,
    lists,
    session
  } = config;
  const adminMetaRoot = {
    enableSessionItem: (ui === null || ui === void 0 ? void 0 : ui.enableSessionItem) || false,
    enableSignout: session !== undefined,
    listsByKey: {},
    lists: [],
    views: []
  };

  for (const [key, list] of Object.entries(initialisedLists)) {
    var _ref, _listConfig$ui, _listConfig$ui2, _listConfig$ui2$listV, _ref2, _listConfig$ui$descri, _listConfig$ui3, _listConfig$ui$listVi, _listConfig$ui4, _listConfig$ui4$listV, _ref3, _listConfig$ui5, _listConfig$ui5$listV;

    const listConfig = lists[key]; // Default the labelField to `name`, `label`, or `title` if they exist; otherwise fall back to `id`

    const labelField = (_ref = (_listConfig$ui = listConfig.ui) === null || _listConfig$ui === void 0 ? void 0 : _listConfig$ui.labelField) !== null && _ref !== void 0 ? _ref : listConfig.fields.label ? 'label' : listConfig.fields.name ? 'name' : listConfig.fields.title ? 'title' : 'id';
    let initialColumns;

    if ((_listConfig$ui2 = listConfig.ui) !== null && _listConfig$ui2 !== void 0 && (_listConfig$ui2$listV = _listConfig$ui2.listView) !== null && _listConfig$ui2$listV !== void 0 && _listConfig$ui2$listV.initialColumns) {
      // If they've asked for a particular thing, give them that thing
      initialColumns = listConfig.ui.listView.initialColumns;
    } else {
      // Otherwise, we'll start with the labelField on the left and then add
      // 2 more fields to the right of that. We don't include the 'id' field
      // unless it happened to be the labelField
      initialColumns = [labelField, ...Object.keys(list.fields).filter(fieldKey => list.fields[fieldKey].graphql.isEnabled.read).filter(fieldKey => fieldKey !== labelField).filter(fieldKey => fieldKey !== 'id')].slice(0, 3);
    }

    adminMetaRoot.listsByKey[key] = {
      key,
      labelField,
      description: (_ref2 = (_listConfig$ui$descri = (_listConfig$ui3 = listConfig.ui) === null || _listConfig$ui3 === void 0 ? void 0 : _listConfig$ui3.description) !== null && _listConfig$ui$descri !== void 0 ? _listConfig$ui$descri : listConfig.description) !== null && _ref2 !== void 0 ? _ref2 : null,
      label: list.adminUILabels.label,
      singular: list.adminUILabels.singular,
      plural: list.adminUILabels.plural,
      path: list.adminUILabels.path,
      fields: [],
      pageSize: (_listConfig$ui$listVi = (_listConfig$ui4 = listConfig.ui) === null || _listConfig$ui4 === void 0 ? void 0 : (_listConfig$ui4$listV = _listConfig$ui4.listView) === null || _listConfig$ui4$listV === void 0 ? void 0 : _listConfig$ui4$listV.pageSize) !== null && _listConfig$ui$listVi !== void 0 ? _listConfig$ui$listVi : 50,
      initialColumns,
      initialSort: (_ref3 = (_listConfig$ui5 = listConfig.ui) === null || _listConfig$ui5 === void 0 ? void 0 : (_listConfig$ui5$listV = _listConfig$ui5.listView) === null || _listConfig$ui5$listV === void 0 ? void 0 : _listConfig$ui5$listV.initialSort) !== null && _ref3 !== void 0 ? _ref3 : null,
      // TODO: probably remove this from the GraphQL schema and here
      itemQueryName: key,
      listQueryName: list.pluralGraphQLName
    };
    adminMetaRoot.lists.push(adminMetaRoot.listsByKey[key]);
  }

  let uniqueViewCount = -1;
  const stringViewsToIndex = {};

  function getViewId(view) {
    if (stringViewsToIndex[view] !== undefined) {
      return stringViewsToIndex[view];
    }

    uniqueViewCount++;
    stringViewsToIndex[view] = uniqueViewCount;
    adminMetaRoot.views.push(view);
    return uniqueViewCount;
  } // Populate .fields array


  for (const [key, list] of Object.entries(initialisedLists)) {
    var _config$lists$key$ui$, _config$lists$key$ui, _config$lists$key$ui2;

    const searchFields = new Set((_config$lists$key$ui$ = (_config$lists$key$ui = config.lists[key].ui) === null || _config$lists$key$ui === void 0 ? void 0 : _config$lists$key$ui.searchFields) !== null && _config$lists$key$ui$ !== void 0 ? _config$lists$key$ui$ : []);

    if (searchFields.has('id')) {
      throw new Error(`The ui.searchFields option on the ${key} list includes 'id'. Lists can always be searched by an item's id so it must not be specified as a search field`);
    }

    const whereInputFields = list.types.where.graphQLType.getFields();

    if (((_config$lists$key$ui2 = config.lists[key].ui) === null || _config$lists$key$ui2 === void 0 ? void 0 : _config$lists$key$ui2.searchFields) === undefined) {
      const labelField = adminMetaRoot.listsByKey[key].labelField;
      const potentialFilterField = whereInputFields[`${labelField}_contains_i`] || whereInputFields[`${labelField}_contains`];

      if ((potentialFilterField === null || potentialFilterField === void 0 ? void 0 : potentialFilterField.type) === graphql$1.GraphQLString) {
        searchFields.add(labelField);
      }
    }

    for (const [fieldKey, field] of Object.entries(list.fields)) {
      var _field$label, _field$ui;

      // FIXME: Disabling this entirely for now until the Admin UI can properly
      // handle `omit: ['read']` correctly.
      if (field.graphql.isEnabled.read === false) continue;
      let search = null;

      if (searchFields.has(fieldKey)) {
        var _whereInputFields$, _whereInputFields$2;

        if (((_whereInputFields$ = whereInputFields[`${fieldKey}_contains_i`]) === null || _whereInputFields$ === void 0 ? void 0 : _whereInputFields$.type) === graphql$1.GraphQLString) {
          search = 'insensitive';
        } else if (((_whereInputFields$2 = whereInputFields[`${fieldKey}_contains`]) === null || _whereInputFields$2 === void 0 ? void 0 : _whereInputFields$2.type) === graphql$1.GraphQLString) {
          search = 'default';
        } else {
          throw new Error(`The ui.searchFields option on the ${key} list includes '${fieldKey}' but that field doesn't have a contains filter that accepts a GraphQL String`);
        }
      }

      adminMetaRoot.listsByKey[key].fields.push({
        label: (_field$label = field.label) !== null && _field$label !== void 0 ? _field$label : humanize(fieldKey),
        viewsIndex: getViewId(field.views),
        customViewsIndex: ((_field$ui = field.ui) === null || _field$ui === void 0 ? void 0 : _field$ui.views) === undefined ? null : getViewId(field.ui.views),
        fieldMeta: null,
        isOrderable: field.graphql.isEnabled.orderBy,
        isFilterable: field.graphql.isEnabled.filter,
        path: fieldKey,
        listKey: key,
        search
      });
    }
  } // we do this seperately to the above so that fields can check other fields to validate their config or etc.
  // (ofc they won't necessarily be able to see other field's fieldMeta)


  for (const [key, list] of Object.entries(initialisedLists)) {
    for (const fieldMetaRootVal of adminMetaRoot.listsByKey[key].fields) {
      var _list$fields$fieldMet, _list$fields$fieldMet2, _list$fields$fieldMet3;

      fieldMetaRootVal.fieldMeta = (_list$fields$fieldMet = (_list$fields$fieldMet2 = (_list$fields$fieldMet3 = list.fields[fieldMetaRootVal.path]).getAdminMeta) === null || _list$fields$fieldMet2 === void 0 ? void 0 : _list$fields$fieldMet2.call(_list$fields$fieldMet3, adminMetaRoot)) !== null && _list$fields$fieldMet !== void 0 ? _list$fields$fieldMet : null;
    }
  }

  return adminMetaRoot;
}

function serializePathForImport(path) {
  // JSON.stringify is important here because it will escape windows style paths(and any thing else that might potentially be in there)
  return JSON.stringify(path // Next is unhappy about imports that include .ts/tsx in them because TypeScript is unhappy with them because when doing a TypeScript compilation with tsc, the imports won't be written so they would be wrong there
  .replace(/\.tsx?$/, '').replace(new RegExp(`\\${Path__namespace['default'].sep}`, 'g'), '/'));
}

const appTemplate = (adminMetaRootVal, graphQLSchema, {
  configFileExists,
  projectAdminPath
}, apiPath) => {
  const result = graphql$1.executeSync({
    document: adminMetaGraphql.staticAdminMetaQuery,
    schema: graphQLSchema,
    contextValue: {
      isAdminUIBuildProcess: true
    }
  });

  if (result.errors) {
    throw result.errors[0];
  }

  const {
    adminMeta
  } = result.data.keystone;
  const adminMetaQueryResultHash = hashString__default['default'](JSON.stringify(adminMeta));
  const allViews = adminMetaRootVal.views.map(views => {
    const viewPath = Path__namespace['default'].isAbsolute(views) ? Path__namespace['default'].relative(Path__namespace['default'].join(projectAdminPath, 'pages'), views) : views;
    return serializePathForImport(viewPath);
  }); // -- TEMPLATE START

  return `import { getApp } from '@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/App';

${allViews.map((views, i) => `import * as view${i} from ${views};`).join('\n')}

${configFileExists ? `import * as adminConfig from "../../../admin/config";` : 'var adminConfig = {};'}

export default getApp({
  lazyMetadataQuery: ${JSON.stringify(getLazyMetadataQuery(graphQLSchema, adminMeta))},
  fieldViews: [${allViews.map((_, i) => `view${i}`)}],
  adminMetaHash: "${adminMetaQueryResultHash}",
  adminConfig: adminConfig,
  apiPath: "${apiPath}",
});
`; // -- TEMPLATE END
};

function getLazyMetadataQuery(graphqlSchema, adminMeta) {
  const selections = graphql$1.parse(`fragment x on y {
    keystone {
      adminMeta {
        lists {
          key
          isHidden
          fields {
            path
            createView {
              fieldMode
            }
          }
        }
      }
    }
  }`).definitions[0].selectionSet.selections;
  const queryType = graphqlSchema.getQueryType();

  if (queryType) {
    const getListByKey = name => adminMeta.lists.find(({
      key
    }) => key === name);

    const fields = queryType.getFields();

    if (fields['authenticatedItem'] !== undefined) {
      const authenticatedItemType = fields['authenticatedItem'].type;

      if (!(authenticatedItemType instanceof graphql$1.GraphQLUnionType) || authenticatedItemType.name !== 'AuthenticatedItem') {
        throw new Error(`The type of Query.authenticatedItem must be a type named AuthenticatedItem and be a union of types that refer to Keystone lists but it is "${authenticatedItemType.toString()}"`);
      }

      for (const type of authenticatedItemType.getTypes()) {
        const fields = type.getFields();
        const list = getListByKey(type.name);

        if (list === undefined) {
          throw new Error(`All members of the AuthenticatedItem union must refer to Keystone lists but "${type.name}" is in the AuthenticatedItem union but is not a Keystone list`);
        }

        let labelGraphQLField = fields[list.labelField];

        if (labelGraphQLField === undefined) {
          throw new Error(`The labelField for the list "${list.key}" is "${list.labelField}" but the GraphQL type does not have a field named "${list.labelField}"`);
        }

        let labelGraphQLFieldType = labelGraphQLField.type;

        if (labelGraphQLFieldType instanceof graphql$1.GraphQLNonNull) {
          labelGraphQLFieldType = labelGraphQLFieldType.ofType;
        }

        if (!(labelGraphQLFieldType instanceof graphql$1.GraphQLScalarType)) {
          throw new Error(`Label fields must be scalar GraphQL types but the labelField "${list.labelField}" on the list "${list.key}" is not a scalar type`);
        }

        const requiredArgs = labelGraphQLField.args.filter(arg => arg.defaultValue === undefined && arg.type instanceof graphql$1.GraphQLNonNull);

        if (requiredArgs.length) {
          throw new Error(`Label fields must have no required arguments but the labelField "${list.labelField}" on the list "${list.key}" has a required argument "${requiredArgs[0].name}"`);
        }
      }

      selections.push({
        kind: 'Field',
        name: {
          kind: 'Name',
          value: 'authenticatedItem'
        },
        selectionSet: {
          kind: 'SelectionSet',
          selections: authenticatedItemType.getTypes().map(({
            name
          }) => ({
            kind: 'InlineFragment',
            typeCondition: {
              kind: 'NamedType',
              name: {
                kind: 'Name',
                value: name
              }
            },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [{
                kind: 'Field',
                name: {
                  kind: 'Name',
                  value: 'id'
                }
              }, {
                kind: 'Field',
                name: {
                  kind: 'Name',
                  value: getListByKey(name).labelField
                }
              }]
            }
          }))
        }
      });
    }
  } // We're returning the complete query AST here for explicit-ness


  return {
    kind: 'Document',
    definitions: [{
      kind: 'OperationDefinition',
      operation: 'query',
      selectionSet: {
        kind: 'SelectionSet',
        selections
      }
    }]
  };
}

const homeTemplate = `export { HomePage as default } from '@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/HomePage';
`;

const listTemplate = listKey => `import { getListPage } from '@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ListPage';

export default getListPage(${JSON.stringify({
  listKey
})});
`;

const itemTemplate = listKey => `import { getItemPage } from '@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage';

export default getItemPage(${JSON.stringify({
  listKey
})})
`;

const apiTemplate = `
import keystoneConfig from '../../../../keystone';
import { initConfig, createSystem, createApolloServerMicro } from '@keystone-next/keystone/system';
import { PrismaClient } from '.prisma/client';

const initializedKeystoneConfig = initConfig(keystoneConfig);
const { graphQLSchema, keystone, createContext } = createSystem(initializedKeystoneConfig, 'none', PrismaClient);
const apolloServer = createApolloServerMicro({
  graphQLSchema,
  createContext,
  sessionStrategy: initializedKeystoneConfig.session ? initializedKeystoneConfig.session() : undefined,
  graphqlConfig: initializedKeystoneConfig.graphql,
  connectionPromise: keystone.connect(),
});

export const config = {
  api: {
    bodyParser: false,
  },
};
export default apolloServer.createHandler({ path: initializedKeystoneConfig.graphql?.path || '/api/graphql' });
`;

const noAccessTemplate = session => `import { getNoAccessPage } from '@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/NoAccessPage';

export default getNoAccessPage(${JSON.stringify({
  sessionsEnabled: !!session
})})
`;

const pkgDir = Path__namespace.dirname(require.resolve('@keystone-next/keystone/package.json'));
const writeAdminFiles = (config, graphQLSchema, adminMeta, configFileExists, projectAdminPath) => {
  var _config$experimental, _config$graphql, _config$graphql2, _config$experimental2, _config$graphql3;

  if ((_config$experimental = config.experimental) !== null && _config$experimental !== void 0 && _config$experimental.enableNextJsGraphqlApiEndpoint && (_config$graphql = config.graphql) !== null && _config$graphql !== void 0 && _config$graphql.path && !config.graphql.path.startsWith('/api/')) {
    throw new Error('config.graphql.path must start with "/api/" when using config.experimental.enableNextJsGraphqlApiEndpoint');
  }

  return [...['next.config.js', 'tsconfig.json'].map(outputPath => ({
    mode: 'copy',
    inputPath: Path__namespace.join(pkgDir, 'static', outputPath),
    outputPath
  })), {
    mode: 'write',
    src: noAccessTemplate(config.session),
    outputPath: 'pages/no-access.js'
  }, {
    mode: 'write',
    src: appTemplate(adminMeta, graphQLSchema, {
      configFileExists,
      projectAdminPath
    }, ((_config$graphql2 = config.graphql) === null || _config$graphql2 === void 0 ? void 0 : _config$graphql2.path) || '/api/graphql'),
    outputPath: 'pages/_app.js'
  }, {
    mode: 'write',
    src: homeTemplate,
    outputPath: 'pages/index.js'
  }, ...adminMeta.lists.map(({
    path,
    key
  }) => ({
    mode: 'write',
    src: listTemplate(key),
    outputPath: `pages/${path}/index.js`
  })), ...adminMeta.lists.map(({
    path,
    key
  }) => ({
    mode: 'write',
    src: itemTemplate(key),
    outputPath: `pages/${path}/[id].js`
  })), ...((_config$experimental2 = config.experimental) !== null && _config$experimental2 !== void 0 && _config$experimental2.enableNextJsGraphqlApiEndpoint ? [{
    mode: 'write',
    src: apiTemplate,
    outputPath: `pages/${((_config$graphql3 = config.graphql) === null || _config$graphql3 === void 0 ? void 0 : _config$graphql3.path) || '/api/graphql'}.js`
  }] : [])];
};

const graphql = _objectSpread(_objectSpread({}, sqlite.graphqlBoundToKeystoneContext), graphqlTsSchema.bindGraphQLSchemaAPIToContext());

function getAdminMetaSchema({
  config,
  graphQLSchema,
  lists,
  adminMeta: adminMetaRoot
}) {
  var _config$ui$isAccessAl, _config$ui;

  const isAccessAllowed = config.session === undefined ? undefined : (_config$ui$isAccessAl = (_config$ui = config.ui) === null || _config$ui === void 0 ? void 0 : _config$ui.isAccessAllowed) !== null && _config$ui$isAccessAl !== void 0 ? _config$ui$isAccessAl : ({
    session
  }) => session !== undefined;
  const jsonScalarType = graphQLSchema.getType('JSON');
  const jsonScalar = jsonScalarType ? graphql.scalar(graphql$1.assertScalarType(jsonScalarType)) : sqlite.JSON;
  const queryModeEnumType = graphQLSchema.getType('QueryMode');
  const queryModeEnum = queryModeEnumType ? _objectSpread(_objectSpread({}, sqlite.QueryMode), {}, {
    graphQLType: graphql$1.assertEnumType(graphQLSchema.getType('QueryMode'))
  }) : sqlite.QueryMode;
  const KeystoneAdminUIFieldMeta = graphql.object()({
    name: 'KeystoneAdminUIFieldMeta',
    fields: {
      path: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      label: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      isOrderable: graphql.field({
        type: graphql.nonNull(graphql.Boolean)
      }),
      isFilterable: graphql.field({
        type: graphql.nonNull(graphql.Boolean)
      }),
      fieldMeta: graphql.field({
        type: jsonScalar
      }),
      viewsIndex: graphql.field({
        type: graphql.nonNull(graphql.Int)
      }),
      customViewsIndex: graphql.field({
        type: graphql.Int
      }),
      createView: graphql.field({
        resolve(rootVal) {
          return {
            fieldPath: rootVal.path,
            listKey: rootVal.listKey
          };
        },

        type: graphql.nonNull(graphql.object()({
          name: 'KeystoneAdminUIFieldMetaCreateView',
          fields: {
            fieldMode: graphql.field({
              type: graphql.nonNull(graphql.enum({
                name: 'KeystoneAdminUIFieldMetaCreateViewFieldMode',
                values: graphql.enumValues(['edit', 'hidden'])
              })),

              async resolve(rootVal, args, context) {
                var _lists$rootVal$listKe, _lists$rootVal$listKe2, _lists$rootVal$listKe3, _listConfig$ui, _listConfig$ui$create;

                if ('isAdminUIBuildProcess' in context) {
                  throw new Error('KeystoneAdminUIFieldMetaCreateView.fieldMode cannot be resolved during the build process');
                }

                if (!lists[rootVal.listKey].fields[rootVal.fieldPath].graphql.isEnabled.create) {
                  return 'hidden';
                }

                const listConfig = config.lists[rootVal.listKey];
                const sessionFunction = (_lists$rootVal$listKe = (_lists$rootVal$listKe2 = lists[rootVal.listKey].fields[rootVal.fieldPath].ui) === null || _lists$rootVal$listKe2 === void 0 ? void 0 : (_lists$rootVal$listKe3 = _lists$rootVal$listKe2.createView) === null || _lists$rootVal$listKe3 === void 0 ? void 0 : _lists$rootVal$listKe3.fieldMode) !== null && _lists$rootVal$listKe !== void 0 ? _lists$rootVal$listKe : (_listConfig$ui = listConfig.ui) === null || _listConfig$ui === void 0 ? void 0 : (_listConfig$ui$create = _listConfig$ui.createView) === null || _listConfig$ui$create === void 0 ? void 0 : _listConfig$ui$create.defaultFieldMode;
                return runMaybeFunction(sessionFunction, 'edit', {
                  session: context.session
                });
              }

            })
          }
        }))
      }),
      listView: graphql.field({
        resolve(rootVal) {
          return {
            fieldPath: rootVal.path,
            listKey: rootVal.listKey
          };
        },

        type: graphql.nonNull(graphql.object()({
          name: 'KeystoneAdminUIFieldMetaListView',
          fields: {
            fieldMode: graphql.field({
              type: graphql.nonNull(graphql.enum({
                name: 'KeystoneAdminUIFieldMetaListViewFieldMode',
                values: graphql.enumValues(['read', 'hidden'])
              })),

              async resolve(rootVal, args, context) {
                var _lists$rootVal$listKe4, _lists$rootVal$listKe5, _lists$rootVal$listKe6, _listConfig$ui2, _listConfig$ui2$listV;

                if ('isAdminUIBuildProcess' in context) {
                  throw new Error('KeystoneAdminUIFieldMetaListView.fieldMode cannot be resolved during the build process');
                }

                if (!lists[rootVal.listKey].fields[rootVal.fieldPath].graphql.isEnabled.read) {
                  return 'hidden';
                }

                const listConfig = config.lists[rootVal.listKey];
                const sessionFunction = (_lists$rootVal$listKe4 = (_lists$rootVal$listKe5 = lists[rootVal.listKey].fields[rootVal.fieldPath].ui) === null || _lists$rootVal$listKe5 === void 0 ? void 0 : (_lists$rootVal$listKe6 = _lists$rootVal$listKe5.listView) === null || _lists$rootVal$listKe6 === void 0 ? void 0 : _lists$rootVal$listKe6.fieldMode) !== null && _lists$rootVal$listKe4 !== void 0 ? _lists$rootVal$listKe4 : (_listConfig$ui2 = listConfig.ui) === null || _listConfig$ui2 === void 0 ? void 0 : (_listConfig$ui2$listV = _listConfig$ui2.listView) === null || _listConfig$ui2$listV === void 0 ? void 0 : _listConfig$ui2$listV.defaultFieldMode;
                return runMaybeFunction(sessionFunction, 'read', {
                  session: context.session
                });
              }

            })
          }
        }))
      }),
      itemView: graphql.field({
        args: {
          id: graphql.arg({
            type: graphql.nonNull(graphql.ID)
          })
        },

        resolve(rootVal, args) {
          return {
            fieldPath: rootVal.path,
            listKey: rootVal.listKey,
            itemId: args.id
          };
        },

        type: graphql.object()({
          name: 'KeystoneAdminUIFieldMetaItemView',
          fields: {
            fieldMode: graphql.field({
              type: graphql.nonNull(graphql.enum({
                name: 'KeystoneAdminUIFieldMetaItemViewFieldMode',
                values: graphql.enumValues(['edit', 'read', 'hidden'])
              })),

              async resolve(rootVal, args, context) {
                var _lists$rootVal$listKe7, _lists$rootVal$listKe8, _lists$rootVal$listKe9, _listConfig$ui3, _listConfig$ui3$itemV;

                if ('isAdminUIBuildProcess' in context) {
                  throw new Error('KeystoneAdminUIFieldMetaItemView.fieldMode cannot be resolved during the build process');
                }

                if (!lists[rootVal.listKey].fields[rootVal.fieldPath].graphql.isEnabled.read) {
                  return 'hidden';
                } else if (!lists[rootVal.listKey].fields[rootVal.fieldPath].graphql.isEnabled.update) {
                  return 'read';
                }

                const item = await context.sudo().db.lists[rootVal.listKey].findOne({
                  where: {
                    id: rootVal.itemId
                  }
                });
                const listConfig = config.lists[rootVal.listKey];
                const sessionFunction = (_lists$rootVal$listKe7 = (_lists$rootVal$listKe8 = lists[rootVal.listKey].fields[rootVal.fieldPath].ui) === null || _lists$rootVal$listKe8 === void 0 ? void 0 : (_lists$rootVal$listKe9 = _lists$rootVal$listKe8.itemView) === null || _lists$rootVal$listKe9 === void 0 ? void 0 : _lists$rootVal$listKe9.fieldMode) !== null && _lists$rootVal$listKe7 !== void 0 ? _lists$rootVal$listKe7 : (_listConfig$ui3 = listConfig.ui) === null || _listConfig$ui3 === void 0 ? void 0 : (_listConfig$ui3$itemV = _listConfig$ui3.itemView) === null || _listConfig$ui3$itemV === void 0 ? void 0 : _listConfig$ui3$itemV.defaultFieldMode;
                return runMaybeFunction(sessionFunction, 'edit', {
                  session: context.session,
                  item
                });
              }

            })
          }
        })
      }),
      search: graphql.field({
        type: queryModeEnum
      })
    }
  });
  const KeystoneAdminUISort = graphql.object()({
    name: 'KeystoneAdminUISort',
    fields: {
      field: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      direction: graphql.field({
        type: graphql.nonNull(graphql.enum({
          name: 'KeystoneAdminUISortDirection',
          values: graphql.enumValues(['ASC', 'DESC'])
        }))
      })
    }
  });
  const KeystoneAdminUIListMeta = graphql.object()({
    name: 'KeystoneAdminUIListMeta',
    fields: {
      key: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      itemQueryName: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      listQueryName: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      hideCreate: graphql.field({
        type: graphql.nonNull(graphql.Boolean),

        resolve(rootVal, args, context) {
          var _listConfig$ui4;

          if ('isAdminUIBuildProcess' in context) {
            throw new Error('KeystoneAdminUIListMeta.hideCreate cannot be resolved during the build process');
          }

          const listConfig = config.lists[rootVal.key];
          return runMaybeFunction((_listConfig$ui4 = listConfig.ui) === null || _listConfig$ui4 === void 0 ? void 0 : _listConfig$ui4.hideCreate, false, {
            session: context.session
          });
        }

      }),
      hideDelete: graphql.field({
        type: graphql.nonNull(graphql.Boolean),

        resolve(rootVal, args, context) {
          var _listConfig$ui5;

          if ('isAdminUIBuildProcess' in context) {
            throw new Error('KeystoneAdminUIListMeta.hideDelete cannot be resolved during the build process');
          }

          const listConfig = config.lists[rootVal.key];
          return runMaybeFunction((_listConfig$ui5 = listConfig.ui) === null || _listConfig$ui5 === void 0 ? void 0 : _listConfig$ui5.hideDelete, false, {
            session: context.session
          });
        }

      }),
      path: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      label: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      singular: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      plural: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      description: graphql.field({
        type: graphql.String
      }),
      initialColumns: graphql.field({
        type: graphql.nonNull(graphql.list(graphql.nonNull(graphql.String)))
      }),
      pageSize: graphql.field({
        type: graphql.nonNull(graphql.Int)
      }),
      labelField: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      fields: graphql.field({
        type: graphql.nonNull(graphql.list(graphql.nonNull(KeystoneAdminUIFieldMeta)))
      }),
      initialSort: graphql.field({
        type: KeystoneAdminUISort
      }),
      isHidden: graphql.field({
        type: graphql.nonNull(graphql.Boolean),

        resolve(rootVal, args, context) {
          var _listConfig$ui6;

          if ('isAdminUIBuildProcess' in context) {
            throw new Error('KeystoneAdminUIListMeta.isHidden cannot be resolved during the build process');
          }

          const listConfig = config.lists[rootVal.key];
          return runMaybeFunction((_listConfig$ui6 = listConfig.ui) === null || _listConfig$ui6 === void 0 ? void 0 : _listConfig$ui6.isHidden, false, {
            session: context.session
          });
        }

      })
    }
  });
  const adminMeta = graphql.object()({
    name: 'KeystoneAdminMeta',
    fields: {
      enableSignout: graphql.field({
        type: graphql.nonNull(graphql.Boolean)
      }),
      enableSessionItem: graphql.field({
        type: graphql.nonNull(graphql.Boolean)
      }),
      lists: graphql.field({
        type: graphql.nonNull(graphql.list(graphql.nonNull(KeystoneAdminUIListMeta)))
      }),
      list: graphql.field({
        type: KeystoneAdminUIListMeta,
        args: {
          key: graphql.arg({
            type: graphql.nonNull(graphql.String)
          })
        },

        resolve(rootVal, {
          key
        }) {
          return rootVal.listsByKey[key];
        }

      })
    }
  });
  const KeystoneMeta = graphql.nonNull(graphql.object()({
    name: 'KeystoneMeta',
    fields: {
      adminMeta: graphql.field({
        type: graphql.nonNull(adminMeta),

        resolve(rootVal, args, context) {
          if ('isAdminUIBuildProcess' in context || isAccessAllowed === undefined) {
            return adminMetaRoot;
          }

          return Promise.resolve(isAccessAllowed(context)).then(isAllowed => {
            if (isAllowed) {
              return adminMetaRoot;
            } // TODO: ughhhhhh, we really need to talk about errors.
            // mostly unrelated to above: error or return null here(+ make field nullable)?s


            throw new Error('Access denied');
          });
        }

      })
    }
  }));
  const schemaConfig = graphQLSchema.toConfig();
  const queryTypeConfig = graphQLSchema.getQueryType().toConfig();
  return new graphql$1.GraphQLSchema(_objectSpread(_objectSpread({}, schemaConfig), {}, {
    types: schemaConfig.types.filter(x => x.name !== 'Query'),
    query: new graphql$1.GraphQLObjectType(_objectSpread(_objectSpread({}, queryTypeConfig), {}, {
      fields: _objectSpread(_objectSpread({}, queryTypeConfig.fields), {}, {
        keystone: {
          type: KeystoneMeta.graphQLType,

          resolve() {
            return {};
          }

        }
      })
    }))
  }));
}

function runMaybeFunction(sessionFunction, defaultValue, args) {
  if (typeof sessionFunction === 'function') {
    return sessionFunction(args);
  }

  if (typeof sessionFunction === 'undefined') {
    return defaultValue;
  }

  return sessionFunction;
}

// Run prisma operations as part of a resolver
async function runWithPrisma(context, {
  listKey
}, fn) {
  const model = context.prisma[listKey[0].toLowerCase() + listKey.slice(1)]; // FIXME: We will capture errors here and return them with a custom error code

  return await fn(model);
} // this is wrong
// all the things should be generic over the id type
// i don't want to deal with that right now though

// these aren't here out of thinking this is better syntax(i do not think it is),
// it's just because TS won't infer the arg is X bit
const isFulfilled = arg => arg.status === 'fulfilled';
const isRejected = arg => arg.status === 'rejected';
async function promiseAllRejectWithAllErrors(promises) {
  const results = await Promise.allSettled(promises);

  if (!results.every(isFulfilled)) {
    const errors = results.filter(isRejected).map(x => x.reason); // AggregateError would be ideal here but it's not in Node 12 or 14
    // (also all of our error stuff is just meh. this whole thing is just to align with previous behaviour)

    const error = new Error(errors[0].message || errors[0].toString());
    error.errors = errors;
    throw error;
  }

  return results.map(x => x.value);
}
function getNamesFromList(listKey, {
  graphql
  /*plural, label, singular, path */

}) {
  const _label =
  /*label ||*/
  keyToLabel(listKey);

  const _singular =
  /*singular ||*/
  pluralize__default['default'].singular(_label);

  const _plural =
  /*plural ||*/
  pluralize__default['default'].plural(_label);

  if (_plural === _label) {
    throw new Error(`Unable to use ${_label} as a List name - it has an ambiguous plural (${_plural}). Please choose another name for your list.`);
  }

  const adminUILabels = {
    // Fall back to the plural for the label if none was provided, not the autogenerated default from key
    label:
    /*label ||*/
    _plural,
    singular: _singular,
    plural: _plural,
    path:
    /*path || */
    labelToPath(_plural)
  };
  const pluralGraphQLName = (graphql === null || graphql === void 0 ? void 0 : graphql.plural) || labelToClass(_plural);

  if (pluralGraphQLName === listKey) {
    throw new Error(`The list key and the plural must be different but the list key ${listKey} is the same as the ${listKey} plural GraphQL name`);
  }

  return {
    pluralGraphQLName,
    adminUILabels
  };
}

const keyToLabel = str => {
  let label = humanize(str); // Retain the leading underscore for auxiliary lists

  if (str[0] === '_') {
    label = `_${label}`;
  }

  return label;
};

const labelToPath = str => str.split(' ').join('-').toLowerCase();

const labelToClass = str => str.replace(/\s+/g, '');

function getDBFieldKeyForFieldOnMultiField(fieldKey, subField) {
  return `${fieldKey}_${subField}`;
}

const _excluded$1 = ["AND", "OR", "NOT"];
async function resolveUniqueWhereInput(input, fields, context) {
  const inputKeys = Object.keys(input);

  if (inputKeys.length !== 1) {
    throw new Error(`Exactly one key must be passed in a unique where input but ${inputKeys.length} keys were passed`);
  }

  const key = inputKeys[0];
  const val = input[key];

  if (val === null) {
    throw new Error(`The unique value provided in a unique where input must not be null`);
  }

  const resolver = fields[key].input.uniqueWhere.resolve;
  return {
    [key]: resolver ? await resolver(val, context) : val
  };
}
async function resolveWhereInput(inputFilter, list, context) {
  return {
    AND: await Promise.all(Object.entries(inputFilter).map(async ([fieldKey, value]) => {
      if (fieldKey === 'OR' || fieldKey === 'AND' || fieldKey === 'NOT') {
        return {
          [fieldKey]: await Promise.all(value.map(value => resolveWhereInput(value, list, context)))
        };
      }

      const field = list.fields[fieldKey]; // we know if there are filters in the input object with the key of a field, the field must have defined a where input so this non null assertion is okay

      const where = field.input.where;
      const dbField = field.dbField;
      const ret = where.resolve ? await where.resolve(value, context, (() => {
        if (field.dbField.kind !== 'relation') {
          return undefined;
        }

        const foreignList = field.dbField.list;

        const whereResolver = val => resolveWhereInput(val, list.lists[foreignList], context);

        if (field.dbField.mode === 'many') {
          return async () => {
            if (value === null) {
              throw new Error('A many relation filter cannot be set to null');
            }

            return Object.fromEntries(await Promise.all(Object.entries(value).map(async ([key, val]) => {
              if (val === null) {
                throw new Error(`The key ${key} in a many relation filter cannot be set to null`);
              }

              return [key, await whereResolver(val)];
            })));
          };
        }

        return val => {
          if (val === null) {
            return null;
          }

          return whereResolver(val);
        };
      })()) : value;

      if (ret === null) {
        if (field.dbField.kind === 'multi') {
          throw new Error('multi db fields cannot return null from where input resolvers');
        }

        return {
          [fieldKey]: null
        };
      }

      return handleOperators(fieldKey, dbField, ret);
    }))
  };
}

function handleOperators(fieldKey, dbField, _ref) {
  let {
    AND,
    OR,
    NOT
  } = _ref,
      rest = _objectWithoutProperties(_ref, _excluded$1);

  return _objectSpread({
    AND: AND === null || AND === void 0 ? void 0 : AND.map(value => handleOperators(fieldKey, dbField, value)),
    OR: OR === null || OR === void 0 ? void 0 : OR.map(value => handleOperators(fieldKey, dbField, value)),
    NOT: NOT === null || NOT === void 0 ? void 0 : NOT.map(value => handleOperators(fieldKey, dbField, value))
  }, nestWithAppropiateField(fieldKey, dbField, rest));
}

function nestWithAppropiateField(fieldKey, dbField, value) {
  if (dbField.kind === 'multi') {
    return Object.fromEntries(Object.entries(value).map(([key, val]) => [getDBFieldKeyForFieldOnMultiField(fieldKey, key), val]));
  }

  return {
    [fieldKey]: value
  };
}

const accessDeniedError = () => new apolloServerErrors.ApolloError('You do not have access to this resource');
const validationFailureError = messages => {
  const s = messages.map(m => `  - ${m}`).join('\n');
  return new apolloServerErrors.ApolloError(`You provided invalid data for this operation.\n${s}`);
};
const extensionError = (extension, things) => {
  const s = things.map(t => `  - ${t.tag}: ${t.error.message}`).join('\n');
  return new apolloServerErrors.ApolloError(`An error occured while running "${extension}".\n${s}`, 'INTERNAL_SERVER_ERROR', // Make the original stack traces available.
  {
    debug: things.map(t => ({
      stacktrace: t.error.stack,
      message: t.error.message
    }))
  });
}; // FIXME: In an upcoming PR we will use these args to construct a better
// error message, so leaving the, here for now. - TL
// eslint-disable-next-line @typescript-eslint/no-unused-vars

const limitsExceededError = args => new apolloServerErrors.ApolloError('Your request exceeded server limits');

async function checkOperationAccess(list, context, operation) {
  const args = {
    operation,
    session: context.session,
    listKey: list.listKey,
    context
  }; // Check the mutation access

  const access = list.access.operation[operation]; // @ts-ignore

  const result = await access(args);
  const resultType = typeof result; // It's important that we don't cast objects to truthy values, as there's a strong chance that the user
  // has accidentally tried to return a filter.

  if (resultType !== 'boolean') {
    throw new Error(`Must return a Boolean from ${args.listKey}.access.operation.${args.operation}(). Got ${resultType}`);
  }

  return result;
}
async function getAccessFilters(list, context, operation) {
  const args = {
    operation,
    session: context.session,
    listKey: list.listKey,
    context
  }; // Check the mutation access

  const access = list.access.filter[operation]; // @ts-ignore

  return typeof access === 'function' ? await access(args) : access;
}
async function validateFieldAccessControl({
  access,
  args
}) {
  let result = typeof access === 'function' ? await access(args) : access;

  if (typeof result !== 'boolean') {
    throw new Error(`Must return a Boolean from ${args.listKey}.fields.${args.fieldKey}.access.${args.operation}(). Got ${typeof result}`);
  }

  return result;
}
function parseFieldAccessControl(access) {
  var _access$read, _access$create, _access$update;

  if (typeof access === 'boolean' || typeof access === 'function') {
    return {
      read: access,
      create: access,
      update: access
    };
  } // note i'm intentionally not using spread here because typescript can't express an optional property which cannot be undefined so spreading would mean there is a possibility that someone could pass {access: undefined} or {access:{read: undefined}} and bad things would happen


  return {
    read: (_access$read = access === null || access === void 0 ? void 0 : access.read) !== null && _access$read !== void 0 ? _access$read : () => true,
    create: (_access$create = access === null || access === void 0 ? void 0 : access.create) !== null && _access$create !== void 0 ? _access$create : () => true,
    update: (_access$update = access === null || access === void 0 ? void 0 : access.update) !== null && _access$update !== void 0 ? _access$update : () => true // delete: not supported

  };
}
function parseListAccessControl(access) {
  let item, filter, operation;

  if (typeof (access === null || access === void 0 ? void 0 : access.operation) === 'function') {
    operation = {
      create: access.operation,
      query: access.operation,
      update: access.operation,
      delete: access.operation
    };
  } else {
    var _access$operation$cre, _access$operation, _access$operation$que, _access$operation2, _access$operation$upd, _access$operation3, _access$operation$del, _access$operation4;

    // Note I'm intentionally not using spread here because typescript can't express
    // an optional property which cannot be undefined so spreading would mean there
    // is a possibility that someone could pass { access: undefined } or
    // { access: { read: undefined } } and bad things would happen.
    operation = {
      create: (_access$operation$cre = access === null || access === void 0 ? void 0 : (_access$operation = access.operation) === null || _access$operation === void 0 ? void 0 : _access$operation.create) !== null && _access$operation$cre !== void 0 ? _access$operation$cre : () => true,
      query: (_access$operation$que = access === null || access === void 0 ? void 0 : (_access$operation2 = access.operation) === null || _access$operation2 === void 0 ? void 0 : _access$operation2.query) !== null && _access$operation$que !== void 0 ? _access$operation$que : () => true,
      update: (_access$operation$upd = access === null || access === void 0 ? void 0 : (_access$operation3 = access.operation) === null || _access$operation3 === void 0 ? void 0 : _access$operation3.update) !== null && _access$operation$upd !== void 0 ? _access$operation$upd : () => true,
      delete: (_access$operation$del = access === null || access === void 0 ? void 0 : (_access$operation4 = access.operation) === null || _access$operation4 === void 0 ? void 0 : _access$operation4.delete) !== null && _access$operation$del !== void 0 ? _access$operation$del : () => true
    };
  }

  if (typeof (access === null || access === void 0 ? void 0 : access.filter) === 'boolean' || typeof (access === null || access === void 0 ? void 0 : access.filter) === 'function') {
    filter = {
      query: access.filter,
      update: access.filter,
      delete: access.filter
    };
  } else {
    var _access$filter$query, _access$filter, _access$filter$update, _access$filter2, _access$filter$delete, _access$filter3;

    filter = {
      // create: not supported
      query: (_access$filter$query = access === null || access === void 0 ? void 0 : (_access$filter = access.filter) === null || _access$filter === void 0 ? void 0 : _access$filter.query) !== null && _access$filter$query !== void 0 ? _access$filter$query : () => true,
      update: (_access$filter$update = access === null || access === void 0 ? void 0 : (_access$filter2 = access.filter) === null || _access$filter2 === void 0 ? void 0 : _access$filter2.update) !== null && _access$filter$update !== void 0 ? _access$filter$update : () => true,
      delete: (_access$filter$delete = access === null || access === void 0 ? void 0 : (_access$filter3 = access.filter) === null || _access$filter3 === void 0 ? void 0 : _access$filter3.delete) !== null && _access$filter$delete !== void 0 ? _access$filter$delete : () => true
    };
  }

  if (typeof (access === null || access === void 0 ? void 0 : access.item) === 'boolean' || typeof (access === null || access === void 0 ? void 0 : access.item) === 'function') {
    item = {
      create: access.item,
      update: access.item,
      delete: access.item
    };
  } else {
    var _access$item$create, _access$item, _access$item$update, _access$item2, _access$item$delete, _access$item3;

    item = {
      create: (_access$item$create = access === null || access === void 0 ? void 0 : (_access$item = access.item) === null || _access$item === void 0 ? void 0 : _access$item.create) !== null && _access$item$create !== void 0 ? _access$item$create : () => true,
      // read: not supported
      update: (_access$item$update = access === null || access === void 0 ? void 0 : (_access$item2 = access.item) === null || _access$item2 === void 0 ? void 0 : _access$item2.update) !== null && _access$item$update !== void 0 ? _access$item$update : () => true,
      delete: (_access$item$delete = access === null || access === void 0 ? void 0 : (_access$item3 = access.item) === null || _access$item3 === void 0 ? void 0 : _access$item3.delete) !== null && _access$item$delete !== void 0 ? _access$item$delete : () => true
    };
  }

  return {
    operation,
    filter,
    item
  };
}

function getResolvedUniqueWheres(uniqueInputs, context, foreignList) {
  return uniqueInputs.map(async uniqueInput => {
    // Validate and resolve the input filter
    const uniqueWhere = await resolveUniqueWhereInput(uniqueInput, foreignList.fields, context); // Check whether the item exists

    const item = await context.db.lists[foreignList.listKey].findOne({
      where: uniqueInput
    });

    if (item === null) {
      throw new Error('Unable to find item to connect to.');
    }

    return uniqueWhere;
  });
}

function resolveRelateToManyForCreateInput(nestedMutationState, context, foreignList, target) {
  return async value => {
    if (!Array.isArray(value.connect) && !Array.isArray(value.create)) {
      throw new Error(`You must provide at least one field in to-many relationship inputs but none were provided at ${target}`);
    } // Perform queries for the connections


    const connects = Promise.allSettled(getResolvedUniqueWheres(value.connect || [], context, foreignList)); // Perform nested mutations for the creations

    const creates = Promise.allSettled((value.create || []).map(x => nestedMutationState.create(x, foreignList)));
    const [connectResult, createResult] = await Promise.all([connects, creates]); // Collect all the errors

    const errors = [...connectResult.filter(isRejected), ...createResult.filter(isRejected)].map(x => x.reason);

    if (errors.length) {
      throw new Error(`Unable to create and/or connect ${errors.length} ${target}`);
    }

    const result = {
      connect: [...connectResult, ...createResult].filter(isFulfilled).map(x => x.value)
    }; // Perform queries for the connections

    return result;
  };
}
function resolveRelateToManyForUpdateInput(nestedMutationState, context, foreignList, target) {
  return async value => {
    if (!Array.isArray(value.connect) && !Array.isArray(value.create) && !Array.isArray(value.disconnect) && !Array.isArray(value.set)) {
      throw new Error(`You must provide at least one field in to-many relationship inputs but none were provided at ${target}`);
    }

    if (value.set && value.disconnect) {
      throw new Error(`The set and disconnect fields cannot both be provided to to-many relationship inputs but both were provided at ${target}`);
    } // Perform queries for the connections


    const connects = Promise.allSettled(getResolvedUniqueWheres(value.connect || [], context, foreignList));
    const disconnects = Promise.allSettled(getResolvedUniqueWheres(value.disconnect || [], context, foreignList));
    const sets = Promise.allSettled(getResolvedUniqueWheres(value.set || [], context, foreignList)); // Perform nested mutations for the creations

    const creates = Promise.allSettled((value.create || []).map(x => nestedMutationState.create(x, foreignList)));
    const [connectResult, createResult, disconnectResult, setResult] = await Promise.all([connects, creates, disconnects, sets]); // Collect all the errors

    const errors = [...connectResult.filter(isRejected), ...createResult.filter(isRejected), ...disconnectResult.filter(isRejected), ...setResult.filter(isRejected)];

    if (errors.length) {
      throw new Error(`Unable to create, connect, disconnect and/or set ${errors.length} ${target}`);
    }

    return {
      // unlike all the other operations, an empty array isn't a no-op for set
      set: value.set ? setResult.filter(isFulfilled).map(x => x.value) : undefined,
      disconnect: disconnectResult.filter(isFulfilled).map(x => x.value),
      connect: [...connectResult, ...createResult].filter(isFulfilled).map(x => x.value)
    };
  };
}

async function handleCreateAndUpdate(value, nestedMutationState, context, foreignList, target) {
  if (value.connect) {
    // Validate and resolve the input filter
    const uniqueWhere = await resolveUniqueWhereInput(value.connect, foreignList.fields, context); // Check whether the item exists

    try {
      const item = await context.db.lists[foreignList.listKey].findOne({
        where: value.connect
      });

      if (item === null) {
        throw new Error(`Unable to connect a ${target}`);
      }
    } catch (err) {
      throw new Error(`Unable to connect a ${target}`);
    }

    return {
      connect: uniqueWhere
    };
  } else if (value.create) {
    const createInput = value.create;
    let create = await (async () => {
      try {
        // Perform the nested create operation
        return await nestedMutationState.create(createInput, foreignList);
      } catch (err) {
        throw new Error(`Unable to create a ${target}`);
      }
    })();
    return {
      connect: {
        id: create.id
      }
    };
  }
}

function resolveRelateToOneForCreateInput(nestedMutationState, context, foreignList, target) {
  return async value => {
    const numOfKeys = Object.keys(value).length;

    if (numOfKeys !== 1) {
      throw new Error(`Nested to-one mutations must provide exactly one field if they're provided but ${target} did not`);
    }

    return handleCreateAndUpdate(value, nestedMutationState, context, foreignList, target);
  };
}
function resolveRelateToOneForUpdateInput(nestedMutationState, context, foreignList, target) {
  return async value => {
    if (Object.keys(value).length !== 1) {
      throw new Error(`Nested to-one mutations must provide exactly one field if they're provided but ${target} did not`);
    }

    if (value.connect || value.create) {
      return handleCreateAndUpdate(value, nestedMutationState, context, foreignList, target);
    } else if (value.disconnect) {
      return {
        disconnect: true
      };
    }
  };
}

// we want to do this explicit mapping because:
// - we are passing the values into a normal where filter and we want to ensure that fields cannot do non-unique filters(we don't do validation on non-unique wheres because prisma will validate all that)
// - for multi-field unique indexes, we need to a mapping because iirc findFirst/findMany won't understand the syntax for filtering by multi-field unique indexes(which makes sense and is correct imo)

function mapUniqueWhereToWhere(list, uniqueWhere) {
  // inputResolvers.uniqueWhere validates that there is only one key
  const key = Object.keys(uniqueWhere)[0];
  const dbField = list.fields[key].dbField;

  if (dbField.kind !== 'scalar' || dbField.scalar !== 'String' && dbField.scalar !== 'Int') {
    throw new Error('Currently only String and Int scalar db fields can provide a uniqueWhere input');
  }

  const val = uniqueWhere[key];

  if (dbField.scalar === 'Int' && typeof val !== 'number') {
    throw new Error('uniqueWhere inputs must return an integer for Int db fields');
  }

  if (dbField.scalar === 'String' && typeof val !== 'string') {
    throw new Error('uniqueWhere inputs must return an string for String db fields');
  }

  return {
    [key]: val
  };
}
async function accessControlledFilter(list, context, resolvedWhere, accessFilters) {
  // Merge the filter access control
  if (typeof accessFilters === 'object') {
    resolvedWhere = {
      AND: [resolvedWhere, await resolveWhereInput(accessFilters, list, context)]
    };
  }

  return resolvedWhere;
}
async function findOne(args, list, context) {
  // Check operation permission to pass into single operation
  const operationAccess = await checkOperationAccess(list, context, 'query');

  if (!operationAccess) {
    return null;
  }

  const accessFilters = await getAccessFilters(list, context, 'query');

  if (accessFilters === false) {
    return null;
  } // Validate and resolve the input filter


  const uniqueWhere = await resolveUniqueWhereInput(args.where, list.fields, context);
  const resolvedWhere = mapUniqueWhereToWhere(list, uniqueWhere); // Apply access control

  const filter = await accessControlledFilter(list, context, resolvedWhere, accessFilters);
  return runWithPrisma(context, list, model => model.findFirst({
    where: filter
  }));
}
async function findMany({
  where,
  take,
  skip,
  orderBy: rawOrderBy
}, list, context, info, extraFilter) {
  const orderBy = await resolveOrderBy(rawOrderBy, list, context); // Check operation permission, throw access denied if not allowed

  const operationAccess = await checkOperationAccess(list, context, 'query');

  if (!operationAccess) {
    return [];
  }

  const accessFilters = await getAccessFilters(list, context, 'query');

  if (accessFilters === false) {
    return [];
  }

  applyEarlyMaxResults(take, list);
  let resolvedWhere = await resolveWhereInput(where, list, context);
  resolvedWhere = await accessControlledFilter(list, context, resolvedWhere, accessFilters);
  const results = await runWithPrisma(context, list, model => model.findMany({
    where: extraFilter === undefined ? resolvedWhere : {
      AND: [resolvedWhere, extraFilter]
    },
    orderBy,
    take: take !== null && take !== void 0 ? take : undefined,
    skip
  }));
  applyMaxResults(results, list, context);

  if (info.cacheControl && list.cacheHint) {
    var _info$operation$name;

    info.cacheControl.setCacheHint(list.cacheHint({
      results,
      operationName: (_info$operation$name = info.operation.name) === null || _info$operation$name === void 0 ? void 0 : _info$operation$name.value,
      meta: false
    }));
  }

  return results;
}

async function resolveOrderBy(orderBy, list, context) {
  return await Promise.all(orderBy.map(async orderBySelection => {
    const keys = Object.keys(orderBySelection);

    if (keys.length !== 1) {
      throw new Error(`Only a single key must be passed to ${list.types.orderBy.graphQLType.name}`);
    }

    const fieldKey = keys[0];
    const value = orderBySelection[fieldKey];

    if (value === null) {
      throw new Error('null cannot be passed as an order direction');
    }

    const field = list.fields[fieldKey];
    const resolve = field.input.orderBy.resolve;
    const resolvedValue = resolve ? await resolve(value, context) : value;

    if (field.dbField.kind === 'multi') {
      const keys = Object.keys(resolvedValue);

      if (keys.length !== 1) {
        throw new Error(`Only a single key must be returned from an orderBy input resolver for a multi db field`);
      }

      const innerKey = keys[0];
      return {
        [getDBFieldKeyForFieldOnMultiField(fieldKey, innerKey)]: resolvedValue[innerKey]
      };
    } else {
      return {
        [fieldKey]: resolvedValue
      };
    }
  }));
}

async function count({
  where
}, list, context, info, extraFilter) {
  // Check operation permission, throw access denied if not allowed
  const operationAccess = await checkOperationAccess(list, context, 'query');

  if (!operationAccess) {
    return 0;
  }

  const accessFilters = await getAccessFilters(list, context, 'query');

  if (accessFilters === false) {
    return 0;
  }

  let resolvedWhere = await resolveWhereInput(where, list, context);
  resolvedWhere = await accessControlledFilter(list, context, resolvedWhere, accessFilters);
  const count = await runWithPrisma(context, list, model => model.count({
    where: extraFilter === undefined ? resolvedWhere : {
      AND: [resolvedWhere, extraFilter]
    }
  }));

  if (info.cacheControl && list.cacheHint) {
    var _info$operation$name2;

    info.cacheControl.setCacheHint(list.cacheHint({
      results: count,
      operationName: (_info$operation$name2 = info.operation.name) === null || _info$operation$name2 === void 0 ? void 0 : _info$operation$name2.value,
      meta: true
    }));
  }

  return count;
}

function applyEarlyMaxResults(_take, list) {
  const take = Math.abs(_take !== null && _take !== void 0 ? _take : Infinity); // We want to help devs by failing fast and noisily if limits are violated.
  // Unfortunately, we can't always be sure of intent.
  // E.g., if the query has a "take: 10", is it bad if more results could come back?
  // Maybe yes, or maybe the dev is just paginating posts.
  // But we can be sure there's a problem in two cases:
  // * The query explicitly has a "take" that exceeds the limit
  // * The query has no "take", and has more results than the limit

  if (take < Infinity && take > list.maxResults) {
    throw limitsExceededError({
      list: list.listKey,
      type: 'maxResults',
      limit: list.maxResults
    });
  }
}

function applyMaxResults(results, list, context) {
  if (results.length > list.maxResults) {
    throw limitsExceededError({
      list: list.listKey,
      type: 'maxResults',
      limit: list.maxResults
    });
  }

  if (context) {
    context.totalResults += results.length;

    if (context.totalResults > context.maxTotalResults) {
      throw limitsExceededError({
        list: list.listKey,
        type: 'maxTotalResults',
        limit: context.maxTotalResults
      });
    }
  }
}

async function getFilteredItem(list, context, uniqueWhere, accessFilters) {
  if (accessFilters === false) {
    // Early exit if they want to exclude everything
    throw accessDeniedError();
  } // Merge the filter access control and try to get the item.


  let where = mapUniqueWhereToWhere(list, uniqueWhere);

  if (typeof accessFilters === 'object') {
    where = {
      AND: [where, await resolveWhereInput(accessFilters, list, context)]
    };
  }

  const item = await runWithPrisma(context, list, model => model.findFirst({
    where
  }));

  if (item === null) {
    throw accessDeniedError();
  }

  return item;
}

async function getAccessControlledItemForDelete(list, context, uniqueWhere, accessFilters) {
  const operation = 'delete'; // Apply the filter access control. Will throw an accessDeniedError if the item isn't found.

  const item = await getFilteredItem(list, context, uniqueWhere, accessFilters); // Apply item level access control

  const access = list.access.item[operation];
  const args = {
    operation,
    session: context.session,
    listKey: list.listKey,
    context,
    item
  }; // List level 'item' access control

  const result = await access(args);
  const resultType = typeof result; // It's important that we don't cast objects to truthy values, as there's a strong chance that the user
  // has accidentally tried to return a filter.

  if (resultType !== 'boolean') {
    throw new Error(`Must return a Boolean from ${args.listKey}.access.item.${operation}(). Got ${resultType}`);
  }

  if (!result) {
    throw accessDeniedError();
  } // No field level access control for delete


  return item;
}
async function getAccessControlledItemForUpdate(list, context, uniqueWhere, accessFilters, originalInput) {
  const operation = 'update'; // Apply the filter access control. Will throw an accessDeniedError if the item isn't found.

  const item = await getFilteredItem(list, context, uniqueWhere, accessFilters); // Apply item level access control

  const access = list.access.item[operation];
  const args = {
    operation,
    session: context.session,
    listKey: list.listKey,
    context,
    item,
    originalInput
  }; // List level 'item' access control

  const result = await access(args);
  const resultType = typeof result; // It's important that we don't cast objects to truthy values, as there's a strong chance that the user
  // has accidentally tried to return a filter.

  if (resultType !== 'boolean') {
    throw new Error(`Must return a Boolean from ${args.listKey}.access.item.${operation}(). Got ${resultType}`);
  }

  if (!result) {
    throw accessDeniedError();
  } // Field level 'item' access control


  const results = await Promise.all(Object.keys(originalInput).map(fieldKey => validateFieldAccessControl({
    access: list.fields[fieldKey].access[operation],
    args: _objectSpread(_objectSpread({}, args), {}, {
      fieldKey
    })
  })));

  if (results.some(canAccess => !canAccess)) {
    throw accessDeniedError();
  }

  return item;
}
async function applyAccessControlForCreate(list, context, originalInput) {
  const operation = 'create'; // Apply item level access control

  const access = list.access.item[operation];
  const args = {
    operation,
    session: context.session,
    listKey: list.listKey,
    context,
    originalInput
  }; // List level 'item' access control

  const result = await access(args);
  const resultType = typeof result; // It's important that we don't cast objects to truthy values, as there's a strong chance that the user
  // has accidentally tried to return a filter.

  if (resultType !== 'boolean') {
    throw new Error(`Must return a Boolean from ${args.listKey}.access.item.${operation}(). Got ${resultType}`);
  }

  if (!result) {
    throw accessDeniedError();
  } // Field level 'item' access control


  const results = await Promise.all(Object.keys(originalInput).map(fieldKey => validateFieldAccessControl({
    access: list.fields[fieldKey].access[operation],
    args: _objectSpread(_objectSpread({}, args), {}, {
      fieldKey
    })
  })));

  if (results.some(canAccess => !canAccess)) {
    throw accessDeniedError();
  }
}

async function runSideEffectOnlyHook(list, hookName, args) {
  // Runs the before/after change/delete hooks
  // Only run field hooks on change operations if the field
  // was specified in the original input.
  let shouldRunFieldLevelHook;

  if (hookName === 'beforeChange' || hookName === 'afterChange') {
    const originalInputKeys = new Set(Object.keys(args.originalInput));

    shouldRunFieldLevelHook = fieldKey => originalInputKeys.has(fieldKey);
  } else {
    shouldRunFieldLevelHook = () => true;
  } // Field hooks


  const fieldsErrors = [];

  for (const [fieldKey, field] of Object.entries(list.fields)) {
    if (shouldRunFieldLevelHook(fieldKey)) {
      try {
        var _field$hooks$hookName, _field$hooks;

        await ((_field$hooks$hookName = (_field$hooks = field.hooks)[hookName]) === null || _field$hooks$hookName === void 0 ? void 0 : _field$hooks$hookName.call(_field$hooks, _objectSpread({
          fieldKey
        }, args)));
      } catch (error) {
        fieldsErrors.push({
          error,
          tag: `${list.listKey}.${fieldKey}`
        });
      }
    }
  }

  if (fieldsErrors.length) {
    throw extensionError(hookName, fieldsErrors);
  } // List hooks


  try {
    var _list$hooks$hookName, _list$hooks;

    await ((_list$hooks$hookName = (_list$hooks = list.hooks)[hookName]) === null || _list$hooks$hookName === void 0 ? void 0 : _list$hooks$hookName.call(_list$hooks, args));
  } catch (error) {
    throw extensionError(hookName, [{
      error,
      tag: list.listKey
    }]);
  }
}

async function validationHook(_validationHook) {
  const messages = [];
  await _validationHook(msg => {
    messages.push(msg);
  });

  if (messages.length) {
    throw validationFailureError(messages);
  }
}

async function validateUpdateCreate({
  list,
  hookArgs
}) {
  const {
    operation,
    resolvedData
  } = hookArgs;
  await validationHook(async _addValidationError => {
    var _list$hooks$validateI, _list$hooks;

    // Check isRequired
    for (const [fieldKey, field] of Object.entries(list.fields)) {
      var _field$__legacy;

      const addValidationError = msg => _addValidationError(`${list.listKey}.${fieldKey}: ${msg}`); // yes, this is a massive hack, it's just to make image and file fields work well enough


      let val = resolvedData[fieldKey];

      if (field.dbField.kind === 'multi') {
        if (Object.values(resolvedData[fieldKey]).every(x => x === null)) {
          val = null;
        }

        if (Object.values(resolvedData[fieldKey]).every(x => x === undefined)) {
          val = undefined;
        }
      }

      if ((_field$__legacy = field.__legacy) !== null && _field$__legacy !== void 0 && _field$__legacy.isRequired && (operation === 'create' && val == null || operation === 'update' && val === null)) {
        addValidationError(`Required field "${fieldKey}" is null or undefined.`);
      }
    } // Field validation hooks


    for (const [fieldKey, field] of Object.entries(list.fields)) {
      var _field$hooks$validate, _field$hooks;

      const addValidationError = msg => _addValidationError(`${list.listKey}.${fieldKey}: ${msg}`); // @ts-ignore


      await ((_field$hooks$validate = (_field$hooks = field.hooks).validateInput) === null || _field$hooks$validate === void 0 ? void 0 : _field$hooks$validate.call(_field$hooks, _objectSpread(_objectSpread({}, hookArgs), {}, {
        addValidationError,
        fieldKey
      })));
    } // List validation hooks


    const addValidationError = msg => _addValidationError(`${list.listKey}: ${msg}`); // @ts-ignore


    await ((_list$hooks$validateI = (_list$hooks = list.hooks).validateInput) === null || _list$hooks$validateI === void 0 ? void 0 : _list$hooks$validateI.call(_list$hooks, _objectSpread(_objectSpread({}, hookArgs), {}, {
      addValidationError
    })));
  });
}
async function validateDelete({
  list,
  hookArgs
}) {
  await validationHook(async _addValidationError => {
    var _list$hooks$validateD, _list$hooks2;

    // Field validation
    for (const [fieldKey, field] of Object.entries(list.fields)) {
      var _field$hooks$validate2, _field$hooks2;

      const addValidationError = msg => _addValidationError(`${list.listKey}.${fieldKey}: ${msg}`);

      await ((_field$hooks$validate2 = (_field$hooks2 = field.hooks).validateDelete) === null || _field$hooks$validate2 === void 0 ? void 0 : _field$hooks$validate2.call(_field$hooks2, _objectSpread(_objectSpread({}, hookArgs), {}, {
        addValidationError,
        fieldKey
      })));
    } // List validation


    const addValidationError = msg => _addValidationError(`${list.listKey}: ${msg}`);

    await ((_list$hooks$validateD = (_list$hooks2 = list.hooks).validateDelete) === null || _list$hooks$validateD === void 0 ? void 0 : _list$hooks$validateD.call(_list$hooks2, _objectSpread(_objectSpread({}, hookArgs), {}, {
      addValidationError
    })));
  });
}

async function createSingle({
  data: rawData
}, list, context, operationAccess, writeLimit) {
  // Operation level access control
  if (!operationAccess) {
    throw accessDeniedError();
  } //  Item access control. Will throw an accessDeniedError if not allowed.


  await applyAccessControlForCreate(list, context, rawData);
  const {
    afterChange,
    data
  } = await resolveInputForCreateOrUpdate(list, context, rawData, undefined);
  const item = await writeLimit(() => runWithPrisma(context, list, model => model.create({
    data
  })));
  return {
    item,
    afterChange
  };
}

var _afterChanges = /*#__PURE__*/new WeakMap();

var _context = /*#__PURE__*/new WeakMap();

class NestedMutationState {
  constructor(context) {
    _classPrivateFieldInitSpec(this, _afterChanges, {
      writable: true,
      value: []
    });

    _classPrivateFieldInitSpec(this, _context, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldSet(this, _context, context);
  }

  async create(data, list) {
    const context = _classPrivateFieldGet(this, _context);

    const writeLimit = pLimit__default['default'](1); // Check operation permission to pass into single operation

    const operationAccess = await checkOperationAccess(list, context, 'create');
    const {
      item,
      afterChange
    } = await createSingle({
      data
    }, list, context, operationAccess, writeLimit);

    _classPrivateFieldGet(this, _afterChanges).push(() => afterChange(item));

    return {
      id: item.id
    };
  }

  async afterChange() {
    await promiseAllRejectWithAllErrors(_classPrivateFieldGet(this, _afterChanges).map(async x => x()));
  }

}
async function createOne(createInput, list, context) {
  const writeLimit = pLimit__default['default'](1); // Check operation permission to pass into single operation

  const operationAccess = await checkOperationAccess(list, context, 'create');
  const {
    item,
    afterChange
  } = await createSingle(createInput, list, context, operationAccess, writeLimit);
  await afterChange(item);
  return item;
}
async function createMany(createInputs, list, context, provider) {
  const writeLimit = pLimit__default['default'](provider === 'sqlite' ? 1 : Infinity); // Check operation permission to pass into single operation

  const operationAccess = await checkOperationAccess(list, context, 'create');
  return createInputs.data.map(async data => {
    const {
      item,
      afterChange
    } = await createSingle({
      data
    }, list, context, operationAccess, writeLimit);
    await afterChange(item);
    return item;
  });
}

async function updateSingle(updateInput, list, context, accessFilters, operationAccess, writeLimit) {
  // Operation level access control
  if (!operationAccess) {
    throw accessDeniedError();
  }

  const {
    where: uniqueInput,
    data: rawData
  } = updateInput; // Validate and resolve the input filter

  const uniqueWhere = await resolveUniqueWhereInput(uniqueInput, list.fields, context); // Filter and Item access control. Will throw an accessDeniedError if not allowed.

  const existingItem = await getAccessControlledItemForUpdate(list, context, uniqueWhere, accessFilters, rawData);
  const {
    afterChange,
    data
  } = await resolveInputForCreateOrUpdate(list, context, rawData, existingItem);
  const updatedItem = await writeLimit(() => runWithPrisma(context, list, model => model.update({
    where: {
      id: existingItem.id
    },
    data
  })));
  await afterChange(updatedItem);
  return updatedItem;
}

async function updateOne(updateInput, list, context) {
  const writeLimit = pLimit__default['default'](1); // Check operation permission to pass into single operation

  const operationAccess = await checkOperationAccess(list, context, 'update'); // Get list-level access control filters

  const accessFilters = await getAccessFilters(list, context, 'update');
  return updateSingle(updateInput, list, context, accessFilters, operationAccess, writeLimit);
}
async function updateMany({
  data
}, list, context, provider) {
  const writeLimit = pLimit__default['default'](provider === 'sqlite' ? 1 : Infinity); // Check operation permission to pass into single operation

  const operationAccess = await checkOperationAccess(list, context, 'update'); // Get list-level access control filters

  const accessFilters = await getAccessFilters(list, context, 'update');
  return data.map(async updateInput => updateSingle(updateInput, list, context, accessFilters, operationAccess, writeLimit));
}

async function getResolvedData(list, hookArgs, nestedMutationState) {
  const {
    context,
    operation,
    originalInput
  } = hookArgs; // Start with the original input

  let resolvedData = hookArgs.originalInput; // Apply default values
  // We don't expect any errors from here, so we can wrap all these operations
  // in a generic catch-all error handler.

  if (operation === 'create') {
    resolvedData = Object.fromEntries(await promiseAllRejectWithAllErrors(Object.entries(list.fields).map(async ([fieldKey, field]) => {
      var _field$__legacy;

      let input = resolvedData[fieldKey];

      if (input === undefined && ((_field$__legacy = field.__legacy) === null || _field$__legacy === void 0 ? void 0 : _field$__legacy.defaultValue) !== undefined) {
        input = typeof field.__legacy.defaultValue === 'function' ? await field.__legacy.defaultValue({
          originalInput,
          context
        }) : field.__legacy.defaultValue;
      }

      return [fieldKey, input];
    })));
  } // Apply non-relationship field type input resolvers


  resolvedData = Object.fromEntries(await promiseAllRejectWithAllErrors(Object.entries(list.fields).map(async ([fieldKey, field]) => {
    var _field$input, _field$input$operatio;

    const inputResolver = (_field$input = field.input) === null || _field$input === void 0 ? void 0 : (_field$input$operatio = _field$input[operation]) === null || _field$input$operatio === void 0 ? void 0 : _field$input$operatio.resolve;
    let input = resolvedData[fieldKey];

    if (inputResolver && field.dbField.kind !== 'relation') {
      input = await inputResolver(input, context, undefined);
    }

    return [fieldKey, input];
  }))); // Apply relationship field type input resolvers

  resolvedData = Object.fromEntries(await promiseAllRejectWithAllErrors(Object.entries(list.fields).map(async ([fieldKey, field]) => {
    var _field$input2, _field$input2$operati;

    const inputResolver = (_field$input2 = field.input) === null || _field$input2 === void 0 ? void 0 : (_field$input2$operati = _field$input2[operation]) === null || _field$input2$operati === void 0 ? void 0 : _field$input2$operati.resolve;
    let input = resolvedData[fieldKey];

    if (inputResolver && field.dbField.kind === 'relation') {
      input = await inputResolver(input, context, // This third argument only applies to relationship fields
      (() => {
        if (input === undefined) {
          // No-op: This is what we want
          return () => undefined;
        }

        if (input === null) {
          // No-op: Should this be UserInputError?
          return () => undefined;
        }

        const target = `${list.listKey}.${fieldKey}<${field.dbField.list}>`;
        const foreignList = list.lists[field.dbField.list];
        let resolver;

        if (field.dbField.mode === 'many') {
          if (operation === 'create') {
            resolver = resolveRelateToManyForCreateInput;
          } else {
            resolver = resolveRelateToManyForUpdateInput;
          }
        } else {
          if (operation === 'create') {
            resolver = resolveRelateToOneForCreateInput;
          } else {
            resolver = resolveRelateToOneForUpdateInput;
          }
        }

        return resolver(nestedMutationState, context, foreignList, target);
      })());
    }

    return [fieldKey, input];
  }))); // Resolve input hooks

  const hookName = 'resolveInput'; // Field hooks

  let _resolvedData = {};
  const fieldsErrors = [];

  for (const [fieldKey, field] of Object.entries(list.fields)) {
    if (field.hooks.resolveInput === undefined) {
      _resolvedData[fieldKey] = resolvedData[fieldKey];
    } else {
      try {
        _resolvedData[fieldKey] = await field.hooks.resolveInput(_objectSpread(_objectSpread({}, hookArgs), {}, {
          resolvedData,
          fieldKey
        }));
      } catch (error) {
        fieldsErrors.push({
          error,
          tag: `${list.listKey}.${fieldKey}`
        });
      }
    }
  }

  if (fieldsErrors.length) {
    throw extensionError(hookName, fieldsErrors);
  }

  resolvedData = _resolvedData; // List hooks

  if (list.hooks.resolveInput) {
    try {
      resolvedData = await list.hooks.resolveInput(_objectSpread(_objectSpread({}, hookArgs), {}, {
        resolvedData
      }));
    } catch (error) {
      throw extensionError(hookName, [{
        error,
        tag: list.listKey
      }]);
    }
  }

  return resolvedData;
}

async function resolveInputForCreateOrUpdate(list, context, originalInput, existingItem) {
  const operation = existingItem === undefined ? 'create' : 'update';
  const nestedMutationState = new NestedMutationState(context);
  const {
    listKey
  } = list;
  const hookArgs = {
    context,
    listKey,
    operation,
    originalInput,
    existingItem,
    resolvedData: {}
  }; // Take the original input and resolve all the fields down to what
  // will be saved into the database.

  hookArgs.resolvedData = await getResolvedData(list, hookArgs, nestedMutationState); // Apply all validation checks

  await validateUpdateCreate({
    list,
    hookArgs
  }); // Run beforeChange hooks

  await runSideEffectOnlyHook(list, 'beforeChange', hookArgs); // Return the full resolved input (ready for prisma level operation),
  // and the afterChange hook to be applied

  return {
    data: flattenMultiDbFields(list.fields, hookArgs.resolvedData),
    afterChange: async updatedItem => {
      await nestedMutationState.afterChange();
      await runSideEffectOnlyHook(list, 'afterChange', _objectSpread(_objectSpread({}, hookArgs), {}, {
        updatedItem,
        existingItem
      }));
    }
  };
}

function flattenMultiDbFields(fields, data) {
  return Object.fromEntries(Object.entries(data).flatMap(([fieldKey, value]) => {
    const {
      dbField
    } = fields[fieldKey];

    if (dbField.kind === 'multi') {
      return Object.entries(value).map(([innerFieldKey, fieldValue]) => {
        return [getDBFieldKeyForFieldOnMultiField(fieldKey, innerFieldKey), fieldValue];
      });
    }

    return [[fieldKey, value]];
  }));
}

async function deleteSingle(uniqueInput, list, context, accessFilters, operationAccess, writeLimit) {
  // Operation level access control
  if (!operationAccess) {
    throw accessDeniedError();
  } // Validate and resolve the input filter


  const uniqueWhere = await resolveUniqueWhereInput(uniqueInput, list.fields, context); // Filter and Item access control. Will throw an accessDeniedError if not allowed.

  const existingItem = await getAccessControlledItemForDelete(list, context, uniqueWhere, accessFilters);
  const hookArgs = {
    operation: 'delete',
    listKey: list.listKey,
    context,
    existingItem
  }; // Apply all validation checks

  await validateDelete({
    list,
    hookArgs
  }); // Before delete

  await runSideEffectOnlyHook(list, 'beforeDelete', hookArgs);
  const item = await writeLimit(() => runWithPrisma(context, list, model => model.delete({
    where: {
      id: existingItem.id
    }
  })));
  await runSideEffectOnlyHook(list, 'afterDelete', hookArgs);
  return item;
}

async function deleteMany(uniqueInputs, list, context, provider) {
  const writeLimit = pLimit__default['default'](provider === 'sqlite' ? 1 : Infinity); // Check operation permission to pass into single operation

  const operationAccess = await checkOperationAccess(list, context, 'delete'); // Check filter permission to pass into single operation

  const accessFilters = await getAccessFilters(list, context, 'delete');
  return uniqueInputs.map(async uniqueInput => deleteSingle(uniqueInput, list, context, accessFilters, operationAccess, writeLimit));
}
async function deleteOne(uniqueInput, list, context) {
  // Check operation permission to pass into single operation
  const operationAccess = await checkOperationAccess(list, context, 'delete'); // Check filter permission to pass into single operation

  const accessFilters = await getAccessFilters(list, context, 'delete');
  return deleteSingle(uniqueInput, list, context, accessFilters, operationAccess, pLimit__default['default'](1));
}

// Basically, old keystone uses Promise.allSettled and then after that maps that into promises that resolve and reject,
// whereas the new stuff is just like "here are some promises" with no guarantees about the order they will be settled in.
// That doesn't matter when they all resolve successfully because the order they resolve successfully in
// doesn't affect anything, If some reject though, the order that they reject in will be the order in the errors array
// and some of our tests rely on the order of the graphql errors array. They shouldn't, but they do.

function promisesButSettledWhenAllSettledAndInOrder(promises) {
  const resultsPromise = Promise.allSettled(promises);
  return promises.map(async (_, i) => {
    const result = (await resultsPromise)[i];
    return result.status === 'fulfilled' ? Promise.resolve(result.value) : Promise.reject(result.reason);
  });
}

function getMutationsForList(list, provider) {
  const names = core.getGqlNames(list);
  const createOne$1 = apiWithContext.field({
    type: list.types.output,
    args: {
      data: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.create)
      })
    },

    resolve(_rootVal, {
      data
    }, context) {
      return createOne({
        data
      }, list, context);
    }

  });
  const createMany$1 = apiWithContext.field({
    type: apiWithoutContext.list(list.types.output),
    args: {
      data: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(apiWithoutContext.list(apiWithoutContext.nonNull(list.types.create)))
      })
    },

    async resolve(_rootVal, args, context) {
      return promisesButSettledWhenAllSettledAndInOrder(await createMany(args, list, context, provider));
    }

  });
  const updateOne$1 = apiWithContext.field({
    type: list.types.output,
    args: {
      where: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.uniqueWhere)
      }),
      data: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.update)
      })
    },

    resolve(_rootVal, args, context) {
      return updateOne(args, list, context);
    }

  });
  const updateManyInput = apiWithoutContext.inputObject({
    name: names.updateManyInputName,
    fields: {
      where: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.uniqueWhere)
      }),
      data: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.update)
      })
    }
  });
  const updateMany$1 = apiWithContext.field({
    type: apiWithoutContext.list(list.types.output),
    args: {
      data: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(apiWithoutContext.list(apiWithoutContext.nonNull(updateManyInput)))
      })
    },

    async resolve(_rootVal, args, context) {
      return promisesButSettledWhenAllSettledAndInOrder(await updateMany(args, list, context, provider));
    }

  });
  const deleteOne$1 = apiWithContext.field({
    type: list.types.output,
    args: {
      where: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.uniqueWhere)
      })
    },

    resolve(rootVal, {
      where
    }, context) {
      return deleteOne(where, list, context);
    }

  });
  const deleteMany$1 = apiWithContext.field({
    type: apiWithoutContext.list(list.types.output),
    args: {
      where: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(apiWithoutContext.list(apiWithoutContext.nonNull(list.types.uniqueWhere)))
      })
    },

    async resolve(rootVal, {
      where
    }, context) {
      return promisesButSettledWhenAllSettledAndInOrder(await deleteMany(where, list, context, provider));
    }

  });
  return {
    mutations: _objectSpread(_objectSpread(_objectSpread({}, list.graphql.isEnabled.create && {
      [names.createMutationName]: createOne$1,
      [names.createManyMutationName]: createMany$1
    }), list.graphql.isEnabled.update && {
      [names.updateMutationName]: updateOne$1,
      [names.updateManyMutationName]: updateMany$1
    }), list.graphql.isEnabled.delete && {
      [names.deleteMutationName]: deleteOne$1,
      [names.deleteManyMutationName]: deleteMany$1
    }),
    updateManyInput
  };
}

function getQueriesForList(list) {
  if (!list.graphql.isEnabled.query) return {};
  const names = core.getGqlNames(list);
  const findOne$1 = apiWithContext.field({
    type: list.types.output,
    args: {
      where: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.uniqueWhere)
      })
    },

    async resolve(_rootVal, args, context) {
      return findOne(args, list, context);
    }

  });
  const findMany$1 = apiWithContext.field({
    type: apiWithoutContext.list(apiWithoutContext.nonNull(list.types.output)),
    args: list.types.findManyArgs,

    async resolve(_rootVal, args, context, info) {
      return findMany(args, list, context, info);
    }

  });
  const countQuery = apiWithContext.field({
    type: apiWithoutContext.Int,
    args: {
      where: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.where),
        defaultValue: {}
      })
    },

    async resolve(_rootVal, args, context, info) {
      return count(args, list, context, info);
    }

  });
  return {
    [names.listQueryName]: findMany$1,
    [names.itemQueryName]: findOne$1,
    [names.listQueryCountName]: countQuery
  };
}

function getGraphQLSchema(lists, provider) {
  const query = apiWithContext.object()({
    name: 'Query',
    fields: Object.assign({}, ...Object.values(lists).map(list => getQueriesForList(list)))
  });
  const updateManyByList = {};
  const mutation = apiWithContext.object()({
    name: 'Mutation',
    fields: Object.assign({}, ...Object.values(lists).map(list => {
      const {
        mutations,
        updateManyInput
      } = getMutationsForList(list, provider);
      updateManyByList[list.listKey] = updateManyInput;
      return mutations;
    }))
  });
  const graphQLSchema = new graphql$1.GraphQLSchema({
    query: query.graphQLType,
    mutation: mutation.graphQLType,
    types: collectTypes(lists, updateManyByList)
  });
  return graphQLSchema;
}

function collectTypes(lists, updateManyByList) {
  const collectedTypes = [];

  for (const list of Object.values(lists)) {
    const {
      isEnabled
    } = list.graphql;
    if (!isEnabled.type) continue; // adding all of these types explicitly isn't strictly necessary but we do it to create a certain order in the schema

    collectedTypes.push(list.types.output.graphQLType);

    if (isEnabled.query || isEnabled.update || isEnabled.delete) {
      collectedTypes.push(list.types.uniqueWhere.graphQLType);
    }

    if (isEnabled.query) {
      for (const field of Object.values(list.fields)) {
        if (isEnabled.query && field.graphql.isEnabled.read && field.unreferencedConcreteInterfaceImplementations) {
          // this _IS_ actually necessary since they aren't implicitly referenced by other types, unlike the types above
          collectedTypes.push(...field.unreferencedConcreteInterfaceImplementations.map(x => x.graphQLType));
        }
      }

      collectedTypes.push(list.types.where.graphQLType);
      collectedTypes.push(list.types.orderBy.graphQLType);
    }

    if (isEnabled.update) {
      collectedTypes.push(list.types.update.graphQLType);
      collectedTypes.push(updateManyByList[list.listKey].graphQLType);
    }

    if (isEnabled.create) {
      collectedTypes.push(list.types.create.graphQLType);
    }
  } // this is not necessary, just about ordering


  collectedTypes.push(sqlite.JSON.graphQLType);
  return collectedTypes;
}

function createGraphQLSchema(config, lists, adminMeta) {
  // Start with the core keystone graphQL schema
  let graphQLSchema = getGraphQLSchema(lists, getDBProvider(config.db)); // Merge in the user defined graphQL API

  if (config.extendGraphqlSchema) {
    graphQLSchema = config.extendGraphqlSchema(graphQLSchema);
  } // Merge in session graphQL API


  if (config.session) {
    graphQLSchema = session_dist_keystone.sessionSchema(graphQLSchema);
  } // Merge in the admin-meta graphQL API


  graphQLSchema = getAdminMetaSchema({
    adminMeta,
    config,
    graphQLSchema,
    lists
  });
  return graphQLSchema;
}

function getNamedOrListTypeNodeForType(type) {
  if (type instanceof graphql$1.GraphQLList) {
    return {
      kind: 'ListType',
      type: getTypeNodeForType(type.ofType)
    };
  }

  return {
    kind: 'NamedType',
    name: {
      kind: 'Name',
      value: type.name
    }
  };
}

function getTypeNodeForType(type) {
  if (type instanceof graphql$1.GraphQLNonNull) {
    return {
      kind: 'NonNullType',
      type: getNamedOrListTypeNodeForType(type.ofType)
    };
  }

  return getNamedOrListTypeNodeForType(type);
}
function getVariablesForGraphQLField(field) {
  const variableDefinitions = field.args.map(arg => {
    var _astFromValue;

    return {
      kind: 'VariableDefinition',
      type: getTypeNodeForType(arg.type),
      variable: {
        kind: 'Variable',
        name: {
          kind: 'Name',
          value: arg.name
        }
      },
      defaultValue: arg.defaultValue === undefined ? undefined : (_astFromValue = graphql$1.astFromValue(arg.defaultValue, arg.type)) !== null && _astFromValue !== void 0 ? _astFromValue : undefined
    };
  });
  const argumentNodes = field.args.map(arg => ({
    kind: 'Argument',
    name: {
      kind: 'Name',
      value: arg.name
    },
    value: {
      kind: 'Variable',
      name: {
        kind: 'Name',
        value: arg.name
      }
    }
  }));
  return {
    variableDefinitions,
    argumentNodes
  };
}
const rawField = 'raw';
const RawScalar = new graphql$1.GraphQLScalarType({
  name: 'RawThingPlsDontRelyOnThisAnywhere'
});
const ReturnRawValueObjectType = new graphql$1.GraphQLObjectType({
  name: 'ReturnRawValue',
  fields: {
    [rawField]: {
      type: RawScalar,

      resolve(rootVal) {
        return rootVal;
      }

    }
  }
});

function argsToArgsConfig(args) {
  return Object.fromEntries(args.map(arg => {
    const argConfig = {
      astNode: arg.astNode,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      description: arg.description,
      extensions: arg.extensions,
      type: arg.type
    };
    return [arg.name, argConfig];
  }));
}

// note the GraphQLNonNull and GraphQLList constructors are incorrectly
// not generic over their inner type which is why we have to use as
// (the classes are generic but not the constructors)
function getTypeForField(originalType) {
  if (originalType instanceof graphql$1.GraphQLNonNull) {
    return new graphql$1.GraphQLNonNull(getTypeForField(originalType.ofType));
  }

  if (originalType instanceof graphql$1.GraphQLList) {
    return new graphql$1.GraphQLList(getTypeForField(originalType.ofType));
  }

  return ReturnRawValueObjectType;
}

function getRootValGivenOutputType(originalType, value) {
  if (originalType instanceof graphql$1.GraphQLNonNull) {
    return getRootValGivenOutputType(originalType.ofType, value);
  }

  if (originalType instanceof graphql$1.GraphQLList) {
    if (value === null) return null;
    return value.map(x => getRootValGivenOutputType(originalType.ofType, x));
  }

  return value[rawField];
}

function executeGraphQLFieldToRootVal(field) {
  const {
    argumentNodes,
    variableDefinitions
  } = getVariablesForGraphQLField(field);
  const document = {
    kind: 'Document',
    definitions: [{
      kind: 'OperationDefinition',
      operation: 'query',
      selectionSet: {
        kind: 'SelectionSet',
        selections: [{
          kind: 'Field',
          name: {
            kind: 'Name',
            value: field.name
          },
          arguments: argumentNodes,
          selectionSet: {
            kind: 'SelectionSet',
            selections: [{
              kind: 'Field',
              name: {
                kind: 'Name',
                value: rawField
              }
            }]
          }
        }]
      },
      variableDefinitions
    }]
  };
  const type = getTypeForField(field.type);
  const fieldConfig = {
    args: argsToArgsConfig(field.args),
    astNode: undefined,
    deprecationReason: field.deprecationReason,
    description: field.description,
    extensions: field.extensions,
    resolve: field.resolve,
    subscribe: field.subscribe,
    type
  };
  const schema = new graphql$1.GraphQLSchema({
    query: new graphql$1.GraphQLObjectType({
      name: 'Query',
      fields: {
        [field.name]: fieldConfig
      }
    })
  });
  const validationErrors = graphql$1.validate(schema, document);

  if (validationErrors.length > 0) {
    throw validationErrors[0];
  }

  return async (args, context, rootValue = {}) => {
    var _result$errors;

    const result = await graphql$1.execute({
      schema,
      document,
      contextValue: context,
      variableValues: args,
      rootValue
    });

    if ((_result$errors = result.errors) !== null && _result$errors !== void 0 && _result$errors.length) {
      throw result.errors[0];
    }

    return getRootValGivenOutputType(type, result.data[field.name]);
  };
}

function getRootTypeName(type) {
  if (type instanceof graphql$1.GraphQLNonNull) {
    return getRootTypeName(type.ofType);
  }

  if (type instanceof graphql$1.GraphQLList) {
    return getRootTypeName(type.ofType);
  }

  return type.name;
}

function executeGraphQLFieldWithSelection(schema, operation, fieldName) {
  const rootType = operation === 'mutation' ? schema.getMutationType() : schema.getQueryType();
  const field = rootType.getFields()[fieldName];

  if (field === undefined) {
    return () => {
      throw new Error('You do not have access to this resource');
    };
  }

  const {
    argumentNodes,
    variableDefinitions
  } = getVariablesForGraphQLField(field);
  const rootName = getRootTypeName(field.type);
  return async (args, query, context) => {
    var _result$errors;

    const selectionSet = graphql$1.parse(`fragment x on ${rootName} {${query}}`).definitions[0].selectionSet;
    const document = {
      kind: 'Document',
      definitions: [{
        kind: 'OperationDefinition',
        operation,
        selectionSet: {
          kind: 'SelectionSet',
          selections: [{
            kind: 'Field',
            name: {
              kind: 'Name',
              value: field.name
            },
            arguments: argumentNodes,
            selectionSet: selectionSet
          }]
        },
        variableDefinitions
      }]
    };
    const validationErrors = graphql$1.validate(schema, document);

    if (validationErrors.length > 0) {
      throw validationErrors[0];
    }

    const result = await graphql$1.execute({
      schema,
      document,
      contextValue: context,
      variableValues: Object.fromEntries( // GraphQL for some reason decides to make undefined values in args
      // skip defaulting for some reason
      // this ofc doesn't technically fully fix it (bc nested things)
      // but for the cases where we care, it does
      Object.entries(args).filter(([, val]) => val !== undefined)),
      rootValue: {}
    });

    if ((_result$errors = result.errors) !== null && _result$errors !== void 0 && _result$errors.length) {
      throw result.errors[0];
    }

    return result.data[field.name];
  };
}

const _excluded = ["query", "resolveFields"];
// (i mean it's not really any more incorrect than TS is generally is but let's ignore that)

const objectEntriesButUsingKeyof = Object.entries;
function getDbAPIFactory(gqlNames, schema) {
  const queryFields = schema.getQueryType().getFields();
  const mutationFields = schema.getMutationType().getFields();

  const f = field => {
    if (field === undefined) {
      return () => {
        throw new Error('You do not have access to this resource');
      };
    }

    return executeGraphQLFieldToRootVal(field);
  };

  const api = {
    findOne: f(queryFields[gqlNames.itemQueryName]),
    findMany: f(queryFields[gqlNames.listQueryName]),
    count: f(queryFields[gqlNames.listQueryCountName]),
    createOne: f(mutationFields[gqlNames.createMutationName]),
    createMany: f(mutationFields[gqlNames.createManyMutationName]),
    updateOne: f(mutationFields[gqlNames.updateMutationName]),
    updateMany: f(mutationFields[gqlNames.updateManyMutationName]),
    deleteOne: f(mutationFields[gqlNames.deleteMutationName]),
    deleteMany: f(mutationFields[gqlNames.deleteManyMutationName])
  };
  return context => Object.fromEntries(objectEntriesButUsingKeyof(api).map(([key, impl]) => [key, args => impl(args, context)]));
}

function defaultQueryParam(query, resolveFields) {
  if (query !== undefined && resolveFields !== undefined) {
    throw new Error('query and resolveFields cannot both be passed to an Items API query');
  }

  if (query !== undefined) return query;
  if (resolveFields !== undefined) return resolveFields;
  return 'id';
}
/* NOTE
 *
 * The `resolveFields` param has been deprecated in favor of `query` (when selecting fields to
 * query) or the new dbAPI which is available via `context.db.lists.{List}`, which replaces
 * the previous `resolveFields: false` behaviour.
 *
 * We'll be removing the option to use `resolveFields` entirely in a future release.
 */


function itemAPIForList(listKey, context, dbAPI) {
  const f = (operation, field, dbAPIVersionOfAPI) => {
    const exec = executeGraphQLFieldWithSelection(context.graphql.schema, operation, field);
    return (_ref = {}) => {
      let {
        query,
        resolveFields
      } = _ref,
          args = _objectWithoutProperties(_ref, _excluded);

      const returnFields = defaultQueryParam(query, resolveFields);

      if (returnFields) {
        return exec(args, returnFields, context);
      } else {
        return dbAPIVersionOfAPI(args);
      }
    };
  };

  const gqlNames = context.gqlNames(listKey);
  return {
    findOne: f('query', gqlNames.itemQueryName, dbAPI.findOne),
    findMany: f('query', gqlNames.listQueryName, dbAPI.findMany),

    async count({
      where = {}
    } = {}) {
      const {
        listQueryCountName,
        whereInputName
      } = context.gqlNames(listKey);
      const query = `query ($where: ${whereInputName}!) { count: ${listQueryCountName}(where: $where)  }`;
      const response = await context.graphql.run({
        query,
        variables: {
          where
        }
      });
      return response.count;
    },

    createOne: f('mutation', gqlNames.createMutationName, dbAPI.createOne),
    createMany: f('mutation', gqlNames.createManyMutationName, dbAPI.createMany),
    updateOne: f('mutation', gqlNames.updateMutationName, dbAPI.updateOne),
    updateMany: f('mutation', gqlNames.updateManyMutationName, dbAPI.updateMany),
    deleteOne: f('mutation', gqlNames.deleteMutationName, dbAPI.deleteOne),
    deleteMany: f('mutation', gqlNames.deleteManyMutationName, dbAPI.deleteMany)
  };
}

const getImagesSubdomain = ({
  apiKey
}) => {
  const [, domain] = apiKey.split('__IMAGES_DOMAIN__');

  if (!domain) {
    throw new Error('Your API key is outdated, please regenerate it and add the new key to your Keystone config');
  }

  return domain;
};

const getS3Bucket = async ({
  apiKey,
  graphqlApiEndpoint
}) => {
  const response = await fetch__default['default'](graphqlApiEndpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      query: `
        query($apiKey:String) {
          allAmazonS3Buckets(where: { project: { apiKey: { apiKey: $apiKey } } }) {
            bucketName,
            prefix,
            region
          }
        }
      `,
      variables: {
        apiKey
      }
    })
  });
  const json = await response.json();
  const {
    data
  } = json;
  const {
    allAmazonS3Buckets
  } = data;
  return allAmazonS3Buckets[0];
};

const uploadAsset = async ({
  apiKey,
  filename,
  inputFieldName,
  stream,
  apiRoute,
  restApiEndpoint
}) => {
  const form = new FormData__default['default']();
  form.append(inputFieldName, stream, filename);
  const response = await fetch__default['default'](`${restApiEndpoint}/${apiRoute}`, {
    method: 'POST',
    body: form,
    headers: {
      Authorization: `Bearer ${apiKey}`
    }
  });
  return await response.json();
};

const buildKeystoneCloudImageSrc = async ({
  apiKey,
  filename,
  imagesDomain
}) => {
  const imagesSubdomain = getImagesSubdomain({
    apiKey
  });
  return `http://${imagesSubdomain}.${imagesDomain}/${filename}`;
};
const buildKeystoneCloudFileSrc = async ({
  apiKey,
  graphqlApiEndpoint,
  filename
}) => {
  const {
    bucketName,
    prefix,
    region
  } = await getS3Bucket({
    apiKey,
    graphqlApiEndpoint
  });
  return `https://${bucketName}.s3.${region}.amazonaws.com/${prefix}/${filename}`;
};
const getImageMetadataFromKeystoneCloud = async ({
  apiKey,
  filename,
  restApiEndpoint
}) => {
  const response = await fetch__default['default'](`${restApiEndpoint}/images/${filename}`, {
    headers: {
      Authorization: `Bearer ${apiKey}`
    }
  });
  return await response.json();
};
const getFileFromKeystoneCloud = async ({
  apiKey,
  filename,
  restApiEndpoint
}) => {
  const response = await fetch__default['default'](`${restApiEndpoint}/files/${filename}`, {
    headers: {
      Authorization: `Bearer ${apiKey}`
    }
  });
  return await response.json();
};
const uploadImageToKeystoneCloud = async ({
  apiKey,
  stream,
  filename,
  restApiEndpoint
}) => uploadAsset({
  apiKey,
  stream,
  filename,
  restApiEndpoint,
  inputFieldName: 'image',
  apiRoute: 'images'
});
const uploadFileToKeystoneCloud = async ({
  apiKey,
  stream,
  filename,
  restApiEndpoint
}) => uploadAsset({
  apiKey,
  stream,
  filename,
  restApiEndpoint,
  inputFieldName: 'file',
  apiRoute: 'files'
});

const DEFAULT_BASE_URL$1 = '/images';
const DEFAULT_STORAGE_PATH$1 = './public/images';

const getImageMetadataFromBuffer = async buffer => {
  const filesize = buffer.length;
  const fileType = fromBuffer__default['default'](buffer);

  if (!fileType) {
    throw new Error('File type not found');
  }

  if (fileType.ext !== 'jpg' && fileType.ext !== 'png' && fileType.ext !== 'webp' && fileType.ext !== 'gif') {
    throw new Error(`${fileType.ext} is not a supported image type`);
  }

  const extension = fileType.ext;
  const {
    height,
    width
  } = imageSize__default['default'](buffer);

  if (width === undefined || height === undefined) {
    throw new Error('Height and width could not be found for image');
  }

  return {
    width,
    height,
    filesize,
    extension
  };
};

function createImagesContext(config) {
  if (!config.images) {
    return;
  }

  const {
    images,
    experimental
  } = config;
  const {
    baseUrl = DEFAULT_BASE_URL$1,
    storagePath = DEFAULT_STORAGE_PATH$1
  } = images.local || {};
  const {
    apiKey = '',
    imagesDomain = '',
    restApiEndpoint = ''
  } = (experimental === null || experimental === void 0 ? void 0 : experimental.keystoneCloud) || {};

  if (images.upload === 'local') {
    fs__default['default'].mkdirSync(storagePath, {
      recursive: true
    });
  }

  return {
    getSrc: async (mode, id, extension) => {
      const filename = `${id}.${extension}`;

      if (mode === 'keystone-cloud') {
        return await buildKeystoneCloudImageSrc({
          apiKey,
          imagesDomain,
          filename
        });
      }

      return `${baseUrl}/${filename}`;
    },
    getDataFromRef: async ref => {
      const imageRef = fields_types_image_utils_dist_keystone.parseImageRef(ref);

      if (!imageRef) {
        throw new Error('Invalid image reference');
      }

      const {
        mode
      } = imageRef;

      if (mode === 'keystone-cloud') {
        const {
          id,
          extension
        } = imageRef;
        const filename = `${id}.${extension}`;
        const metadata = await getImageMetadataFromKeystoneCloud({
          filename,
          apiKey,
          restApiEndpoint
        });
        return _objectSpread(_objectSpread({}, imageRef), metadata);
      }

      const buffer = await fs__default['default'].readFile(Path__namespace['default'].join(storagePath, `${imageRef.id}.${imageRef.extension}`));
      const metadata = await getImageMetadataFromBuffer(buffer);
      return _objectSpread(_objectSpread({}, imageRef), metadata);
    },
    getDataFromStream: async stream => {
      const {
        upload: mode
      } = images;
      const id = uuid.v4();

      if (mode === 'keystone-cloud') {
        const metadata = await uploadImageToKeystoneCloud({
          apiKey,
          stream,
          restApiEndpoint,
          filename: id
        });
        return _objectSpread({
          mode,
          id
        }, metadata);
      }

      const chunks = [];

      for await (let chunk of stream) {
        chunks.push(chunk);
      }

      const buffer = Buffer.concat(chunks);
      const metadata = await getImageMetadataFromBuffer(buffer);
      await fs__default['default'].writeFile(Path__namespace['default'].join(storagePath, `${id}.${metadata.extension}`), buffer);
      return _objectSpread({
        mode,
        id
      }, metadata);
    }
  };
}

const DEFAULT_BASE_URL = '/files';
const DEFAULT_STORAGE_PATH = './public/files';

const defaultTransformer = str => slugify__default['default'](str);

const generateSafeFilename = (filename, transformFilename = defaultTransformer) => {
  // Appends a UUID to the filename so that people can't brute-force guess stored filenames
  //
  // This regex lazily matches for any characters that aren't a new line
  // it then optionally matches the last instance of a "." symbol
  // followed by any alphabetical character before the end of the string
  const [, name, ext] = filename.match(/^([^:\n].*?)(\.[A-Za-z]+)?$/);
  const id = crypto__default['default'].randomBytes(24).toString('base64').replace(/[^a-zA-Z0-9]/g, '').slice(12); // console.log(id, id.length, id.slice(12).length);

  const urlSafeName = filenamify__default['default'](transformFilename(name), {
    maxLength: 100 - id.length,
    replacement: '-'
  });

  if (ext) {
    return `${urlSafeName}-${id}${ext}`;
  }

  return `${urlSafeName}-${id}`;
};

function createFilesContext(config) {
  if (!config.files) {
    return;
  }

  const {
    files,
    experimental
  } = config;
  const {
    baseUrl = DEFAULT_BASE_URL,
    storagePath = DEFAULT_STORAGE_PATH
  } = files.local || {};
  const {
    apiKey = '',
    graphqlApiEndpoint = '',
    restApiEndpoint = ''
  } = (experimental === null || experimental === void 0 ? void 0 : experimental.keystoneCloud) || {};

  if (files.upload === 'local') {
    fs__default['default'].mkdirSync(storagePath, {
      recursive: true
    });
  }

  return {
    getSrc: async (mode, filename) => {
      if (mode === 'keystone-cloud') {
        return await buildKeystoneCloudFileSrc({
          apiKey,
          graphqlApiEndpoint,
          filename
        });
      }

      return `${baseUrl}/${filename}`;
    },
    getDataFromRef: async ref => {
      const fileRef = fields_types_file_utils_dist_keystone.parseFileRef(ref);

      if (!fileRef) {
        throw new Error('Invalid file reference');
      }

      const {
        mode,
        filename
      } = fileRef;

      if (mode === 'keystone-cloud') {
        const {
          filesize
        } = await getFileFromKeystoneCloud({
          apiKey,
          filename,
          restApiEndpoint
        });
        return _objectSpread({
          filesize
        }, fileRef);
      }

      const {
        size: filesize
      } = await fs__default['default'].stat(Path__namespace['default'].join(storagePath, fileRef.filename));
      return _objectSpread({
        filesize
      }, fileRef);
    },
    getDataFromStream: async (stream$1, originalFilename) => {
      const {
        upload: mode
      } = files;
      const filename = generateSafeFilename(originalFilename, files.transformFilename);

      if (mode === 'keystone-cloud') {
        const {
          filesize
        } = await uploadFileToKeystoneCloud({
          apiKey,
          stream: stream$1,
          filename,
          restApiEndpoint
        });
        return {
          mode,
          filesize,
          filename
        };
      }

      const writeStream = fs__default['default'].createWriteStream(Path__namespace['default'].join(storagePath, filename));
      const pipeStreams = new Promise((resolve, reject) => {
        stream.pipeline(stream$1, writeStream, err => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });

      try {
        await pipeStreams;
        const {
          size: filesize
        } = await fs__default['default'].stat(Path__namespace['default'].join(storagePath, filename));
        return {
          mode,
          filesize,
          filename
        };
      } catch (e) {
        await fs__default['default'].remove(Path__namespace['default'].join(storagePath, filename));
        throw e;
      }
    }
  };
}

function makeCreateContext({
  graphQLSchema,
  internalSchema,
  prismaClient,
  gqlNamesByList,
  config,
  lists
}) {
  const images = createImagesContext(config);
  const files = createFilesContext(config); // We precompute these helpers here rather than every time createContext is called
  // because they involve creating a new GraphQLSchema, creating a GraphQL document AST(programmatically, not by parsing) and validating the
  // note this isn't as big of an optimisation as you would imagine(at least in comparison with the rest of the system),
  // the regular non-db lists api does more expensive things on every call
  // like parsing the generated GraphQL document, and validating it against the schema on _every_ call
  // is that really that bad? no not really. this has just been more optimised because the cost of what it's
  // doing is more obvious(even though in reality it's much smaller than the alternative)

  const publicDbApiFactories = {};

  for (const [listKey, gqlNames] of Object.entries(gqlNamesByList)) {
    publicDbApiFactories[listKey] = getDbAPIFactory(gqlNames, graphQLSchema);
  }

  const internalDbApiFactories = {};

  for (const [listKey, gqlNames] of Object.entries(gqlNamesByList)) {
    internalDbApiFactories[listKey] = getDbAPIFactory(gqlNames, internalSchema);
  }

  const createContext = ({
    sessionContext,
    skipAccessControl = false,
    req,
    schemaName = 'public'
  } = {}) => {
    var _config$graphql$query, _config$graphql, _config$graphql$query2, _config$experimental;

    const schema = schemaName === 'public' ? graphQLSchema : internalSchema;

    const rawGraphQL = ({
      query,
      variables
    }) => {
      const source = typeof query === 'string' ? query : graphql$1.print(query);
      return Promise.resolve(graphql$1.graphql({
        schema,
        source,
        contextValue: contextToReturn,
        variableValues: variables
      }));
    };

    const runGraphQL = async ({
      query,
      variables
    }) => {
      var _result$errors;

      let result = await rawGraphQL({
        query,
        variables
      });

      if ((_result$errors = result.errors) !== null && _result$errors !== void 0 && _result$errors.length) {
        throw result.errors[0];
      }

      return result.data;
    };

    const dbAPI = {};
    const itemAPI = {};

    const contextToReturn = _objectSpread(_objectSpread({
      schemaName,
      db: {
        lists: dbAPI
      },
      lists: itemAPI,
      totalResults: 0,
      prisma: prismaClient,
      graphql: {
        raw: rawGraphQL,
        run: runGraphQL,
        schema
      },
      maxTotalResults: (_config$graphql$query = (_config$graphql = config.graphql) === null || _config$graphql === void 0 ? void 0 : (_config$graphql$query2 = _config$graphql.queryLimits) === null || _config$graphql$query2 === void 0 ? void 0 : _config$graphql$query2.maxTotalResults) !== null && _config$graphql$query !== void 0 ? _config$graphql$query : Infinity,
      sudo: () => createContext({
        sessionContext,
        skipAccessControl: true,
        req,
        schemaName: 'internal'
      }),
      exitSudo: () => createContext({
        sessionContext,
        skipAccessControl: false,
        req
      }),
      withSession: session => createContext({
        sessionContext: _objectSpread(_objectSpread({}, sessionContext), {}, {
          session
        }),
        skipAccessControl,
        req
      }),
      req
    }, sessionContext), {}, {
      // Note: This field lets us use the server-side-graphql-client library.
      // We may want to remove it once the updated itemAPI w/ query is available.
      gqlNames: listKey => gqlNamesByList[listKey],
      images,
      files
    });

    if ((_config$experimental = config.experimental) !== null && _config$experimental !== void 0 && _config$experimental.contextInitialisedLists) {
      contextToReturn.experimental = {
        initialisedLists: lists
      };
    }

    const dbAPIFactories = schemaName === 'public' ? publicDbApiFactories : internalDbApiFactories;

    for (const listKey of Object.keys(gqlNamesByList)) {
      dbAPI[listKey] = dbAPIFactories[listKey](contextToReturn);
      itemAPI[listKey] = itemAPIForList(listKey, contextToReturn, dbAPI[listKey]);
    }

    return contextToReturn;
  };

  return createContext;
}

// note: all keystone fields correspond to a field here
// not all fields here correspond to keystone fields(the implicit side of one-sided relation fields)
function sortRelationships(left, right) {
  const order = left.listKey.localeCompare(right.listKey);

  if (order > 0) {
    // left comes after right, so swap them.
    return [right, left];
  } else if (order === 0) {
    // self referential list, so check the paths.
    if (left.fieldPath.localeCompare(right.fieldPath) > 0) {
      return [right, left];
    }
  }

  return [left, right];
} // what's going on here:
// - validating all the relationships
// - for relationships involving to-one: deciding which side owns the foreign key
// - turning one-sided relationships into two-sided relationships so that elsewhere in Keystone,
//   you only have to reason about two-sided relationships
//   (note that this means that there are "fields" in the returned ListsWithResolvedRelations
//   which are not actually proper Keystone fields, they are just a db field and nothing else)


function resolveRelationships(lists) {
  const alreadyResolvedTwoSidedRelationships = new Set();
  const resolvedLists = Object.fromEntries(Object.keys(lists).map(listKey => [listKey, {}]));

  for (const [listKey, fields] of Object.entries(lists)) {
    const resolvedList = resolvedLists[listKey];

    for (const [fieldPath, {
      dbField: field
    }] of Object.entries(fields.fields)) {
      if (field.kind !== 'relation') {
        resolvedList[fieldPath] = field;
        continue;
      }

      const foreignUnresolvedList = lists[field.list];

      if (!foreignUnresolvedList) {
        throw new Error(`The relationship field at ${listKey}.${fieldPath} points to the list ${listKey} which does not exist`);
      }

      if (field.field) {
        var _foreignUnresolvedLis;

        const localRef = `${listKey}.${fieldPath}`;
        const foreignRef = `${field.list}.${field.field}`;

        if (alreadyResolvedTwoSidedRelationships.has(localRef)) {
          continue;
        }

        alreadyResolvedTwoSidedRelationships.add(foreignRef);
        const foreignField = (_foreignUnresolvedLis = foreignUnresolvedList.fields[field.field]) === null || _foreignUnresolvedLis === void 0 ? void 0 : _foreignUnresolvedLis.dbField;

        if (!foreignField) {
          throw new Error(`The relationship field at ${localRef} points to ${foreignRef} but no field at ${foreignRef} exists`);
        }

        if (foreignField.kind !== 'relation') {
          throw new Error(`The relationship field at ${localRef} points to ${foreignRef} but ${foreignRef} is not a relationship field`);
        }

        if (foreignField.list !== listKey) {
          throw new Error(`The relationship field at ${localRef} points to ${foreignRef} but ${foreignRef} points to the list ${foreignField.list} rather than ${listKey}`);
        }

        if (foreignField.field === undefined) {
          throw new Error(`The relationship field at ${localRef} points to ${foreignRef}, ${localRef} points to ${listKey} correctly but does not point to the ${fieldPath} field when it should`);
        }

        if (foreignField.field !== fieldPath) {
          throw new Error(`The relationship field at ${localRef} points to ${foreignRef}, ${localRef} points to ${listKey} correctly but points to the ${foreignField.field} field instead of ${fieldPath}`);
        }

        let [leftRel, rightRel] = sortRelationships({
          listKey,
          fieldPath,
          mode: field.mode
        }, {
          listKey: field.list,
          fieldPath: field.field,
          mode: foreignField.mode
        });

        if (leftRel.mode === 'one' && rightRel.mode === 'one') {
          const relationName = `${leftRel.listKey}_${leftRel.fieldPath}`;
          resolvedLists[leftRel.listKey][leftRel.fieldPath] = {
            kind: 'relation',
            mode: 'one',
            field: rightRel.fieldPath,
            list: rightRel.listKey,
            foreignIdField: 'owned-unique',
            relationName
          };
          resolvedLists[rightRel.listKey][rightRel.fieldPath] = {
            kind: 'relation',
            mode: 'one',
            field: leftRel.fieldPath,
            list: leftRel.listKey,
            foreignIdField: 'none',
            relationName
          };
          continue;
        }

        if (leftRel.mode === 'many' && rightRel.mode === 'many') {
          const relationName = `${leftRel.listKey}_${leftRel.fieldPath}_${rightRel.listKey}_${rightRel.fieldPath}`;
          resolvedLists[leftRel.listKey][leftRel.fieldPath] = {
            kind: 'relation',
            mode: 'many',
            field: rightRel.fieldPath,
            list: rightRel.listKey,
            relationName
          };
          resolvedLists[rightRel.listKey][rightRel.fieldPath] = {
            kind: 'relation',
            mode: 'many',
            field: leftRel.fieldPath,
            list: leftRel.listKey,
            relationName
          };
          continue;
        } // if we're here, we're in a 1:N
        // and we want to make sure the 1 side on the left and the many on the right
        // (technically only one of these checks is necessary, the other one will have to be true if one is
        // but this communicates what's going on here)


        if (leftRel.mode === 'many' && rightRel.mode === 'one') {
          [leftRel, rightRel] = [rightRel, leftRel];
        }

        const relationName = `${leftRel.listKey}_${leftRel.fieldPath}`;
        resolvedLists[leftRel.listKey][leftRel.fieldPath] = {
          kind: 'relation',
          mode: 'one',
          field: rightRel.fieldPath,
          list: rightRel.listKey,
          foreignIdField: 'owned',
          relationName
        };
        resolvedLists[rightRel.listKey][rightRel.fieldPath] = {
          kind: 'relation',
          mode: 'many',
          field: leftRel.fieldPath,
          list: leftRel.listKey,
          relationName
        };
        continue;
      }

      const foreignFieldPath = `from_${listKey}_${fieldPath}`;

      if (foreignUnresolvedList.fields[foreignFieldPath]) {
        throw new Error(`The relationship field at ${listKey}.${fieldPath} points to the list ${field.list}, Keystone needs to a create a relationship field at ${field.list}.${foreignFieldPath} to support the relationship at ${listKey}.${fieldPath} but ${field.list} already has a field named ${foreignFieldPath}`);
      }

      if (field.mode === 'many') {
        const relationName = `${listKey}_${fieldPath}_many`;
        resolvedLists[field.list][foreignFieldPath] = {
          kind: 'relation',
          mode: 'many',
          list: listKey,
          field: fieldPath,
          relationName
        };
        resolvedList[fieldPath] = {
          kind: 'relation',
          mode: 'many',
          list: field.list,
          field: foreignFieldPath,
          relationName
        };
      } else {
        const relationName = `${listKey}_${fieldPath}`;
        resolvedLists[field.list][foreignFieldPath] = {
          kind: 'relation',
          mode: 'many',
          list: listKey,
          field: fieldPath,
          relationName
        };
        resolvedList[fieldPath] = {
          kind: 'relation',
          list: field.list,
          field: foreignFieldPath,
          foreignIdField: 'owned',
          relationName,
          mode: 'one'
        };
      }
    }
  } // the way we resolve the relationships means that the relationships will be in a
  // different order than the order the user specified in their config
  // doesn't really change the behaviour of anything but it means that the order of the fields in the prisma schema will be
  // the same as the user provided


  return Object.fromEntries(Object.entries(resolvedLists).map(([listKey, outOfOrderDbFields]) => {
    // this adds the fields based on the order that the user passed in
    // (except it will not add the opposites to one-sided relations)
    const resolvedDbFields = Object.fromEntries(Object.keys(lists[listKey].fields).map(fieldKey => [fieldKey, outOfOrderDbFields[fieldKey]])); // then we add the opposites to one-sided relations

    Object.assign(resolvedDbFields, outOfOrderDbFields);
    return [listKey, {
      resolvedDbFields
    }];
  }));
}

function getRelationVal(dbField, id, foreignList, context, info) {
  const oppositeDbField = foreignList.resolvedDbFields[dbField.field];
  if (oppositeDbField.kind !== 'relation') throw new Error('failed assert');
  const relationFilter = {
    [dbField.field]: oppositeDbField.mode === 'many' ? {
      some: {
        id
      }
    } : {
      id
    }
  };

  if (dbField.mode === 'many') {
    return {
      findMany: async args => findMany(args, foreignList, context, info, relationFilter),
      count: async ({
        where
      }) => count({
        where
      }, foreignList, context, info, relationFilter)
    };
  } else {
    return async () => {
      // Check operation permission to pass into single operation
      const operationAccess = await checkOperationAccess(foreignList, context, 'query');

      if (!operationAccess) {
        return null;
      }

      const accessFilters = await getAccessFilters(foreignList, context, 'query');

      if (accessFilters === false) {
        return null;
      }

      const resolvedWhere = await accessControlledFilter(foreignList, context, relationFilter, accessFilters);
      return runWithPrisma(context, foreignList, model => model.findFirst({
        where: resolvedWhere
      }));
    };
  }
}

function getValueForDBField(rootVal, dbField, id, fieldPath, context, lists, info) {
  if (dbField.kind === 'multi') {
    return Object.fromEntries(Object.keys(dbField.fields).map(innerDBFieldKey => {
      const keyOnDbValue = getDBFieldKeyForFieldOnMultiField(fieldPath, innerDBFieldKey);
      return [innerDBFieldKey, rootVal[keyOnDbValue]];
    }));
  }

  if (dbField.kind === 'relation') {
    return getRelationVal(dbField, id, lists[dbField.list], context, info);
  } else {
    return rootVal[fieldPath];
  }
}

function outputTypeField(output, dbField, cacheHint, access, listKey, fieldKey, lists) {
  return apiWithContext.field({
    type: output.type,
    deprecationReason: output.deprecationReason,
    description: output.description,
    args: output.args,
    extensions: output.extensions,

    async resolve(rootVal, args, context, info) {
      const id = rootVal.id; // Check access

      const canAccess = await validateFieldAccessControl({
        access,
        args: {
          context,
          fieldKey,
          item: rootVal,
          listKey,
          operation: 'read',
          session: context.session
        }
      });

      if (!canAccess) {
        return null;
      } // Only static cache hints are supported at the field level until a use-case makes it clear what parameters a dynamic hint would take


      if (cacheHint && info && info.cacheControl) {
        info.cacheControl.setCacheHint(cacheHint);
      }

      const value = getValueForDBField(rootVal, dbField, id, fieldKey, context, lists, info);

      if (output.resolve) {
        return output.resolve({
          value,
          item: rootVal
        }, args, context, info);
      } else {
        return value;
      }
    }

  });
}

function assertFieldsValid(list) {
  assertNoConflictingExtraOutputFields(list);
  assertIdFieldGraphQLTypesCorrect(list);
  assertNoFieldKeysThatConflictWithFilterCombinators(list);
  assertUniqueWhereInputsValid(list);
}

function assertUniqueWhereInputsValid(list) {
  for (const [fieldKey, {
    dbField,
    input
  }] of Object.entries(list.fields)) {
    if (input !== null && input !== void 0 && input.uniqueWhere) {
      if (dbField.kind !== 'scalar' || dbField.scalar !== 'String' && dbField.scalar !== 'Int') {
        throw new Error(`Only String and Int scalar db fields can provide a uniqueWhere input currently but the field at ${list.listKey}.${fieldKey} specifies a uniqueWhere input`);
      }

      if (dbField.index !== 'unique' && fieldKey !== 'id') {
        throw new Error(`Fields must have a unique index or be the idField to specify a uniqueWhere input but the field at ${list.listKey}.${fieldKey} specifies a uniqueWhere input without a unique index`);
      }
    }
  }
}

function assertNoFieldKeysThatConflictWithFilterCombinators(list) {
  for (const fieldKey of Object.keys(list.fields)) {
    if (fieldKey === 'AND' || fieldKey === 'OR' || fieldKey === 'NOT') {
      throw new Error(`Fields cannot be named ${fieldKey} but there is a field named ${fieldKey} on ${list.listKey}`);
    }
  }
}

function assertNoConflictingExtraOutputFields(list) {
  const fieldKeys = new Set(Object.keys(list.fields));
  const alreadyFoundFields = {};

  for (const [fieldKey, field] of Object.entries(list.fields)) {
    if (field.extraOutputFields) {
      for (const outputTypeFieldName of Object.keys(field.extraOutputFields)) {
        // note that this and the case handled below are fundamentally the same thing but i want different errors for each of them
        if (fieldKeys.has(outputTypeFieldName)) {
          throw new Error(`The field ${fieldKey} on the ${list.listKey} list defines an extra GraphQL output field named ${outputTypeFieldName} which conflicts with the Keystone field type named ${outputTypeFieldName} on the same list`);
        }

        const alreadyFoundField = alreadyFoundFields[outputTypeFieldName];

        if (alreadyFoundField !== undefined) {
          throw new Error(`The field ${fieldKey} on the ${list.listKey} list defines an extra GraphQL output field named ${outputTypeFieldName} which conflicts with the Keystone field type named ${alreadyFoundField} which also defines an extra GraphQL output field named ${outputTypeFieldName}`);
        }

        alreadyFoundFields[outputTypeFieldName] = fieldKey;
      }
    }
  }
}

function assertIdFieldGraphQLTypesCorrect(list) {
  var _idField$input;

  const idField = list.fields.id;

  if (((_idField$input = idField.input) === null || _idField$input === void 0 ? void 0 : _idField$input.uniqueWhere) === undefined) {
    throw new Error(`The idField on a list must define a uniqueWhere GraphQL input with the ID GraphQL scalar type but the idField for ${list.listKey} does not define one`);
  }

  if (idField.input.uniqueWhere.arg.type !== apiWithoutContext.ID) {
    throw new Error(`The idField on a list must define a uniqueWhere GraphQL input with the ID GraphQL scalar type but the idField for ${list.listKey} defines the type ${idField.input.uniqueWhere.arg.type.graphQLType.toString()}`);
  } // we may want to loosen these constraints in the future


  if (idField.input.create !== undefined) {
    throw new Error(`The idField on a list must not define a create GraphQL input but the idField for ${list.listKey} does define one`);
  }

  if (idField.input.update !== undefined) {
    throw new Error(`The idField on a list must not define an update GraphQL input but the idField for ${list.listKey} does define one`);
  }

  if (idField.graphql.isEnabled.read === false) {
    throw new Error(`The idField on a list must not have graphql.isEnabled.read be set to false but ${list.listKey} does`);
  }

  if (idField.output.type.kind !== 'non-null' || idField.output.type.of !== apiWithoutContext.ID) {
    throw new Error(`The idField on a list must define a GraphQL output field with a non-nullable ID GraphQL scalar type but the idField for ${list.listKey} defines the type ${idField.output.type.graphQLType.toString()}`);
  }
}

function initialiseLists(listsConfig, provider) {
  const listInfos = {};
  const isEnabled = {};

  for (const [listKey, listConfig] of Object.entries(listsConfig)) {
    var _listConfig$graphql;

    const omit = (_listConfig$graphql = listConfig.graphql) === null || _listConfig$graphql === void 0 ? void 0 : _listConfig$graphql.omit;
    const {
      defaultIsFilterable,
      defaultIsOrderable
    } = listConfig;

    if (omit === true) {
      isEnabled[listKey] = {
        type: false,
        query: false,
        create: false,
        update: false,
        delete: false,
        filter: false,
        orderBy: false
      };
    } else if (omit === undefined) {
      isEnabled[listKey] = {
        type: true,
        query: true,
        create: true,
        update: true,
        delete: true,
        filter: !!defaultIsFilterable,
        orderBy: !!defaultIsOrderable
      };
    } else {
      isEnabled[listKey] = {
        type: true,
        query: !omit.includes('query'),
        create: !omit.includes('create'),
        update: !omit.includes('update'),
        delete: !omit.includes('delete'),
        filter: !!defaultIsFilterable,
        orderBy: !!defaultIsOrderable
      };
    }
  }

  for (const [listKey, listConfig] of Object.entries(listsConfig)) {
    const names = core.getGqlNames({
      listKey,
      pluralGraphQLName: getNamesFromList(listKey, listConfig).pluralGraphQLName
    });
    let output = apiWithContext.object()({
      name: names.outputTypeName,
      fields: () => {
        const {
          fields
        } = lists[listKey];
        return _objectSpread({}, Object.fromEntries(Object.entries(fields).flatMap(([fieldPath, field]) => {
          if (!field.output || !field.graphql.isEnabled.read || field.dbField.kind === 'relation' && !isEnabled[field.dbField.list].query) {
            return [];
          }

          return [[fieldPath, field.output], ...Object.entries(field.extraOutputFields || {})].map(([outputTypeFieldName, outputField]) => {
            var _field$graphql;

            return [outputTypeFieldName, outputTypeField(outputField, field.dbField, (_field$graphql = field.graphql) === null || _field$graphql === void 0 ? void 0 : _field$graphql.cacheHint, field.access.read, listKey, fieldPath, lists)];
          });
        })));
      }
    });
    const uniqueWhere = apiWithoutContext.inputObject({
      name: names.whereUniqueInputName,
      fields: () => {
        const {
          fields
        } = lists[listKey];
        return Object.fromEntries(Object.entries(fields).flatMap(([key, field]) => {
          var _field$input, _field$input$uniqueWh;

          if (!((_field$input = field.input) !== null && _field$input !== void 0 && (_field$input$uniqueWh = _field$input.uniqueWhere) !== null && _field$input$uniqueWh !== void 0 && _field$input$uniqueWh.arg) || !field.graphql.isEnabled.read || !field.graphql.isEnabled.filter) {
            return [];
          }

          return [[key, field.input.uniqueWhere.arg]];
        }));
      }
    });
    const where = apiWithoutContext.inputObject({
      name: names.whereInputName,
      fields: () => {
        const {
          fields
        } = lists[listKey];
        return Object.assign({
          AND: apiWithoutContext.arg({
            type: apiWithoutContext.list(apiWithoutContext.nonNull(where))
          }),
          OR: apiWithoutContext.arg({
            type: apiWithoutContext.list(apiWithoutContext.nonNull(where))
          }),
          NOT: apiWithoutContext.arg({
            type: apiWithoutContext.list(apiWithoutContext.nonNull(where))
          })
        }, ...Object.entries(fields).map(([fieldKey, field]) => {
          var _field$input2, _field$input2$where, _field$input3, _field$input3$where;

          return ((_field$input2 = field.input) === null || _field$input2 === void 0 ? void 0 : (_field$input2$where = _field$input2.where) === null || _field$input2$where === void 0 ? void 0 : _field$input2$where.arg) && field.graphql.isEnabled.read && field.graphql.isEnabled.filter && {
            [fieldKey]: (_field$input3 = field.input) === null || _field$input3 === void 0 ? void 0 : (_field$input3$where = _field$input3.where) === null || _field$input3$where === void 0 ? void 0 : _field$input3$where.arg
          };
        }));
      }
    });
    const create = apiWithoutContext.inputObject({
      name: names.createInputName,
      fields: () => {
        const {
          fields
        } = lists[listKey];
        return Object.fromEntries(Object.entries(fields).flatMap(([key, field]) => {
          var _field$input4, _field$input4$create;

          if (!((_field$input4 = field.input) !== null && _field$input4 !== void 0 && (_field$input4$create = _field$input4.create) !== null && _field$input4$create !== void 0 && _field$input4$create.arg) || !field.graphql.isEnabled.create) return [];
          return [[key, field.input.create.arg]];
        }));
      }
    });
    const update = apiWithoutContext.inputObject({
      name: names.updateInputName,
      fields: () => {
        const {
          fields
        } = lists[listKey];
        return Object.fromEntries(Object.entries(fields).flatMap(([key, field]) => {
          var _field$input5, _field$input5$update;

          if (!((_field$input5 = field.input) !== null && _field$input5 !== void 0 && (_field$input5$update = _field$input5.update) !== null && _field$input5$update !== void 0 && _field$input5$update.arg) || !field.graphql.isEnabled.update) return [];
          return [[key, field.input.update.arg]];
        }));
      }
    });
    const orderBy = apiWithoutContext.inputObject({
      name: names.listOrderName,
      fields: () => {
        const {
          fields
        } = lists[listKey];
        return Object.fromEntries(Object.entries(fields).flatMap(([key, field]) => {
          var _field$input6, _field$input6$orderBy;

          if (!((_field$input6 = field.input) !== null && _field$input6 !== void 0 && (_field$input6$orderBy = _field$input6.orderBy) !== null && _field$input6$orderBy !== void 0 && _field$input6$orderBy.arg) || !field.graphql.isEnabled.read || !field.graphql.isEnabled.orderBy) {
            return [];
          }

          return [[key, field.input.orderBy.arg]];
        }));
      }
    });
    const findManyArgs = {
      where: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(where),
        defaultValue: {}
      }),
      orderBy: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(apiWithoutContext.list(apiWithoutContext.nonNull(orderBy))),
        defaultValue: []
      }),
      // TODO: non-nullable when max results is specified in the list with the default of max results
      take: apiWithoutContext.arg({
        type: apiWithoutContext.Int
      }),
      skip: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(apiWithoutContext.Int),
        defaultValue: 0
      })
    };
    const _isEnabled = isEnabled[listKey];
    let relateToManyForCreate, relateToManyForUpdate, relateToOneForCreate, relateToOneForUpdate;

    if (_isEnabled.type) {
      relateToManyForCreate = apiWithoutContext.inputObject({
        name: names.relateToManyForCreateInputName,
        fields: () => {
          return _objectSpread(_objectSpread({}, _isEnabled.create && {
            create: apiWithoutContext.arg({
              type: apiWithoutContext.list(apiWithoutContext.nonNull(create))
            })
          }), {}, {
            connect: apiWithoutContext.arg({
              type: apiWithoutContext.list(apiWithoutContext.nonNull(uniqueWhere))
            })
          });
        }
      });
      relateToManyForUpdate = apiWithoutContext.inputObject({
        name: names.relateToManyForUpdateInputName,
        fields: () => {
          return _objectSpread(_objectSpread({
            // The order of these fields reflects the order in which they are applied
            // in the mutation.
            disconnect: apiWithoutContext.arg({
              type: apiWithoutContext.list(apiWithoutContext.nonNull(uniqueWhere))
            }),
            set: apiWithoutContext.arg({
              type: apiWithoutContext.list(apiWithoutContext.nonNull(uniqueWhere))
            })
          }, _isEnabled.create && {
            create: apiWithoutContext.arg({
              type: apiWithoutContext.list(apiWithoutContext.nonNull(create))
            })
          }), {}, {
            connect: apiWithoutContext.arg({
              type: apiWithoutContext.list(apiWithoutContext.nonNull(uniqueWhere))
            })
          });
        }
      });
      relateToOneForCreate = apiWithoutContext.inputObject({
        name: names.relateToOneForCreateInputName,
        fields: () => {
          return _objectSpread(_objectSpread({}, _isEnabled.create && {
            create: apiWithoutContext.arg({
              type: create
            })
          }), {}, {
            connect: apiWithoutContext.arg({
              type: uniqueWhere
            })
          });
        }
      });
      relateToOneForUpdate = apiWithoutContext.inputObject({
        name: names.relateToOneForUpdateInputName,
        fields: () => {
          return _objectSpread(_objectSpread({}, _isEnabled.create && {
            create: apiWithoutContext.arg({
              type: create
            })
          }), {}, {
            connect: apiWithoutContext.arg({
              type: uniqueWhere
            }),
            disconnect: apiWithoutContext.arg({
              type: apiWithoutContext.Boolean
            })
          });
        }
      });
    }

    listInfos[listKey] = {
      types: {
        output,
        uniqueWhere,
        where,
        create,
        orderBy,
        update,
        findManyArgs,
        relateTo: {
          many: {
            where: apiWithoutContext.inputObject({
              name: `${listKey}ManyRelationFilter`,
              fields: {
                every: apiWithoutContext.arg({
                  type: where
                }),
                some: apiWithoutContext.arg({
                  type: where
                }),
                none: apiWithoutContext.arg({
                  type: where
                })
              }
            }),
            create: relateToManyForCreate,
            update: relateToManyForUpdate
          },
          one: {
            create: relateToOneForCreate,
            update: relateToOneForUpdate
          }
        }
      }
    };
  }

  const listsWithInitialisedFields = Object.fromEntries(Object.entries(listsConfig).map(([listKey, list]) => [listKey, _objectSpread(_objectSpread({
    fields: Object.fromEntries(Object.entries(list.fields).map(([fieldKey, fieldFunc]) => {
      var _f$graphql, _f$isFilterable, _f$isOrderable;

      if (typeof fieldFunc !== 'function') {
        throw new Error(`The field at ${listKey}.${fieldKey} does not provide a function`);
      }

      let f = fieldFunc({
        fieldKey,
        listKey,
        lists: listInfos,
        provider
      });
      const omit = (_f$graphql = f.graphql) === null || _f$graphql === void 0 ? void 0 : _f$graphql.omit;
      const read = omit !== true && !(omit !== null && omit !== void 0 && omit.includes('read'));
      const _isEnabled = {
        read,
        update: omit !== true && !(omit !== null && omit !== void 0 && omit.includes('update')),
        create: omit !== true && !(omit !== null && omit !== void 0 && omit.includes('create')),
        // Filter and orderBy can be defaulted at the list level, otherwise they
        // default to `false` if no value was set at the list level.
        filter: read && ((_f$isFilterable = f.isFilterable) !== null && _f$isFilterable !== void 0 ? _f$isFilterable : isEnabled[listKey].filter),
        orderBy: read && ((_f$isOrderable = f.isOrderable) !== null && _f$isOrderable !== void 0 ? _f$isOrderable : isEnabled[listKey].orderBy)
      };

      const field = _objectSpread(_objectSpread({}, f), {}, {
        graphql: _objectSpread(_objectSpread({}, f.graphql), {}, {
          isEnabled: _isEnabled
        }),
        input: _objectSpread({}, f.input)
      });

      return [fieldKey, field];
    }))
  }, getNamesFromList(listKey, list)), {}, {
    hooks: list.hooks,
    access: list.access
  })]));
  const listsWithResolvedDBFields = resolveRelationships(listsWithInitialisedFields);
  const listsWithInitialisedFieldsAndResolvedDbFields = Object.fromEntries(Object.entries(listsWithInitialisedFields).map(([listKey, list]) => {
    let hasAnEnabledCreateField = false;
    let hasAnEnabledUpdateField = false;
    const fields = Object.fromEntries(Object.entries(list.fields).map(([fieldKey, field]) => {
      var _field$input7, _field$input7$create, _field$input8, _field$hooks;

      if ((_field$input7 = field.input) !== null && _field$input7 !== void 0 && (_field$input7$create = _field$input7.create) !== null && _field$input7$create !== void 0 && _field$input7$create.arg && field.graphql.isEnabled.create) {
        hasAnEnabledCreateField = true;
      }

      if ((_field$input8 = field.input) !== null && _field$input8 !== void 0 && _field$input8.update && field.graphql.isEnabled.update) {
        hasAnEnabledUpdateField = true;
      }

      const access = parseFieldAccessControl(field.access);
      const dbField = listsWithResolvedDBFields[listKey].resolvedDbFields[fieldKey];
      return [fieldKey, _objectSpread(_objectSpread({}, field), {}, {
        access,
        dbField,
        hooks: (_field$hooks = field.hooks) !== null && _field$hooks !== void 0 ? _field$hooks : {},
        graphql: field.graphql
      })];
    }));
    const access = parseListAccessControl(list.access); // You can't have a graphQL type with no fields, so
    // if they're all disabled, we have to disable the whole operation.

    if (!hasAnEnabledCreateField) {
      isEnabled[listKey].create = false;
    }

    if (!hasAnEnabledUpdateField) {
      isEnabled[listKey].update = false;
    }

    return [listKey, _objectSpread(_objectSpread({}, list), {}, {
      access,
      fields,
      graphql: {
        isEnabled: isEnabled[listKey]
      }
    })];
  }));

  for (const [listKey, {
    fields
  }] of Object.entries(listsWithInitialisedFieldsAndResolvedDbFields)) {
    assertFieldsValid({
      listKey,
      fields
    });
  }

  const lists = {};

  for (const [listKey, list] of Object.entries(listsWithInitialisedFieldsAndResolvedDbFields)) {
    var _listsConfig$listKey$2, _listsConfig$listKey$3, _listsConfig$listKey$4;

    lists[listKey] = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, list), listInfos[listKey]), listsWithResolvedDBFields[listKey]), {}, {
      hooks: list.hooks || {},
      cacheHint: (() => {
        var _listsConfig$listKey$;

        const cacheHint = (_listsConfig$listKey$ = listsConfig[listKey].graphql) === null || _listsConfig$listKey$ === void 0 ? void 0 : _listsConfig$listKey$.cacheHint;

        if (cacheHint === undefined) {
          return undefined;
        }

        return typeof cacheHint === 'function' ? cacheHint : () => cacheHint;
      })(),
      maxResults: (_listsConfig$listKey$2 = (_listsConfig$listKey$3 = listsConfig[listKey].graphql) === null || _listsConfig$listKey$3 === void 0 ? void 0 : (_listsConfig$listKey$4 = _listsConfig$listKey$3.queryLimits) === null || _listsConfig$listKey$4 === void 0 ? void 0 : _listsConfig$listKey$4.maxResults) !== null && _listsConfig$listKey$2 !== void 0 ? _listsConfig$listKey$2 : Infinity,
      listKey,
      lists
    });
  }

  return lists;
}

function getDBProvider(db) {
  if (db.adapter === 'prisma_postgresql' || db.provider === 'postgresql') {
    return 'postgresql';
  } else if (db.adapter === 'prisma_sqlite' || db.provider === 'sqlite') {
    return 'sqlite';
  } else {
    throw new Error('Invalid db configuration. Please specify db.provider as either "sqlite" or "postgresql"');
  }
}

function getInternalGraphQLSchema(config, provider) {
  const transformedConfig = _objectSpread(_objectSpread({}, config), {}, {
    lists: Object.fromEntries(Object.entries(config.lists).map(([listKey, list]) => {
      return [listKey, _objectSpread(_objectSpread({}, list), {}, {
        access: {
          operation: {},
          item: {},
          filter: {}
        },
        graphql: _objectSpread(_objectSpread({}, list.graphql || {}), {}, {
          omit: []
        }),
        fields: Object.fromEntries(Object.entries(list.fields).map(([fieldKey, field]) => {
          return [fieldKey, data => {
            const f = field(data);
            return _objectSpread(_objectSpread({}, f), {}, {
              access: () => true,
              isFilterable: true,
              isOrderable: true,
              graphql: _objectSpread(_objectSpread({}, f.graphql || {}), {}, {
                omit: []
              })
            });
          }];
        }))
      })];
    }))
  });

  const lists = initialiseLists(transformedConfig.lists, provider);
  const adminMeta = createAdminMeta(transformedConfig, lists);
  return createGraphQLSchema(transformedConfig, lists, adminMeta);
}

function createSystem(config) {
  const provider = getDBProvider(config.db);
  const lists = initialiseLists(config.lists, provider);
  const adminMeta = createAdminMeta(config, lists);
  const graphQLSchema = createGraphQLSchema(config, lists, adminMeta);
  const internalGraphQLSchema = getInternalGraphQLSchema(config, provider);
  return {
    graphQLSchema,
    adminMeta,
    getKeystone: PrismaClient => {
      const prismaClient = new PrismaClient({
        log: config.db.enableLogging && ['query'],
        datasources: {
          [provider]: {
            url: config.db.url
          }
        }
      });
      prismaClient.$on('beforeExit', async () => {
        // Prisma is failing to properly clean up its child processes
        // https://github.com/keystonejs/keystone/issues/5477
        // We explicitly send a SIGINT signal to the prisma child process on exit
        // to ensure that the process is cleaned up appropriately.
        prismaClient._engine.child.kill('SIGINT');
      });
      const createContext = makeCreateContext({
        graphQLSchema,
        internalSchema: internalGraphQLSchema,
        config,
        prismaClient,
        gqlNamesByList: Object.fromEntries(Object.entries(lists).map(([listKey, list]) => [listKey, core.getGqlNames(list)])),
        lists
      });
      return {
        async connect() {
          var _config$db$onConnect, _config$db;

          await prismaClient.$connect();
          const context = createContext({
            skipAccessControl: true,
            schemaName: 'internal'
          });
          await ((_config$db$onConnect = (_config$db = config.db).onConnect) === null || _config$db$onConnect === void 0 ? void 0 : _config$db$onConnect.call(_config$db, context));
        },

        async disconnect() {
          await prismaClient.$disconnect();
        },

        createContext
      };
    }
  };
}

exports.createSystem = createSystem;
exports.getDBFieldKeyForFieldOnMultiField = getDBFieldKeyForFieldOnMultiField;
exports.getDBProvider = getDBProvider;
exports.initialiseLists = initialiseLists;
exports.serializePathForImport = serializePathForImport;
exports.writeAdminFiles = writeAdminFiles;
