{
  "version": 3,
  "sources": ["../../src/commands/MigrateDev.ts"],
  "sourcesContent": ["import {\n  arg,\n  Command,\n  format,\n  HelpError,\n  isError,\n  getSchemaPath,\n  getCommandWithExecutor,\n  isCi,\n  getConfig,\n  getDMMF,\n} from '@prisma/sdk'\nimport Debug from '@prisma/debug'\nimport chalk from 'chalk'\nimport prompt from 'prompts'\nimport fs from 'fs'\nimport path from 'path'\nimport { Migrate } from '../Migrate'\nimport {\n  ensureDatabaseExists,\n  getDbInfo,\n  DbType,\n} from '../utils/ensureDatabaseExists'\nimport {\n  ExperimentalFlagWithNewMigrateError,\n  EarlyAccessFeatureFlagWithNewMigrateError,\n} from '../utils/flagErrors'\nimport {\n  NoSchemaFoundError,\n  MigrateDevEnvNonInteractiveError,\n} from '../utils/errors'\nimport { printMigrationId } from '../utils/printMigrationId'\nimport { printFilesFromMigrationIds } from '../utils/printFiles'\nimport { handleUnexecutableSteps } from '../utils/handleEvaluateDataloss'\nimport { getMigrationName } from '../utils/promptForMigrationName'\nimport { throwUpgradeErrorIfOldMigrate } from '../utils/detectOldMigrate'\nimport { printDatasource } from '../utils/printDatasource'\nimport { tryToRunSeed, detectSeedFiles } from '../utils/seed'\nimport { EngineResults } from '../types'\n\nconst debug = Debug('prisma:migrate:dev')\n\nexport class MigrateDev implements Command {\n  public static new(): MigrateDev {\n    return new MigrateDev()\n  }\n\n  private static help = format(`\n${\n  process.platform === 'win32' ? '' : chalk.bold('\uD83C\uDFCB\uFE0F  ')\n}Create a migration from changes in Prisma schema, apply it to the database, trigger generators (e.g. Prisma Client)\n \n${chalk.bold('Usage')}\n\n  ${chalk.dim('$')} prisma migrate dev [options]\n\n${chalk.bold('Options')}\n\n       -h, --help   Display this help message\n         --schema   Custom path to your Prisma schema\n       -n, --name   Name the migration\n    --create-only   Create a new migration but do not apply it\n                    The migration will be empty if there are no changes in Prisma schema\n  --skip-generate   Skip triggering generators (e.g. Prisma Client)\n      --skip-seed   Skip triggering seed\n\n${chalk.bold('Examples')}\n\n  Create a migration from changes in Prisma schema, apply it to the database, trigger generators (e.g. Prisma Client)\n  ${chalk.dim('$')} prisma migrate dev\n\n  Specify a schema\n  ${chalk.dim('$')} prisma migrate dev --schema=./schema.prisma\n\n  Create a migration without applying it\n  ${chalk.dim('$')} prisma migrate dev --create-only\n  `)\n\n  public async parse(argv: string[]): Promise<string | Error> {\n    const args = arg(argv, {\n      '--help': Boolean,\n      '-h': '--help',\n      '--name': String,\n      '-n': '--name',\n      // '--force': Boolean,\n      // '-f': '--force',\n      '--create-only': Boolean,\n      '--schema': String,\n      '--skip-generate': Boolean,\n      '--skip-seed': Boolean,\n      '--experimental': Boolean,\n      '--early-access-feature': Boolean,\n      '--telemetry-information': String,\n    })\n\n    if (isError(args)) {\n      return this.help(args.message)\n    }\n\n    if (args['--help']) {\n      return this.help()\n    }\n\n    if (args['--experimental']) {\n      throw new ExperimentalFlagWithNewMigrateError()\n    }\n\n    if (args['--early-access-feature']) {\n      throw new EarlyAccessFeatureFlagWithNewMigrateError()\n    }\n\n    const schemaPath = await getSchemaPath(args['--schema'])\n\n    if (!schemaPath) {\n      throw new NoSchemaFoundError()\n    }\n\n    console.info(\n      chalk.dim(\n        `Prisma schema loaded from ${path.relative(process.cwd(), schemaPath)}`,\n      ),\n    )\n\n    await printDatasource(schemaPath)\n\n    console.info() // empty line\n\n    throwUpgradeErrorIfOldMigrate(schemaPath)\n\n    // Validate schema (same as prisma validate)\n    const schema = fs.readFileSync(schemaPath, 'utf-8')\n    await getDMMF({\n      datamodel: schema,\n    })\n    await getConfig({\n      datamodel: schema,\n    })\n\n    // Automatically create the database if it doesn't exist\n    const wasDbCreated = await ensureDatabaseExists('create', true, schemaPath)\n    if (wasDbCreated) {\n      console.info(wasDbCreated)\n    }\n\n    const migrate = new Migrate(schemaPath)\n\n    let devDiagnostic: EngineResults.DevDiagnosticOutput\n    try {\n      devDiagnostic = await migrate.devDiagnostic()\n      debug({ devDiagnostic: JSON.stringify(devDiagnostic, null, 2) })\n    } catch (e) {\n      migrate.stop()\n      throw e\n    }\n\n    const migrationIdsApplied: string[] = []\n\n    if (devDiagnostic.action.tag === 'reset') {\n      if (!args['--force']) {\n        // We use prompts.inject() for testing in our CI\n        if (isCi() && Boolean((prompt as any)._injected?.length) === false) {\n          migrate.stop()\n          throw new MigrateDevEnvNonInteractiveError()\n        }\n\n        const dbInfo = await getDbInfo(schemaPath)\n        const confirmedReset = await this.confirmReset(\n          dbInfo,\n          devDiagnostic.action.reason,\n        )\n        console.info() // empty line\n\n        if (!confirmedReset) {\n          console.info('Reset cancelled.')\n          migrate.stop()\n          process.exit(0)\n          // For snapshot test, because exit() is mocked\n          return ``\n        }\n      }\n\n      try {\n        // Do the reset\n        await migrate.reset()\n      } catch (e) {\n        migrate.stop()\n        throw e\n      }\n    }\n\n    try {\n      const { appliedMigrationNames } = await migrate.applyMigrations()\n      migrationIdsApplied.push(...appliedMigrationNames)\n\n      // Inform user about applied migrations now\n      if (appliedMigrationNames.length > 0) {\n        console.info(\n          `The following migration(s) have been applied:\\n\\n${chalk(\n            printFilesFromMigrationIds('migrations', appliedMigrationNames, {\n              'migration.sql': '',\n            }),\n          )}`,\n        )\n      }\n    } catch (e) {\n      migrate.stop()\n      throw e\n    }\n\n    // If database was reset we want to run the seed if not skipped\n    if (\n      devDiagnostic.action.tag === 'reset' &&\n      !process.env.PRISMA_MIGRATE_SKIP_SEED &&\n      !args['--skip-seed']\n    ) {\n      // Run seed if 1 or more seed files are present\n      // And catch the error to continue execution\n      try {\n        const detected = detectSeedFiles(schemaPath)\n        if (detected.numberOfSeedFiles > 0) {\n          console.info() // empty line\n          await tryToRunSeed(schemaPath)\n        }\n      } catch (e) {\n        console.error(e)\n      }\n    }\n\n    let evaluateDataLossResult: EngineResults.EvaluateDataLossOutput\n    try {\n      evaluateDataLossResult = await migrate.evaluateDataLoss()\n      debug({ evaluateDataLossResult })\n    } catch (e) {\n      migrate.stop()\n      throw e\n    }\n\n    // display unexecutableSteps\n    // throws error if not create-only\n    const unexecutableStepsError = handleUnexecutableSteps(\n      evaluateDataLossResult.unexecutableSteps,\n      args['--create-only'],\n    )\n    if (unexecutableStepsError) {\n      migrate.stop()\n      throw new Error(unexecutableStepsError)\n    }\n\n    // log warnings and prompt user to continue if needed\n    if (\n      evaluateDataLossResult.warnings &&\n      evaluateDataLossResult.warnings.length > 0\n    ) {\n      console.log(chalk.bold(`\\n\u26A0\uFE0F  Warnings for the current datasource:\\n`))\n      for (const warning of evaluateDataLossResult.warnings) {\n        console.log(chalk(`  \u2022 ${warning.message}`))\n      }\n      console.info() // empty line\n\n      if (!args['--force']) {\n        // We use prompts.inject() for testing in our CI\n        if (isCi() && Boolean((prompt as any)._injected?.length) === false) {\n          migrate.stop()\n          throw new MigrateDevEnvNonInteractiveError()\n        }\n\n        const message = args['--create-only']\n          ? 'Are you sure you want create this migration?'\n          : 'Are you sure you want create and apply this migration?'\n        const confirmation = await prompt({\n          type: 'confirm',\n          name: 'value',\n          message,\n        })\n\n        if (!confirmation.value) {\n          migrate.stop()\n          return `Migration cancelled.`\n        }\n      }\n    }\n\n    let migrationName: undefined | string = undefined\n    if (evaluateDataLossResult.migrationSteps > 0 || args['--create-only']) {\n      const getMigrationNameResult = await getMigrationName(args['--name'])\n\n      if (getMigrationNameResult.userCancelled) {\n        migrate.stop()\n        return getMigrationNameResult.userCancelled\n      } else {\n        migrationName = getMigrationNameResult.name\n      }\n    }\n\n    let migrationIds: string[]\n    try {\n      const createMigrationResult = await migrate.createMigration({\n        migrationsDirectoryPath: migrate.migrationsDirectoryPath,\n        migrationName: migrationName || '',\n        draft: args['--create-only'] ? true : false,\n        prismaSchema: migrate.getDatamodel(),\n      })\n      debug({ createMigrationResult })\n\n      if (args['--create-only']) {\n        migrate.stop()\n\n        return `Prisma Migrate created the following migration without applying it ${printMigrationId(\n          createMigrationResult.generatedMigrationName!,\n        )}\\n\\nYou can now edit it and apply it by running ${chalk.greenBright(\n          getCommandWithExecutor('prisma migrate dev'),\n        )}.`\n      }\n\n      const { appliedMigrationNames } = await migrate.applyMigrations()\n      migrationIds = appliedMigrationNames\n    } finally {\n      migrate.stop()\n    }\n\n    // For display only, empty line\n    migrationIdsApplied.length > 0 && console.info()\n\n    if (migrationIds.length === 0) {\n      if (migrationIdsApplied.length > 0) {\n        console.info(\n          `${chalk.green('Your database is now in sync with your schema.')}`,\n        )\n      } else {\n        console.info(\n          `Already in sync, no schema change or pending migration was found.`,\n        )\n      }\n    } else {\n      console.info(\n        `The following migration(s) have been created and applied from new schema changes:\\n\\n${chalk(\n          printFilesFromMigrationIds('migrations', migrationIds, {\n            'migration.sql': '',\n          }),\n        )}\n\n${chalk.green('Your database is now in sync with your schema.')}`,\n      )\n    }\n\n    // Run if not skipped\n    if (!process.env.PRISMA_MIGRATE_SKIP_GENERATE && !args['--skip-generate']) {\n      await migrate.tryToRunGenerate()\n      console.info() // empty line\n    }\n\n    return ''\n  }\n\n  private async confirmReset(\n    {\n      schemaWord,\n      dbType,\n      dbName,\n      dbLocation,\n    }: {\n      schemaWord?: 'database'\n      dbType?: DbType\n      dbName?: string\n      dbLocation?: string\n    },\n    reason: string,\n  ): Promise<boolean> {\n    const mssqlMessage = `${reason}\n\nWe need to reset the database.\nDo you want to continue? ${chalk.red('All data will be lost')}.`\n\n    const message = `${reason}\n\nWe need to reset the ${dbType} ${schemaWord} \"${dbName}\" at \"${dbLocation}\".\nDo you want to continue? ${chalk.red('All data will be lost')}.`\n\n    const confirmation = await prompt({\n      type: 'confirm',\n      name: 'value',\n      message: dbType === 'SQL Server' ? mssqlMessage : message,\n    })\n\n    return confirmation.value\n  }\n\n  public help(error?: string): string | HelpError {\n    if (error) {\n      return new HelpError(\n        `\\n${chalk.bold.red(`!`)} ${error}\\n${MigrateDev.help}`,\n      )\n    }\n    return MigrateDev.help\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
