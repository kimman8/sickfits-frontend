import Path__default from 'path';
import { parse, GraphQLScalarType, printSchema } from 'graphql';
import * as fs from 'fs-extra';
import { formatSchema, getGenerator } from '@prisma/sdk';
import prettier, { format } from 'prettier';
import { s as shouldPrompt, c as confirmPrompt, E as ExitError } from '../../dist/utils-b84e12de.esm.js';
import { g as getGqlNames } from '../../dist/core-3f0f7b15.esm.js';
import '../../dist/sqlite-943cbaa7.esm.js';
import '@babel/runtime/helpers/objectWithoutProperties';
import '@babel/runtime/helpers/objectSpread2';
import { g as getDBFieldKeyForFieldOnMultiField, i as initialiseLists, a as getDBProvider } from '../../dist/createSystem-0871d001.esm.js';
import 'prompts';
import '@babel/runtime/helpers/defineProperty';
import 'decimal.js';
import '@graphql-ts/schema/api-without-context';
import '@graphql-ts/schema';
import 'graphql-type-json';
import 'graphql-upload/public/GraphQLUpload.js';
import '@graphql-ts/schema/api-with-context';
import 'fast-glob';
import 'resolve';
import '@emotion/hash';
import '../../dist/admin-meta-graphql-c4fe434c.esm.js';
import '@apollo/client';
import '../../session/dist/keystone.esm.js';
import 'cookie';
import '@hapi/iron';
import 'uid-safe';
import '@babel/runtime/helpers/classPrivateFieldInitSpec';
import '@babel/runtime/helpers/classPrivateFieldGet';
import '@babel/runtime/helpers/classPrivateFieldSet';
import 'p-limit';
import 'pluralize';
import 'apollo-server-errors';
import 'uuid';
import 'image-type';
import 'image-size';
import '../../fields/types/image/utils/dist/keystone.esm.js';
import 'node-fetch';
import 'form-data';
import 'crypto';
import 'stream';
import 'filenamify';
import '@sindresorhus/slugify';
import '../../fields/types/file/utils/dist/keystone.esm.js';

let printEnumTypeDefinition = node => {
  return `export type ${node.name.value} =\n${node.values.map(x => `  | ${JSON.stringify(x.name.value)}`).join('\n')};`;
};

function printInputTypesFromSchema(schema, schemaObj, scalars) {
  let ast = parse(schema);

  let printTypeNodeWithoutNullable = node => {
    if (node.kind === 'ListType') {
      return `ReadonlyArray<${printTypeNode(node.type)}> | ${printTypeNode(node.type)}`;
    }

    let name = node.name.value;

    if (schemaObj.getType(name) instanceof GraphQLScalarType) {
      if (scalars[name] === undefined) {
        return 'any';
      }

      return `Scalars[${JSON.stringify(name)}]`;
    }

    return name;
  };

  let printTypeNode = node => {
    if (node.kind === 'NonNullType') {
      return printTypeNodeWithoutNullable(node.type);
    }

    return `${printTypeNodeWithoutNullable(node)} | null`;
  };

  let printInputObjectTypeDefinition = node => {
    var _node$fields;

    let str = `export type ${node.name.value} = {\n`;
    (_node$fields = node.fields) === null || _node$fields === void 0 ? void 0 : _node$fields.forEach(node => {
      str += `  readonly ${node.name.value}${node.type.kind === 'NonNullType' && !node.defaultValue ? '' : '?'}: ${printTypeNode(node.type)};\n`;
    });
    str += '};';
    return str;
  };

  let typeString = 'type Scalars = {\n';

  for (let scalar in scalars) {
    typeString += `  readonly ${scalar}: ${scalars[scalar]};\n`;
  }

  typeString += '};';

  for (const node of ast.definitions) {
    if (node.kind === 'InputObjectTypeDefinition') {
      typeString += '\n\n' + printInputObjectTypeDefinition(node);
    }

    if (node.kind === 'EnumTypeDefinition') {
      typeString += '\n\n' + printEnumTypeDefinition(node);
    }
  }

  return {
    printedTypes: typeString + '\n',
    ast,
    printTypeNode
  };
}

function printGeneratedTypes(printedSchema, graphQLSchema, lists) {
  let scalars = {
    ID: 'string',
    Boolean: 'boolean',
    String: 'string',
    Int: 'number',
    Float: 'number',
    JSON: 'import("@keystone-next/keystone/types").JSONValue'
  };
  let prelude = `import {
  KeystoneListsAPI as GenericKeystoneListsAPI,
  KeystoneDbAPI as GenericKeystoneDbAPI,
  KeystoneContext as GenericKeystoneContext,
} from '@keystone-next/keystone/types';
`;
  let {
    printedTypes,
    ast,
    printTypeNode
  } = printInputTypesFromSchema(printedSchema, graphQLSchema, scalars);
  printedTypes += '\n';
  let allListsStr = '\nexport type KeystoneListsTypeInfo = {';
  let queryTypeName = graphQLSchema.getQueryType().name;
  let queryNode = ast.definitions.find(node => {
    return node.kind === 'ObjectTypeDefinition' && node.name.value === queryTypeName;
  });

  if (!queryNode) {
    throw new Error('Query type on GraphQL schema not found when generating types');
  }

  let queryNodeFieldsByName = {};

  for (const field of queryNode.fields) {
    queryNodeFieldsByName[field.name.value] = field;
  }

  let printArgs = args => {
    let types = '{\n';

    for (const arg of args) {
      if (arg.name.value === 'search') continue;
      types += `  readonly ${arg.name.value}${arg.type.kind === 'NonNullType' && !arg.defaultValue ? '' : '?'}: ${printTypeNode(arg.type)};\n`;
    }

    return types + '}';
  };

  for (const [listKey, list] of Object.entries(lists)) {
    const gqlNames = getGqlNames(list);
    let listTypeInfoName = `${listKey}ListTypeInfo`;
    const listQuery = queryNodeFieldsByName[gqlNames.listQueryName];
    printedTypes += `
export type ${listTypeInfoName} = {
  key: ${JSON.stringify(listKey)};
  fields: ${Object.keys(list.fields).map(x => JSON.stringify(x)).join('|')}
  backing: import(".prisma/client").${listKey};
  inputs: {
    where: ${gqlNames.whereInputName};
    uniqueWhere: ${gqlNames.whereUniqueInputName};
    create: ${gqlNames.createInputName};
    update: ${gqlNames.updateInputName};
  };
  args: {
    listQuery: ${listQuery ? printArgs(listQuery.arguments) : 'import("@keystone-next/keystone/types").BaseGeneratedListTypes["args"]["listQuery"]'}
  };
};

export type ${listKey}ListFn = (
  listConfig: import('@keystone-next/keystone').ListConfig<${listTypeInfoName}, ${listTypeInfoName}['fields']>
) => import('@keystone-next/keystone').ListConfig<${listTypeInfoName}, ${listTypeInfoName}['fields']>;
`;
    allListsStr += `\n  readonly ${JSON.stringify(listKey)}: ${listTypeInfoName};`;
  }

  allListsStr += '\n};';
  const postlude = `
export type KeystoneListsAPI = GenericKeystoneListsAPI<KeystoneListsTypeInfo>;
export type KeystoneDbAPI = GenericKeystoneDbAPI<KeystoneListsTypeInfo>;

export type KeystoneContext = Omit<GenericKeystoneContext, 'db' | 'lists' | 'prisma'> & {
  db: { lists: KeystoneDbAPI };
  lists: KeystoneListsAPI;
  prisma: import('.prisma/client').PrismaClient;
};
`;
  return prettier.format(prelude + printedTypes + allListsStr + postlude, {
    parser: 'babel-ts',
    trailingComma: 'es5',
    singleQuote: true
  });
}

function areArraysEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
}

const modifiers = {
  required: '',
  optional: '?',
  many: '[]'
};

function printIndex(fieldPath, index) {
  return {
    none: '',
    unique: '@unique',
    index: `\n@@index([${fieldPath}])`
  }[index || 'none'];
}

function printNativeType(nativeType, datasourceName) {
  return nativeType === undefined ? '' : ` @${datasourceName}.${nativeType}`;
}

function printScalarDefaultValue(defaultValue) {
  if (defaultValue.kind === 'literal') {
    if (typeof defaultValue.value === 'string') {
      return JSON.stringify(defaultValue.value);
    }

    return defaultValue.value.toString();
  }

  if (defaultValue.kind === 'now' || defaultValue.kind === 'autoincrement' || defaultValue.kind === 'cuid' || defaultValue.kind === 'uuid') {
    return `${defaultValue.kind}()`;
  }

  if (defaultValue.kind === 'dbgenerated') {
    return `dbgenerated(${JSON.stringify(defaultValue.value)})`;
  }

  assertNever(defaultValue);
}

function assertNever(arg) {
  throw new Error(`expected to never be called but was called with ${arg}`);
}

function printField(fieldPath, field, datasourceName, lists) {
  if (field.kind === 'scalar') {
    const nativeType = printNativeType(field.nativeType, datasourceName);
    const index = printIndex(fieldPath, field.index);
    const defaultValue = field.default ? ` @default(${printScalarDefaultValue(field.default)})` : '';
    return `${fieldPath} ${field.scalar}${modifiers[field.mode]}${nativeType}${defaultValue}${index}`;
  }

  if (field.kind === 'enum') {
    const index = printIndex(fieldPath, field.index);
    const defaultValue = field.default ? ` @default(${field.default})` : '';
    return `${fieldPath} ${field.name}${modifiers[field.mode]}${defaultValue}${index}`;
  }

  if (field.kind === 'multi') {
    return Object.entries(field.fields).map(([subField, field]) => printField(getDBFieldKeyForFieldOnMultiField(fieldPath, subField), field, datasourceName, lists)).join('\n');
  }

  if (field.kind === 'relation') {
    if (field.mode === 'many') {
      return `${fieldPath} ${field.list}[] @relation("${field.relationName}")`;
    }

    if (field.foreignIdField === 'none') {
      return `${fieldPath} ${field.list}? @relation("${field.relationName}")`;
    }

    const relationIdFieldPath = `${fieldPath}Id`;
    const relationField = `${fieldPath} ${field.list}? @relation("${field.relationName}", fields: [${relationIdFieldPath}], references: [id])`;
    const foreignIdField = lists[field.list].resolvedDbFields.id;
    assertDbFieldIsValidForIdField(field.list, foreignIdField);
    const nativeType = printNativeType(foreignIdField.nativeType, datasourceName);
    const index = printIndex(relationIdFieldPath, field.foreignIdField === 'owned' ? 'index' : 'unique');
    const relationIdField = `${relationIdFieldPath} ${foreignIdField.scalar}? @map("${fieldPath}") ${nativeType}${index}`;
    return `${relationField}\n${relationIdField}`;
  } // TypeScript's control flow analysis doesn't understand that this will never happen without the assertNever
  // (this will still correctly validate if any case is unhandled though)


  return assertNever(field);
}

function collectEnums(lists) {
  const enums = {};

  for (const [listKey, {
    resolvedDbFields
  }] of Object.entries(lists)) {
    for (const [fieldPath, field] of Object.entries(resolvedDbFields)) {
      const fields = field.kind === 'multi' ? Object.entries(field.fields).map(([key, field]) => [field, `${listKey}.${fieldPath} (sub field ${key})`]) : [[field, `${listKey}.${fieldPath}`]];

      for (const [field, ref] of fields) {
        if (field.kind !== 'enum') continue;
        const alreadyExistingEnum = enums[field.name];

        if (alreadyExistingEnum === undefined) {
          enums[field.name] = {
            values: field.values,
            firstDefinedByRef: ref
          };
          continue;
        }

        if (!areArraysEqual(alreadyExistingEnum.values, field.values)) {
          throw new Error(`The fields ${alreadyExistingEnum.firstDefinedByRef} and ${ref} both specify Prisma schema enums` + `with the name ${field.name} but they have different values:\n` + `enum from ${alreadyExistingEnum.firstDefinedByRef}:\n${JSON.stringify(alreadyExistingEnum.values, null, 2)}\n` + `enum from ${ref}:\n${JSON.stringify(field.values, null, 2)}`);
        }
      }
    }
  }

  return Object.entries(enums).map(([enumName, {
    values
  }]) => `enum ${enumName} {\n${values.join('\n')}\n}`).join('\n');
}

function assertDbFieldIsValidForIdField(listKey, field) {
  if (field.kind !== 'scalar') {
    throw new Error(`id fields must be either a String or Int Prisma scalar but the id field for the ${listKey} list is not a scalar`);
  } // this may be loosened in the future


  if (field.scalar !== 'String' && field.scalar !== 'Int') {
    throw new Error(`id fields must be either String or Int Prisma scalars but the id field for the ${listKey} list is a ${field.scalar} scalar`);
  }

  if (field.mode !== 'required') {
    throw new Error(`id fields must be a singular required field but the id field for the ${listKey} list is ${field.mode === 'many' ? 'a many' : 'an optional'} field`);
  }

  if (field.index !== undefined) {
    throw new Error(`id fields must not specify indexes themselves but the id field for the ${listKey} list specifies an index`);
  } // this will likely be loosened in the future


  if (field.default === undefined) {
    throw new Error(`id fields must specify a Prisma/database level default value but the id field for the ${listKey} list does not`);
  }
}

function printPrismaSchema(lists, provider, clientDir) {
  let prismaSchema = `// This file is automatically generated by Keystone, do not modify it manually.
// Modify your Keystone config when you want to change this.

datasource ${provider} {
  url = env("DATABASE_URL")
  provider = "${provider}"
}

generator client {
  provider = "prisma-client-js"
  output = "${clientDir}"
}
\n`;

  for (const [listKey, {
    resolvedDbFields
  }] of Object.entries(lists)) {
    prismaSchema += `model ${listKey} {`;

    for (const [fieldPath, field] of Object.entries(resolvedDbFields)) {
      if (field.kind !== 'none') {
        prismaSchema += '\n' + printField(fieldPath, field, provider, lists);
      }

      if (fieldPath === 'id') {
        assertDbFieldIsValidForIdField(listKey, field);
        prismaSchema += ' @id';
      }
    }

    prismaSchema += `\n}\n`;
  }

  prismaSchema += `\n${collectEnums(lists)}\n`;
  return prismaSchema;
}

function getSchemaPaths(cwd) {
  return {
    prisma: Path__default.join(cwd, 'schema.prisma'),
    graphql: Path__default.join(cwd, 'schema.graphql')
  };
}
async function getCommittedArtifacts(graphQLSchema, config) {
  const lists = initialiseLists(config.lists, getDBProvider(config.db));
  const prismaSchema = printPrismaSchema(lists, getDBProvider(config.db), 'node_modules/.prisma/client');
  return {
    graphql: format('# This file is automatically generated by Keystone, do not modify it manually.\n' + '# Modify your Keystone config when you want to change this.\n\n' + printSchema(graphQLSchema), {
      parser: 'graphql'
    }),
    prisma: await formatSchema({
      schema: prismaSchema
    })
  };
}

async function readFileButReturnNothingIfDoesNotExist(filename) {
  try {
    return await fs.readFile(filename, 'utf8');
  } catch (err) {
    if (err.code === 'ENOENT') {
      return;
    }

    throw err;
  }
}

async function validateCommittedArtifacts(graphQLSchema, config, cwd) {
  const artifacts = await getCommittedArtifacts(graphQLSchema, config);
  const schemaPaths = getSchemaPaths(cwd);
  const [writtenGraphQLSchema, writtenPrismaSchema] = await Promise.all([readFileButReturnNothingIfDoesNotExist(schemaPaths.graphql), readFileButReturnNothingIfDoesNotExist(schemaPaths.prisma)]);

  const outOfDateSchemas = (() => {
    if (writtenGraphQLSchema !== artifacts.graphql && writtenPrismaSchema !== artifacts.prisma) {
      return 'both';
    }

    if (writtenGraphQLSchema !== artifacts.graphql) {
      return 'graphql';
    }

    if (writtenPrismaSchema !== artifacts.prisma) {
      return 'prisma';
    }
  })();

  if (outOfDateSchemas) {
    const message = {
      both: 'Your Prisma and GraphQL schemas are not up to date',
      graphql: 'Your GraphQL schema is not up to date',
      prisma: 'Your GraphQL schema is not up to date'
    }[outOfDateSchemas];
    console.log(message);
    const term = {
      both: 'Prisma and GraphQL schemas',
      prisma: 'Prisma schema',
      graphql: 'GraphQL schema'
    }[outOfDateSchemas];

    if (shouldPrompt && (await confirmPrompt(`Would you like to update your ${term}?`))) {
      await writeCommittedArtifacts(artifacts, cwd);
    } else {
      console.log(`Please run keystone-next postinstall --fix to update your ${term}`);
      throw new ExitError(1);
    }
  }
}
async function writeCommittedArtifacts(artifacts, cwd) {
  const schemaPaths = getSchemaPaths(cwd);
  await Promise.all([fs.writeFile(schemaPaths.graphql, artifacts.graphql), fs.writeFile(schemaPaths.prisma, artifacts.prisma)]);
}
async function generateCommittedArtifacts(graphQLSchema, config, cwd) {
  const artifacts = await getCommittedArtifacts(graphQLSchema, config);
  await writeCommittedArtifacts(artifacts, cwd);
  return artifacts;
}

const nodeAPIJS = (cwd, config) => `import keystoneConfig from '../../keystone';
import { PrismaClient } from '.prisma/client';
import { createListsAPI } from '@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/node-api';
${makeVercelIncludeTheSQLiteDB(cwd, Path__default.join(cwd, 'node_modules/.keystone/next'), config)}

export const lists = createListsAPI(keystoneConfig, PrismaClient);
`;

const nodeAPIDTS = `import { KeystoneListsAPI } from '@keystone-next/keystone/types';
import { KeystoneListsTypeInfo } from './types';

export const lists: KeystoneListsAPI<KeystoneListsTypeInfo>;`;

const makeVercelIncludeTheSQLiteDB = (cwd, directoryOfFileToBeWritten, config) => {
  if (config.db.adapter === 'prisma_sqlite' || config.db.provider === 'sqlite') {
    const sqliteDbAbsolutePath = Path__default.resolve(cwd, config.db.url.replace('file:', ''));
    return `import path from 'path';

    path.join(__dirname, ${JSON.stringify(Path__default.relative(directoryOfFileToBeWritten, sqliteDbAbsolutePath))});
    path.join(process.cwd(), ${JSON.stringify(Path__default.relative(cwd, sqliteDbAbsolutePath))});
    `;
  }

  return '';
};

const nextGraphQLAPIJS = (cwd, config) => `import keystoneConfig from '../../../keystone';
import { PrismaClient } from '.prisma/client';
import { nextGraphQLAPIRoute } from '@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/next-graphql';
${makeVercelIncludeTheSQLiteDB(cwd, Path__default.join(cwd, 'node_modules/.keystone/next'), config)}

export const config = {
  api: {
    bodyParser: false,
  },
};

export default nextGraphQLAPIRoute(keystoneConfig, PrismaClient);
`; // note the export default config is just a lazy way of going "this is also any"


const nextGraphQLAPIDTS = `export const config: any;
export default config;
`;
async function generateNodeModulesArtifacts(graphQLSchema, config, cwd) {
  var _config$experimental, _config$experimental2;

  const lists = initialiseLists(config.lists, getDBProvider(config.db));
  const printedSchema = printSchema(graphQLSchema);
  const dotKeystoneDir = Path__default.join(cwd, 'node_modules/.keystone');
  await Promise.all([generatePrismaClient(cwd), fs.outputFile(Path__default.join(dotKeystoneDir, 'types.d.ts'), printGeneratedTypes(printedSchema, graphQLSchema, lists)), fs.outputFile(Path__default.join(dotKeystoneDir, 'types.js'), ''), ...((_config$experimental = config.experimental) !== null && _config$experimental !== void 0 && _config$experimental.generateNodeAPI ? [fs.outputFile(Path__default.join(dotKeystoneDir, 'api.js'), nodeAPIJS(cwd, config)), fs.outputFile(Path__default.join(dotKeystoneDir, 'api.d.ts'), nodeAPIDTS)] : []), ...((_config$experimental2 = config.experimental) !== null && _config$experimental2 !== void 0 && _config$experimental2.generateNextGraphqlAPI ? [fs.outputFile(Path__default.join(dotKeystoneDir, 'next/graphql-api.js'), nextGraphQLAPIJS(cwd, config)), fs.outputFile(Path__default.join(dotKeystoneDir, 'next/graphql-api.d.ts'), nextGraphQLAPIDTS)] : [])]);
}

async function generatePrismaClient(cwd) {
  const generator = await getGenerator({
    schemaPath: getSchemaPaths(cwd).prisma
  });
  await generator.generate();
  generator.stop();
}

function requirePrismaClient(cwd) {
  return require(Path__default.join(cwd, 'node_modules/.prisma/client')).PrismaClient;
}

export { generateCommittedArtifacts, generateNodeModulesArtifacts, getCommittedArtifacts, getSchemaPaths, requirePrismaClient, validateCommittedArtifacts, writeCommittedArtifacts };
