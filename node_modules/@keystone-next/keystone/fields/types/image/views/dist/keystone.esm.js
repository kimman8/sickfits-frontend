import { jsx, Stack, Text, useTheme, VisuallyHidden } from '@keystone-ui/core';
import { FieldContainer, FieldLabel, TextInput } from '@keystone-ui/fields';
import copy from 'copy-to-clipboard';
import bytes from 'bytes';
import { useRef, useMemo, useState, useEffect, Fragment } from 'react';
import { useToasts } from '@keystone-ui/toast';
import { Pill } from '@keystone-ui/pill';
import { Button } from '@keystone-ui/button';
import { parseImageRef } from '../../utils/dist/keystone.esm.js';

/** @jsxRuntime classic */

function useObjectURL(fileData) {
  let [objectURL, setObjectURL] = useState(undefined);
  useEffect(() => {
    if (fileData) {
      let url = URL.createObjectURL(fileData);
      setObjectURL(url);
      return () => {
        URL.revokeObjectURL(url);
      };
    }
  }, [fileData]);
  return objectURL;
}

const RefView = ({
  field,
  onChange,
  onCancel,
  error
}) => {
  return jsx(Fragment, null, jsx(VisuallyHidden, {
    htmlFor: `${field.path}--ref-input`,
    as: "label"
  }, 'Paste the image ref here'), jsx(Stack, {
    gap: "small",
    across: true,
    css: {
      width: '100%',
      justifyContent: 'space-between',
      'div:first-of-type': {
        flex: '2'
      }
    }
  }, jsx(TextInput, {
    id: `${field.path}--ref-input`,
    autoFocus: true,
    placeholder: "Paste the image ref here",
    onChange: event => {
      onChange(event.target.value);
    },
    css: {
      width: '100%'
    }
  }), jsx(Button, {
    tone: "passive",
    onClick: onCancel
  }, "Cancel"), error ? jsx(Pill, {
    weight: "light",
    tone: "negative"
  }, error) : null));
};

function Field({
  autoFocus,
  field,
  value,
  forceValidation,
  onChange
}) {
  const inputRef = useRef(null);
  const errorMessage = createErrorMessage(value, forceValidation);

  const onUploadChange = ({
    currentTarget: {
      validity,
      files
    }
  }) => {
    const file = files === null || files === void 0 ? void 0 : files[0];
    if (!file) return; // bail if the user cancels from the file browser

    onChange === null || onChange === void 0 ? void 0 : onChange({
      kind: 'upload',
      data: {
        file,
        validity
      },
      previous: value
    });
  }; // Generate a random input key when the value changes, to ensure the file input is unmounted and
  // remounted (this is the only way to reset its value and ensure onChange will fire again if
  // the user selects the same file again)
  // eslint-disable-next-line react-hooks/exhaustive-deps


  const inputKey = useMemo(() => Math.random(), [value]);
  return jsx(FieldContainer, {
    as: "fieldset"
  }, jsx(FieldLabel, {
    as: "legend"
  }, field.label), value.kind === 'ref' ? jsx(RefView, {
    field: field,
    onChange: ref => {
      onChange === null || onChange === void 0 ? void 0 : onChange({
        kind: 'ref',
        data: {
          ref
        },
        previous: value.previous
      });
    },
    error: forceValidation && errorMessage ? errorMessage : undefined,
    onCancel: () => {
      onChange === null || onChange === void 0 ? void 0 : onChange(value.previous);
    }
  }) : jsx(ImgView, {
    errorMessage: errorMessage,
    value: value,
    onChange: onChange,
    field: field,
    inputRef: inputRef
  }), jsx("input", {
    css: {
      display: 'none'
    },
    autoComplete: "off",
    autoFocus: autoFocus,
    ref: inputRef,
    key: inputKey,
    name: field.path,
    onChange: onUploadChange,
    type: "file",
    disabled: onChange === undefined
  }));
}

function ImgView({
  errorMessage,
  value,
  onChange,
  field,
  inputRef
}) {
  const {
    addToast
  } = useToasts();
  const imagePathFromUpload = useObjectURL(errorMessage === undefined && value.kind === 'upload' ? value.data.file : undefined);

  const onSuccess = () => {
    addToast({
      title: 'Copied image ref to clipboard',
      tone: 'positive'
    });
  };

  const onFailure = () => {
    addToast({
      title: 'Failed to copy image ref to clipboard',
      tone: 'negative'
    });
  };

  const copyRef = () => {
    if (value.kind !== 'from-server') {
      return;
    }

    if (navigator) {
      // use the new navigator.clipboard API if it exists
      navigator.clipboard.writeText(value === null || value === void 0 ? void 0 : value.data.ref).then(onSuccess, onFailure);
      return;
    } else {
      // Fallback to a library that leverages document.execCommand
      // for browser versions that dont' support the navigator object.
      // As document.execCommand
      try {
        copy(value === null || value === void 0 ? void 0 : value.data.ref);
      } catch (e) {
        addToast({
          title: 'Faild to oopy to clipboard',
          tone: 'negative'
        });
      }

      return;
    }
  };

  return value.kind === 'from-server' || value.kind === 'upload' ? jsx(Stack, {
    gap: "small",
    across: true,
    align: "center"
  }, errorMessage === undefined ? value.kind === 'from-server' ? jsx(ImageWrapper, null, jsx("img", {
    css: {
      width: '100%'
    },
    src: value.data.src,
    alt: field.path
  })) : jsx(ImageWrapper, null, jsx("img", {
    css: {
      height: 'auto',
      maxWidth: '100%'
    },
    src: imagePathFromUpload,
    alt: field.path
  })) : null, onChange && jsx(Stack, {
    gap: "small"
  }, value.kind === 'from-server' && jsx(Stack, {
    padding: "xxsmall",
    gap: "xxsmall"
  }, jsx(Stack, {
    across: true,
    align: "center",
    gap: "small"
  }, jsx(Text, {
    size: "small"
  }, jsx("a", {
    href: value.data.src,
    target: "_blank"
  }, `${value.data.id}.${value.data.extension}`)), jsx(Button, {
    size: "small",
    tone: "passive",
    onClick: copyRef
  }, "Copy Ref")), jsx(Text, {
    size: "xsmall"
  }, `${value.data.width} x ${value.data.height} (${bytes(value.data.filesize)})`)), jsx(Stack, {
    across: true,
    gap: "small",
    align: "center"
  }, jsx(Button, {
    size: "small",
    onClick: () => {
      var _inputRef$current;

      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.click();
    }
  }, "Change"), value.kind !== 'upload' ? jsx(Button, {
    size: "small",
    tone: "passive",
    onClick: () => {
      onChange({
        kind: 'ref',
        data: {
          ref: ''
        },
        previous: value
      });
    }
  }, "Paste Ref") : null, value.kind === 'from-server' && jsx(Button, {
    size: "small",
    tone: "negative",
    onClick: () => {
      onChange({
        kind: 'remove',
        previous: value
      });
    }
  }, "Remove"), value.kind === 'upload' && jsx(Button, {
    size: "small",
    tone: "negative",
    onClick: () => {
      onChange(value.previous);
    }
  }, "Cancel"), errorMessage ? jsx(Pill, {
    tone: "negative",
    weight: "light"
  }, errorMessage) : value.kind === 'upload' && jsx(Pill, {
    weight: "light",
    tone: "positive"
  }, "Save to upload this image")))) : jsx(Stack, {
    gap: "small"
  }, jsx(Stack, {
    css: {
      alignItems: 'center'
    },
    gap: "small",
    across: true
  }, jsx(Button, {
    size: "small",
    disabled: onChange === undefined,
    onClick: () => {
      var _inputRef$current2;

      (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.click();
    },
    tone: "positive"
  }, "Upload Image"), jsx(Button, {
    size: "small",
    tone: "passive",
    disabled: onChange === undefined,
    onClick: () => {
      onChange === null || onChange === void 0 ? void 0 : onChange({
        kind: 'ref',
        data: {
          ref: ''
        },
        previous: value
      });
    }
  }, "Paste Ref"), value.kind === 'remove' && value.previous && jsx(Button, {
    size: "small",
    tone: "negative",
    onClick: () => {
      if (value.previous !== undefined) {
        onChange === null || onChange === void 0 ? void 0 : onChange(value === null || value === void 0 ? void 0 : value.previous);
      }
    }
  }, "Undo removal"), value.kind === 'remove' && // NOTE -- UX decision is to not display this, I think it would only be relevant
  // for deleting uploaded images (and we don't support that yet)
  // <Pill weight="light" tone="warning">
  //   Save to remove this image
  // </Pill>
  null));
}

function validateRef({
  ref
}) {
  if (!parseImageRef(ref)) {
    return 'Invalid ref';
  }
}

function createErrorMessage(value, forceValidation) {
  if (value.kind === 'upload') {
    return validateImage(value.data);
  } else if (value.kind === 'ref') {
    return forceValidation ? validateRef(value.data) : undefined;
  }
}

function validateImage({
  file,
  validity
}) {
  if (!validity.valid) {
    return 'Something went wrong, please reload and try again.';
  } // check if the file is actually an image


  if (!file.type.includes('image')) {
    return 'Only image files are allowed. Please try again.';
  }
} // ==============================
// Styled Components
// ==============================

const ImageWrapper = ({
  children
}) => {
  const theme = useTheme();
  return jsx("div", {
    css: {
      backgroundColor: 'white',
      borderRadius: theme.radii.medium,
      border: `1px solid ${theme.colors.border}`,
      flexShrink: 0,
      lineHeight: 0,
      padding: 4,
      position: 'relative',
      textAlign: 'center',
      width: '130px' // 120px image + chrome

    }
  }, children);
};

/** @jsxRuntime classic */
const Cell = ({
  item,
  field
}) => {
  const data = item[field.path];
  if (!data) return null;
  return jsx("div", {
    css: {
      alignItems: 'center',
      display: 'flex',
      height: 24,
      lineHeight: 0,
      width: 24
    }
  }, jsx("img", {
    alt: data.filename,
    css: {
      maxHeight: '100%',
      maxWidth: '100%'
    },
    src: data.src
  }));
};
const CardValue = ({
  item,
  field
}) => {
  const data = item[field.path];
  return jsx(FieldContainer, null, jsx(FieldLabel, null, field.label), data && jsx(ImageWrapper, null, jsx("img", {
    css: {
      width: '100%'
    },
    alt: data.filename,
    src: data.src
  })));
};
const controller = config => {
  return {
    path: config.path,
    label: config.label,
    graphqlSelection: `${config.path} {
        src
        id
        ref
        extension
        width
        height
        filesize
      }`,
    defaultValue: {
      kind: 'empty'
    },

    deserialize(item) {
      const value = item[config.path];
      if (!value) return {
        kind: 'empty'
      };
      return {
        kind: 'from-server',
        data: {
          src: value.src,
          id: value.id,
          extension: value.extension,
          ref: value.ref,
          width: value.width,
          height: value.height,
          filesize: value.filesize
        }
      };
    },

    validate(value) {
      if (value.kind === 'ref') {
        return validateRef(value.data) === undefined;
      }

      return value.kind !== 'upload' || validateImage(value.data) === undefined;
    },

    serialize(value) {
      if (value.kind === 'upload') {
        return {
          [config.path]: {
            upload: value.data.file
          }
        };
      }

      if (value.kind === 'ref') {
        return {
          [config.path]: {
            ref: value.data.ref
          }
        };
      }

      if (value.kind === 'remove') {
        return {
          [config.path]: null
        };
      }

      return {};
    }

  };
};

export { CardValue, Cell, Field, controller };
