import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import { GraphQLObjectType, GraphQLSchema } from 'graphql';
import * as cookie from 'cookie';
import Iron from '@hapi/iron';
import { sync } from 'uid-safe';
import '../../dist/sqlite-943cbaa7.esm.js';
import { field } from '@graphql-ts/schema/api-with-context';
import { nonNull, Boolean } from '@graphql-ts/schema/api-without-context';
import 'decimal.js';
import '@graphql-ts/schema';
import 'graphql-type-json';
import 'graphql-upload/public/GraphQLUpload.js';

const _excluded = ["store", "maxAge"];

function generateSessionId() {
  return sync(24);
}

const TOKEN_NAME = 'keystonejs-session';
const MAX_AGE = 60 * 60 * 8; // 8 hours
// should we also accept httpOnly?

function statelessSessions({
  secret,
  maxAge = MAX_AGE,
  path = '/',
  secure = process.env.NODE_ENV === 'production',
  ironOptions = Iron.defaults,
  domain,
  sameSite = 'lax'
}) {
  if (!secret) {
    throw new Error('You must specify a session secret to use sessions');
  }

  if (secret.length < 32) {
    throw new Error('The session secret must be at least 32 characters long');
  }

  return {
    async get({
      req
    }) {
      var _req$headers$authoriz;

      const cookies = cookie.parse(req.headers.cookie || '');
      const bearer = (_req$headers$authoriz = req.headers.authorization) === null || _req$headers$authoriz === void 0 ? void 0 : _req$headers$authoriz.replace('Bearer ', '');
      const token = bearer || cookies[TOKEN_NAME];
      if (!token) return;

      try {
        return await Iron.unseal(token, secret, ironOptions);
      } catch (err) {}
    },

    async end({
      res
    }) {
      res.setHeader('Set-Cookie', cookie.serialize(TOKEN_NAME, '', {
        maxAge: 0,
        expires: new Date(),
        httpOnly: true,
        secure,
        path,
        sameSite,
        domain
      }));
    },

    async start({
      res,
      data
    }) {
      let sealedData = await Iron.seal(data, secret, _objectSpread(_objectSpread({}, ironOptions), {}, {
        ttl: maxAge * 1000
      }));
      res.setHeader('Set-Cookie', cookie.serialize(TOKEN_NAME, sealedData, {
        maxAge,
        expires: new Date(Date.now() + maxAge * 1000),
        httpOnly: true,
        secure,
        path,
        sameSite,
        domain
      }));
      return sealedData;
    }

  };
}
function storedSessions(_ref) {
  let {
    store: storeOption,
    maxAge = MAX_AGE
  } = _ref,
      statelessSessionsOptions = _objectWithoutProperties(_ref, _excluded);

  let {
    get,
    start,
    end
  } = statelessSessions(_objectSpread(_objectSpread({}, statelessSessionsOptions), {}, {
    maxAge
  }));
  let store = typeof storeOption === 'function' ? storeOption({
    maxAge
  }) : storeOption;
  let isConnected = false;
  return {
    async get({
      req,
      createContext
    }) {
      const data = await get({
        req,
        createContext
      });
      const sessionId = data === null || data === void 0 ? void 0 : data.sessionId;

      if (typeof sessionId === 'string') {
        if (!isConnected) {
          var _store$connect;

          await ((_store$connect = store.connect) === null || _store$connect === void 0 ? void 0 : _store$connect.call(store));
          isConnected = true;
        }

        return store.get(sessionId);
      }
    },

    async start({
      res,
      data,
      createContext
    }) {
      let sessionId = generateSessionId();

      if (!isConnected) {
        var _store$connect2;

        await ((_store$connect2 = store.connect) === null || _store$connect2 === void 0 ? void 0 : _store$connect2.call(store));
        isConnected = true;
      }

      await store.set(sessionId, data);
      return (start === null || start === void 0 ? void 0 : start({
        res,
        data: {
          sessionId
        },
        createContext
      })) || '';
    },

    async end({
      req,
      res,
      createContext
    }) {
      const data = await get({
        req,
        createContext
      });
      const sessionId = data === null || data === void 0 ? void 0 : data.sessionId;

      if (typeof sessionId === 'string') {
        if (!isConnected) {
          var _store$connect3;

          await ((_store$connect3 = store.connect) === null || _store$connect3 === void 0 ? void 0 : _store$connect3.call(store));
          isConnected = true;
        }

        await store.delete(sessionId);
      }

      await (end === null || end === void 0 ? void 0 : end({
        req,
        res,
        createContext
      }));
    }

  };
}
/**
 * This is the function createSystem uses to implement the session strategy provided
 */

async function createSessionContext(sessionStrategy, req, res, createContext) {
  return {
    session: await sessionStrategy.get({
      req,
      createContext
    }),
    startSession: data => sessionStrategy.start({
      res,
      data,
      createContext
    }),
    endSession: () => sessionStrategy.end({
      req,
      res,
      createContext
    })
  };
}
function sessionSchema(graphQLSchema) {
  const schemaConfig = graphQLSchema.toConfig();
  const mutationTypeConfig = graphQLSchema.getMutationType().toConfig();
  const endSessionField = field({
    type: nonNull(Boolean),

    async resolve(rootVal, args, context) {
      if (context.endSession) {
        await context.endSession();
      }

      return true;
    }

  });
  const mutationType = new GraphQLObjectType(_objectSpread(_objectSpread({}, mutationTypeConfig), {}, {
    fields: _objectSpread(_objectSpread({}, mutationTypeConfig.fields), {}, {
      endSession: _objectSpread(_objectSpread({}, endSessionField), {}, {
        type: endSessionField.type.graphQLType
      })
    })
  }));
  return new GraphQLSchema(_objectSpread(_objectSpread({}, schemaConfig), {}, {
    types: schemaConfig.types.map(x => x.name === 'Mutation' ? mutationType : x),
    mutation: mutationType
  }));
}

export { createSessionContext, sessionSchema, statelessSessions, storedSessions };
