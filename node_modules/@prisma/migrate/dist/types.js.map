{
  "version": 3,
  "sources": ["../src/types.ts"],
  "sourcesContent": ["interface UserFacingError {\n  is_panic: boolean\n  message: string\n  error_code?: string\n  meta?: unknown\n}\n\nexport type UserFacingErrorWithMeta = {\n  is_panic: boolean\n  message: string\n  error_code: 'P3006'\n  meta: {\n    migration_name: string\n    inner_error?: {\n      is_panic: boolean\n      message: string\n      backtrace: string\n    }\n  }\n}\n\nexport type DriftDiagnostic =\n  /// The current database schema does not match the schema that would be expected from applying the migration history.\n  | { diagnostic: 'driftDetected'; rollback: string }\n  // A migration failed to cleanly apply to a temporary database.\n  | {\n      diagnostic: 'migrationFailedToApply'\n      error: UserFacingError\n    }\n\nexport type HistoryDiagnostic =\n  | { diagnostic: 'databaseIsBehind'; unappliedMigrationNames: string[] }\n  | {\n      diagnostic: 'migrationsDirectoryIsBehind'\n      unpersistedMigrationNames: string[]\n    }\n  | {\n      diagnostic: 'historiesDiverge'\n      lastCommonMigrationName: string\n      unpersistedMigrationNames: string[]\n      unappliedMigrationNames: string[]\n    }\n\nexport interface MigrationFeedback {\n  message: string\n  stepIndex: number\n}\n\nexport type DevAction =\n  | { tag: 'reset'; reason: string }\n  | { tag: 'createMigration' }\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace EngineArgs {\n  /**\n   * These RPCs need a sourceConfig, therefore a db connection to function\n   */\n  export interface DevDiagnosticInput {\n    migrationsDirectoryPath: string\n  }\n  export interface ListMigrationDirectoriesInput {\n    migrationsDirectoryPath: string\n  }\n  export interface MarkMigrationAppliedInput {\n    migrationsDirectoryPath: string\n    migrationName: string\n  }\n  export interface MarkMigrationRolledBackInput {\n    migrationName: string\n  }\n  export interface DiagnoseMigrationHistoryInput {\n    migrationsDirectoryPath: string\n    /// Whether creating shadow/temporary databases is allowed.\n    optInToShadowDatabase: boolean\n  }\n  export interface PlanMigrationInput {\n    migrationsDirectoryPath: string\n    prismaSchema: string\n  }\n  export interface EvaluateDataLossInput {\n    migrationsDirectoryPath: string\n    prismaSchema: string\n  }\n  export interface CreateMigrationInput {\n    migrationsDirectoryPath: string\n    prismaSchema: string\n    draft: boolean // if true, always generate a migration, but do not apply\n    /// The user-given name for the migration. This will be used in the migration directory.\n    migrationName?: string\n  }\n  export interface ApplyMigrationsInput {\n    migrationsDirectoryPath: string\n  }\n\n  export interface SchemaPush {\n    schema: string\n    force: boolean\n  }\n  export interface DropDatabase {\n    schema: string\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace EngineResults {\n  export interface ListMigrationDirectoriesOutput {\n    migrations: string[]\n  }\n  export interface DiagnoseMigrationHistoryOutput {\n    /// Null means the database and the migrations directory are in sync and up to date.\n    history: HistoryDiagnostic | null\n    /// The name of the migrations that failed to apply completely to the database.\n    failedMigrationNames: string[]\n    /// The names of the migrations that were modified after they were applied to the database.\n    editedMigrationNames: string[]\n    /// Whether the migrations table is present.\n    hasMigrationsTable: boolean\n  }\n  export interface DevDiagnosticOutput {\n    action: DevAction\n  }\n  export interface PlanMigrationOutput {\n    // Todo\n  }\n  export interface EvaluateDataLossOutput {\n    /// The number of migration steps that would be generated. If this is 0, we wouldn't generate a new migration, unless the `draft` option is passed.\n    migrationSteps: number\n\n    /// The warnings and unexecutable migration messages that apply to the _development database_.\n    /// The warnings for the production databases are written as comments into the migration scripts.\n    warnings: MigrationFeedback[]\n    unexecutableSteps: MigrationFeedback[]\n  }\n  export interface CreateMigrationOutput {\n    /// The name of the newly generated migration directory, if any.\n    generatedMigrationName: string | null\n  }\n  export interface ApplyMigrationsOutput {\n    appliedMigrationNames: string[]\n  }\n\n  export interface SchemaPush {\n    executedSteps: number\n    warnings: string[]\n    unexecutable: string[]\n  }\n}\n\nexport interface FileMap {\n  [fileName: string]: string\n}\n\nexport interface Dictionary<T> {\n  [key: string]: T\n}\n"],
  "mappings": ";;AAAA;",
  "names": []
}
