var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
__export(exports, {
  EngineError: () => EngineError,
  MigrateEngine: () => MigrateEngine
});
var import_debug = __toModule(require("@prisma/debug"));
var import_sdk = __toModule(require("@prisma/sdk"));
var import_chalk = __toModule(require("chalk"));
var import_child_process = __toModule(require("child_process"));
var import_byline = __toModule(require("./utils/byline"));
const debugRpc = (0, import_debug.default)("prisma:migrateEngine:rpc");
const debugStderr = (0, import_debug.default)("prisma:migrateEngine:stderr");
const debugStdin = (0, import_debug.default)("prisma:migrateEngine:stdin");
class EngineError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
}
let messageId = 1;
class MigrateEngine {
  constructor({
    projectDir,
    debug = false,
    schemaPath,
    enabledPreviewFeatures
  }) {
    this.listeners = {};
    this.messages = [];
    this.lastError = null;
    this.projectDir = projectDir;
    this.schemaPath = schemaPath;
    if (debug) {
      import_debug.default.enable("MigrateEngine*");
    }
    this.debug = debug;
    this.enabledPreviewFeatures = enabledPreviewFeatures;
  }
  stop() {
    this.child.kill();
  }
  devDiagnostic(args) {
    return this.runCommand(this.getRPCPayload("devDiagnostic", args));
  }
  listMigrationDirectories(args) {
    return this.runCommand(this.getRPCPayload("listMigrationDirectories", args));
  }
  markMigrationApplied(args) {
    return this.runCommand(this.getRPCPayload("markMigrationApplied", args));
  }
  markMigrationRolledBack(args) {
    return this.runCommand(this.getRPCPayload("markMigrationRolledBack", args));
  }
  diagnoseMigrationHistory(args) {
    return this.runCommand(this.getRPCPayload("diagnoseMigrationHistory", args));
  }
  planMigration(args) {
    return this.runCommand(this.getRPCPayload("planMigration", args));
  }
  evaluateDataLoss(args) {
    return this.runCommand(this.getRPCPayload("evaluateDataLoss", args));
  }
  createMigration(args) {
    return this.runCommand(this.getRPCPayload("createMigration", args));
  }
  applyMigrations(args) {
    return this.runCommand(this.getRPCPayload("applyMigrations", args));
  }
  reset() {
    return this.runCommand(this.getRPCPayload("reset", void 0));
  }
  getDatabaseVersion() {
    return this.runCommand(this.getRPCPayload("getDatabaseVersion", void 0));
  }
  schemaPush(args) {
    return this.runCommand(this.getRPCPayload("schemaPush", args));
  }
  debugPanic() {
    return this.runCommand(this.getRPCPayload("debugPanic", void 0));
  }
  rejectAll(err) {
    Object.entries(this.listeners).map(([id, listener]) => {
      listener(null, err);
      delete this.listeners[id];
    });
  }
  registerCallback(id, callback) {
    this.listeners[id] = callback;
  }
  handleResponse(response) {
    let result;
    try {
      result = JSON.parse(response);
    } catch (e) {
      console.error(`Could not parse migration engine response: ${response.slice(0, 200)}`);
    }
    if (result) {
      if (result.id) {
        if (!this.listeners[result.id]) {
          console.error(`Got result for unknown id ${result.id}`);
        }
        if (this.listeners[result.id]) {
          this.listeners[result.id](result);
          delete this.listeners[result.id];
        }
      } else {
        if (result.is_panic) {
          throw new Error(`Response: ${result.message}`);
        } else if (result.message) {
          console.error(import_chalk.default.red(`Response: ${result.message}`));
        } else {
          console.error(import_chalk.default.red(`Response: ${JSON.stringify(result)}`));
        }
      }
    }
  }
  init() {
    if (!this.initPromise) {
      this.initPromise = this.internalInit();
    }
    return this.initPromise;
  }
  internalInit() {
    return new Promise(async (resolve, reject) => {
      try {
        const { PWD, ...rest } = process.env;
        const binaryPath = await (0, import_sdk.resolveBinary)(import_sdk.BinaryType.migrationEngine);
        debugRpc("starting migration engine with binary: " + binaryPath);
        const args = ["-d", this.schemaPath];
        if (this.enabledPreviewFeatures && Array.isArray(this.enabledPreviewFeatures) && this.enabledPreviewFeatures.length > 0) {
          args.push(...[
            "--enabled-preview-features",
            this.enabledPreviewFeatures.join(",")
          ]);
        }
        this.child = (0, import_child_process.spawn)(binaryPath, args, {
          cwd: this.projectDir,
          stdio: ["pipe", "pipe", this.debug ? process.stderr : "pipe"],
          env: {
            ...rest,
            SERVER_ROOT: this.projectDir,
            RUST_LOG: "info",
            RUST_BACKTRACE: "1"
          }
        });
        this.child.on("error", (err) => {
          console.error("[migration-engine] error: %s", err);
          this.rejectAll(err);
          reject(err);
        });
        this.child.on("exit", (code) => {
          var _a;
          const exitWithErr = (err) => {
            this.rejectAll(err);
            reject(err);
          };
          const engineMessage = ((_a = this.lastError) == null ? void 0 : _a.message) || this.messages.join("\n");
          const handlePanic = () => {
            const stackTrace = this.messages.join("\n");
            exitWithErr(new import_sdk.RustPanic(serializePanic(engineMessage), stackTrace, this.lastRequest, import_sdk.ErrorArea.LIFT_CLI, this.schemaPath));
          };
          switch (code) {
            case import_sdk.MigrateEngineExitCode.Success:
              break;
            case import_sdk.MigrateEngineExitCode.Error:
              exitWithErr(new Error(`Error in migration engine: ${engineMessage}`));
              break;
            case import_sdk.MigrateEngineExitCode.Panic:
              handlePanic();
              break;
            default:
              handlePanic();
          }
        });
        this.child.stdin.on("error", (err) => {
          debugStdin(err);
        });
        (0, import_byline.default)(this.child.stderr).on("data", (msg) => {
          var _a;
          const data = String(msg);
          debugStderr(data);
          try {
            const json = JSON.parse(data);
            if (((_a = json.fields) == null ? void 0 : _a.migrate_action) === "log") {
            }
            this.messages.push(json.fields.message);
            if (json.level === "ERROR") {
              this.lastError = json.fields;
            }
          } catch (e) {
          }
        });
        (0, import_byline.default)(this.child.stdout).on("data", (line) => {
          this.handleResponse(String(line));
        });
        setImmediate(() => {
          resolve();
        });
      } catch (e) {
        reject(e);
      }
    });
  }
  async runCommand(request) {
    var _a;
    if (process.env.FORCE_PANIC_MIGRATION_ENGINE) {
      request = this.getRPCPayload("debugPanic", void 0);
    }
    await this.init();
    if ((_a = this.child) == null ? void 0 : _a.killed) {
      throw new Error(`Can't execute ${JSON.stringify(request)} because migration engine already exited.`);
    }
    return new Promise((resolve, reject) => {
      this.registerCallback(request.id, (response, err) => {
        var _a2, _b, _c, _d, _e, _f;
        if (err) {
          return reject(err);
        }
        if (response.result !== void 0) {
          resolve(response.result);
        } else {
          if (response.error) {
            debugRpc(response);
            if ((_a2 = response.error.data) == null ? void 0 : _a2.is_panic) {
              const message = (_d = (_c = (_b = response.error.data) == null ? void 0 : _b.error) == null ? void 0 : _c.message) != null ? _d : response.error.message;
              reject(new import_sdk.RustPanic(message, response.error.data.message, this.lastRequest, import_sdk.ErrorArea.LIFT_CLI, this.schemaPath));
            } else if ((_e = response.error.data) == null ? void 0 : _e.message) {
              let message = `${import_chalk.default.redBright(response.error.data.message)}
`;
              if ((_f = response.error.data) == null ? void 0 : _f.error_code) {
                message = import_chalk.default.redBright(`${response.error.data.error_code}

`) + message;
                reject(new EngineError(message, response.error.data.error_code));
              } else {
                reject(new Error(message));
              }
            } else {
              reject(new Error(`${import_chalk.default.redBright("Error in RPC")}
 Request: ${JSON.stringify(request, null, 2)}
Response: ${JSON.stringify(response, null, 2)}
${response.error.message}
`));
            }
          } else {
            reject(new Error(`Got invalid RPC response without .result property: ${JSON.stringify(response)}`));
          }
        }
      });
      if (this.child.stdin.destroyed) {
        throw new Error(`Can't execute ${JSON.stringify(request)} because migration engine is destroyed.`);
      }
      debugRpc("SENDING RPC CALL", JSON.stringify(request));
      this.child.stdin.write(JSON.stringify(request) + "\n");
      this.lastRequest = request;
    });
  }
  getRPCPayload(method, params) {
    return {
      id: messageId++,
      jsonrpc: "2.0",
      method,
      params: {
        ...params
      }
    };
  }
}
function serializePanic(log) {
  return `${import_chalk.default.red.bold("Error in migration engine.\nReason: ")}${import_chalk.default.red(`${log}`)}

Please create an issue with your \`schema.prisma\` at
${import_chalk.default.underline("https://github.com/prisma/prisma/issues/new")}
`;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  EngineError,
  MigrateEngine
});
