import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import 'decimal.js';
import { Boolean as Boolean$2, Float as Float$2, ID, Int as Int$2, String as String$2, enum as enum$1, enumValues, arg, inputObject, list, nonNull, scalar } from '@graphql-ts/schema/api-without-context';
import * as graphqlTsSchema from '@graphql-ts/schema';
import { bindGraphQLSchemaAPIToContext } from '@graphql-ts/schema';
import { GraphQLJSON } from 'graphql-type-json';
import GraphQLUpload from 'graphql-upload/public/GraphQLUpload.js';
import { field, fields, interface as interface$1, interfaceField, object, union } from '@graphql-ts/schema/api-with-context';

const JSON = graphqlTsSchema.graphql.scalar(GraphQLJSON);
const Upload = graphqlTsSchema.graphql.scalar(GraphQLUpload);

var graphqlBoundToKeystoneContext = /*#__PURE__*/Object.freeze({
  __proto__: null,
  JSON: JSON,
  Upload: Upload,
  Boolean: Boolean$2,
  Float: Float$2,
  ID: ID,
  Int: Int$2,
  String: String$2,
  'enum': enum$1,
  enumValues: enumValues,
  arg: arg,
  inputObject: inputObject,
  list: list,
  nonNull: nonNull,
  scalar: scalar,
  bindGraphQLSchemaAPIToContext: bindGraphQLSchemaAPIToContext,
  field: field,
  fields: fields,
  'interface': interface$1,
  interfaceField: interfaceField,
  object: object,
  union: union
});

// because they use an enum which means TS users have to import the CacheScope enum from apollo-cache-control which isn't great
// so we have a copy of it but using a union of string literals instead of an enum
// (note people importing the enum from apollo-cache-control will still be able to use it because you can use enums as their literal values but not the opposite)

const orderDirectionEnum = enum$1({
  name: 'OrderDirection',
  values: enumValues(['asc', 'desc'])
});
const QueryMode = enum$1({
  name: 'QueryMode',
  values: enumValues(['default', 'insensitive'])
});
// fieldType(dbField)(fieldInfo) => { ...fieldInfo, dbField };
function fieldType(dbField) {
  return function (graphQLInfo) {
    return _objectSpread(_objectSpread({}, graphQLInfo), {}, {
      dbField
    });
  };
}

// (even though, yes, having EnumFilter by defined as EnumNullableFilter<Enum>, would be the same type but names would show up differently in editors for example)

function enumFilters(enumType) {
  const optional = inputObject({
    name: `${enumType.graphQLType.name}NullableFilter`,
    fields: () => ({
      equals: arg({
        type: enumType
      }),
      in: arg({
        type: list(nonNull(enumType))
      }),
      notIn: arg({
        type: list(nonNull(enumType))
      }),
      not: arg({
        type: optional
      })
    })
  });
  const required = inputObject({
    name: `${enumType.graphQLType.name}Filter`,
    fields: () => ({
      equals: arg({
        type: enumType
      }),
      in: arg({
        type: list(nonNull(enumType))
      }),
      notIn: arg({
        type: list(nonNull(enumType))
      }),
      not: arg({
        type: optional
      })
    })
  });
  const many = inputObject({
    name: `${enumType.graphQLType.name}NullableListFilter`,
    fields: () => ({
      // can be null
      equals: arg({
        type: list(nonNull(enumType))
      }),
      // can be null
      has: arg({
        type: enumType
      }),
      hasEvery: arg({
        type: list(nonNull(enumType))
      }),
      hasSome: arg({
        type: list(nonNull(enumType))
      }),
      isEmpty: arg({
        type: enumType
      })
    })
  });
  return {
    optional,
    required,
    many
  };
}

// Do not manually modify this file, it is automatically generated by the package at /prisma-utils in this repo.
const StringNullableFilter$1 = inputObject({
  name: 'StringNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: String$2
    }),
    // can be null
    in: arg({
      type: list(nonNull(String$2))
    }),
    // can be null
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    contains: arg({
      type: String$2
    }),
    startsWith: arg({
      type: String$2
    }),
    endsWith: arg({
      type: String$2
    }),
    mode: arg({
      type: QueryMode
    }),
    // can be null
    not: arg({
      type: NestedStringNullableFilter$1
    })
  })
});
const NestedStringNullableFilter$1 = inputObject({
  name: 'NestedStringNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: String$2
    }),
    // can be null
    in: arg({
      type: list(nonNull(String$2))
    }),
    // can be null
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    contains: arg({
      type: String$2
    }),
    startsWith: arg({
      type: String$2
    }),
    endsWith: arg({
      type: String$2
    }),
    // can be null
    not: arg({
      type: NestedStringNullableFilter$1
    })
  })
});
const StringFilter$1 = inputObject({
  name: 'StringFilter',
  fields: () => ({
    equals: arg({
      type: String$2
    }),
    in: arg({
      type: list(nonNull(String$2))
    }),
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    contains: arg({
      type: String$2
    }),
    startsWith: arg({
      type: String$2
    }),
    endsWith: arg({
      type: String$2
    }),
    mode: arg({
      type: QueryMode
    }),
    not: arg({
      type: NestedStringFilter$1
    })
  })
});
const NestedStringFilter$1 = inputObject({
  name: 'NestedStringFilter',
  fields: () => ({
    equals: arg({
      type: String$2
    }),
    in: arg({
      type: list(nonNull(String$2))
    }),
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    contains: arg({
      type: String$2
    }),
    startsWith: arg({
      type: String$2
    }),
    endsWith: arg({
      type: String$2
    }),
    not: arg({
      type: NestedStringFilter$1
    })
  })
});
const StringNullableListFilter = inputObject({
  name: 'StringNullableListFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: list(nonNull(String$2))
    }),
    // can be null
    has: arg({
      type: String$2
    }),
    hasEvery: arg({
      type: list(nonNull(String$2))
    }),
    hasSome: arg({
      type: list(nonNull(String$2))
    }),
    isEmpty: arg({
      type: Boolean$2
    })
  })
});
const BoolNullableFilter$1 = inputObject({
  name: 'BooleanNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: Boolean$2
    }),
    // can be null
    not: arg({
      type: BoolNullableFilter$1
    })
  })
});
const BoolFilter$1 = inputObject({
  name: 'BooleanFilter',
  fields: () => ({
    equals: arg({
      type: Boolean$2
    }),
    not: arg({
      type: BoolFilter$1
    })
  })
});
const BoolNullableListFilter = inputObject({
  name: 'BooleanNullableListFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: list(nonNull(Boolean$2))
    }),
    // can be null
    has: arg({
      type: Boolean$2
    }),
    hasEvery: arg({
      type: list(nonNull(Boolean$2))
    }),
    hasSome: arg({
      type: list(nonNull(Boolean$2))
    }),
    isEmpty: arg({
      type: Boolean$2
    })
  })
});
const IntNullableFilter$1 = inputObject({
  name: 'IntNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: Int$2
    }),
    // can be null
    in: arg({
      type: list(nonNull(Int$2))
    }),
    // can be null
    notIn: arg({
      type: list(nonNull(Int$2))
    }),
    lt: arg({
      type: Int$2
    }),
    lte: arg({
      type: Int$2
    }),
    gt: arg({
      type: Int$2
    }),
    gte: arg({
      type: Int$2
    }),
    // can be null
    not: arg({
      type: IntNullableFilter$1
    })
  })
});
const IntFilter$1 = inputObject({
  name: 'IntFilter',
  fields: () => ({
    equals: arg({
      type: Int$2
    }),
    in: arg({
      type: list(nonNull(Int$2))
    }),
    notIn: arg({
      type: list(nonNull(Int$2))
    }),
    lt: arg({
      type: Int$2
    }),
    lte: arg({
      type: Int$2
    }),
    gt: arg({
      type: Int$2
    }),
    gte: arg({
      type: Int$2
    }),
    not: arg({
      type: IntFilter$1
    })
  })
});
const IntNullableListFilter = inputObject({
  name: 'IntNullableListFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: list(nonNull(Int$2))
    }),
    // can be null
    has: arg({
      type: Int$2
    }),
    hasEvery: arg({
      type: list(nonNull(Int$2))
    }),
    hasSome: arg({
      type: list(nonNull(Int$2))
    }),
    isEmpty: arg({
      type: Boolean$2
    })
  })
});
const FloatNullableFilter$1 = inputObject({
  name: 'FloatNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: Float$2
    }),
    // can be null
    in: arg({
      type: list(nonNull(Float$2))
    }),
    // can be null
    notIn: arg({
      type: list(nonNull(Float$2))
    }),
    lt: arg({
      type: Float$2
    }),
    lte: arg({
      type: Float$2
    }),
    gt: arg({
      type: Float$2
    }),
    gte: arg({
      type: Float$2
    }),
    // can be null
    not: arg({
      type: FloatNullableFilter$1
    })
  })
});
const FloatFilter$1 = inputObject({
  name: 'FloatFilter',
  fields: () => ({
    equals: arg({
      type: Float$2
    }),
    in: arg({
      type: list(nonNull(Float$2))
    }),
    notIn: arg({
      type: list(nonNull(Float$2))
    }),
    lt: arg({
      type: Float$2
    }),
    lte: arg({
      type: Float$2
    }),
    gt: arg({
      type: Float$2
    }),
    gte: arg({
      type: Float$2
    }),
    not: arg({
      type: FloatFilter$1
    })
  })
});
const FloatNullableListFilter = inputObject({
  name: 'FloatNullableListFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: list(nonNull(Float$2))
    }),
    // can be null
    has: arg({
      type: Float$2
    }),
    hasEvery: arg({
      type: list(nonNull(Float$2))
    }),
    hasSome: arg({
      type: list(nonNull(Float$2))
    }),
    isEmpty: arg({
      type: Boolean$2
    })
  })
});
const DateTimeNullableFilter$1 = inputObject({
  name: 'DateTimeNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: String$2
    }),
    // can be null
    in: arg({
      type: list(nonNull(String$2))
    }),
    // can be null
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    // can be null
    not: arg({
      type: DateTimeNullableFilter$1
    })
  })
});
const DateTimeFilter$1 = inputObject({
  name: 'DateTimeFilter',
  fields: () => ({
    equals: arg({
      type: String$2
    }),
    in: arg({
      type: list(nonNull(String$2))
    }),
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    not: arg({
      type: DateTimeFilter$1
    })
  })
});
const DateTimeNullableListFilter = inputObject({
  name: 'DateTimeNullableListFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: list(nonNull(String$2))
    }),
    // can be null
    has: arg({
      type: String$2
    }),
    hasEvery: arg({
      type: list(nonNull(String$2))
    }),
    hasSome: arg({
      type: list(nonNull(String$2))
    }),
    isEmpty: arg({
      type: Boolean$2
    })
  })
});
const JsonNullableFilter = inputObject({
  name: 'JsonNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: JSON
    }),
    // can be null
    not: arg({
      type: JSON
    })
  })
});
const JsonFilter = inputObject({
  name: 'JsonFilter',
  fields: () => ({
    equals: arg({
      type: JSON
    }),
    not: arg({
      type: JSON
    })
  })
});
const JsonNullableListFilter = inputObject({
  name: 'JsonNullableListFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: list(nonNull(JSON))
    }),
    // can be null
    has: arg({
      type: JSON
    }),
    hasEvery: arg({
      type: list(nonNull(JSON))
    }),
    hasSome: arg({
      type: list(nonNull(JSON))
    }),
    isEmpty: arg({
      type: Boolean$2
    })
  })
});
const DecimalNullableFilter$1 = inputObject({
  name: 'DecimalNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: String$2
    }),
    // can be null
    in: arg({
      type: list(nonNull(String$2))
    }),
    // can be null
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    // can be null
    not: arg({
      type: DecimalNullableFilter$1
    })
  })
});
const DecimalFilter$1 = inputObject({
  name: 'DecimalFilter',
  fields: () => ({
    equals: arg({
      type: String$2
    }),
    in: arg({
      type: list(nonNull(String$2))
    }),
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    not: arg({
      type: DecimalFilter$1
    })
  })
});
const DecimalNullableListFilter = inputObject({
  name: 'DecimalNullableListFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: list(nonNull(String$2))
    }),
    // can be null
    has: arg({
      type: String$2
    }),
    hasEvery: arg({
      type: list(nonNull(String$2))
    }),
    hasSome: arg({
      type: list(nonNull(String$2))
    }),
    isEmpty: arg({
      type: Boolean$2
    })
  })
});
const String$1 = {
  optional: StringNullableFilter$1,
  required: StringFilter$1,
  many: StringNullableListFilter
};
const Boolean$1 = {
  optional: BoolNullableFilter$1,
  required: BoolFilter$1,
  many: BoolNullableListFilter
};
const Int$1 = {
  optional: IntNullableFilter$1,
  required: IntFilter$1,
  many: IntNullableListFilter
};
const Float$1 = {
  optional: FloatNullableFilter$1,
  required: FloatFilter$1,
  many: FloatNullableListFilter
};
const DateTime$1 = {
  optional: DateTimeNullableFilter$1,
  required: DateTimeFilter$1,
  many: DateTimeNullableListFilter
};
const Json = {
  optional: JsonNullableFilter,
  required: JsonFilter,
  many: JsonNullableListFilter
};
const Decimal$1 = {
  optional: DecimalNullableFilter$1,
  required: DecimalFilter$1,
  many: DecimalNullableListFilter
};

var postgresql = /*#__PURE__*/Object.freeze({
  __proto__: null,
  String: String$1,
  Boolean: Boolean$1,
  Int: Int$1,
  Float: Float$1,
  DateTime: DateTime$1,
  Json: Json,
  Decimal: Decimal$1,
  'enum': enumFilters
});

// Do not manually modify this file, it is automatically generated by the package at /prisma-utils in this repo.
const StringNullableFilter = inputObject({
  name: 'StringNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: String$2
    }),
    // can be null
    in: arg({
      type: list(nonNull(String$2))
    }),
    // can be null
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    contains: arg({
      type: String$2
    }),
    startsWith: arg({
      type: String$2
    }),
    endsWith: arg({
      type: String$2
    }),
    // can be null
    not: arg({
      type: NestedStringNullableFilter
    })
  })
});
const NestedStringNullableFilter = inputObject({
  name: 'NestedStringNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: String$2
    }),
    // can be null
    in: arg({
      type: list(nonNull(String$2))
    }),
    // can be null
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    contains: arg({
      type: String$2
    }),
    startsWith: arg({
      type: String$2
    }),
    endsWith: arg({
      type: String$2
    }),
    // can be null
    not: arg({
      type: NestedStringNullableFilter
    })
  })
});
const StringFilter = inputObject({
  name: 'StringFilter',
  fields: () => ({
    equals: arg({
      type: String$2
    }),
    in: arg({
      type: list(nonNull(String$2))
    }),
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    contains: arg({
      type: String$2
    }),
    startsWith: arg({
      type: String$2
    }),
    endsWith: arg({
      type: String$2
    }),
    not: arg({
      type: NestedStringFilter
    })
  })
});
const NestedStringFilter = inputObject({
  name: 'NestedStringFilter',
  fields: () => ({
    equals: arg({
      type: String$2
    }),
    in: arg({
      type: list(nonNull(String$2))
    }),
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    contains: arg({
      type: String$2
    }),
    startsWith: arg({
      type: String$2
    }),
    endsWith: arg({
      type: String$2
    }),
    not: arg({
      type: NestedStringFilter
    })
  })
});
const BoolNullableFilter = inputObject({
  name: 'BooleanNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: Boolean$2
    }),
    // can be null
    not: arg({
      type: BoolNullableFilter
    })
  })
});
const BoolFilter = inputObject({
  name: 'BooleanFilter',
  fields: () => ({
    equals: arg({
      type: Boolean$2
    }),
    not: arg({
      type: BoolFilter
    })
  })
});
const IntNullableFilter = inputObject({
  name: 'IntNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: Int$2
    }),
    // can be null
    in: arg({
      type: list(nonNull(Int$2))
    }),
    // can be null
    notIn: arg({
      type: list(nonNull(Int$2))
    }),
    lt: arg({
      type: Int$2
    }),
    lte: arg({
      type: Int$2
    }),
    gt: arg({
      type: Int$2
    }),
    gte: arg({
      type: Int$2
    }),
    // can be null
    not: arg({
      type: IntNullableFilter
    })
  })
});
const IntFilter = inputObject({
  name: 'IntFilter',
  fields: () => ({
    equals: arg({
      type: Int$2
    }),
    in: arg({
      type: list(nonNull(Int$2))
    }),
    notIn: arg({
      type: list(nonNull(Int$2))
    }),
    lt: arg({
      type: Int$2
    }),
    lte: arg({
      type: Int$2
    }),
    gt: arg({
      type: Int$2
    }),
    gte: arg({
      type: Int$2
    }),
    not: arg({
      type: IntFilter
    })
  })
});
const FloatNullableFilter = inputObject({
  name: 'FloatNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: Float$2
    }),
    // can be null
    in: arg({
      type: list(nonNull(Float$2))
    }),
    // can be null
    notIn: arg({
      type: list(nonNull(Float$2))
    }),
    lt: arg({
      type: Float$2
    }),
    lte: arg({
      type: Float$2
    }),
    gt: arg({
      type: Float$2
    }),
    gte: arg({
      type: Float$2
    }),
    // can be null
    not: arg({
      type: FloatNullableFilter
    })
  })
});
const FloatFilter = inputObject({
  name: 'FloatFilter',
  fields: () => ({
    equals: arg({
      type: Float$2
    }),
    in: arg({
      type: list(nonNull(Float$2))
    }),
    notIn: arg({
      type: list(nonNull(Float$2))
    }),
    lt: arg({
      type: Float$2
    }),
    lte: arg({
      type: Float$2
    }),
    gt: arg({
      type: Float$2
    }),
    gte: arg({
      type: Float$2
    }),
    not: arg({
      type: FloatFilter
    })
  })
});
const DateTimeNullableFilter = inputObject({
  name: 'DateTimeNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: String$2
    }),
    // can be null
    in: arg({
      type: list(nonNull(String$2))
    }),
    // can be null
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    // can be null
    not: arg({
      type: DateTimeNullableFilter
    })
  })
});
const DateTimeFilter = inputObject({
  name: 'DateTimeFilter',
  fields: () => ({
    equals: arg({
      type: String$2
    }),
    in: arg({
      type: list(nonNull(String$2))
    }),
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    not: arg({
      type: DateTimeFilter
    })
  })
});
const DecimalNullableFilter = inputObject({
  name: 'DecimalNullableFilter',
  fields: () => ({
    // can be null
    equals: arg({
      type: String$2
    }),
    // can be null
    in: arg({
      type: list(nonNull(String$2))
    }),
    // can be null
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    // can be null
    not: arg({
      type: DecimalNullableFilter
    })
  })
});
const DecimalFilter = inputObject({
  name: 'DecimalFilter',
  fields: () => ({
    equals: arg({
      type: String$2
    }),
    in: arg({
      type: list(nonNull(String$2))
    }),
    notIn: arg({
      type: list(nonNull(String$2))
    }),
    lt: arg({
      type: String$2
    }),
    lte: arg({
      type: String$2
    }),
    gt: arg({
      type: String$2
    }),
    gte: arg({
      type: String$2
    }),
    not: arg({
      type: DecimalFilter
    })
  })
});
const String = {
  optional: StringNullableFilter,
  required: StringFilter
};
const Boolean = {
  optional: BoolNullableFilter,
  required: BoolFilter
};
const Int = {
  optional: IntNullableFilter,
  required: IntFilter
};
const Float = {
  optional: FloatNullableFilter,
  required: FloatFilter
};
const DateTime = {
  optional: DateTimeNullableFilter,
  required: DateTimeFilter
};
const Decimal = {
  optional: DecimalNullableFilter,
  required: DecimalFilter
};

var sqlite = /*#__PURE__*/Object.freeze({
  __proto__: null,
  String: String,
  Boolean: Boolean,
  Int: Int,
  Float: Float,
  DateTime: DateTime,
  Decimal: Decimal,
  'enum': enumFilters
});

export { JSON as J, QueryMode as Q, Upload as U, fieldType as f, graphqlBoundToKeystoneContext as g, orderDirectionEnum as o, postgresql as p, sqlite as s };
