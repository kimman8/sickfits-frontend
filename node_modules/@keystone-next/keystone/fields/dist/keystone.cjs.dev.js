'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var sqlite = require('../../dist/sqlite-b63545bc.cjs.dev.js');
var jsonFieldTypePolyfillForSqlite = require('../../dist/json-field-type-polyfill-for-sqlite-634a3dbe.cjs.dev.js');
var Path = require('path');
var packagePath = require('../../dist/package-path-d511a573.cjs.dev.js');
var apiWithoutContext = require('@graphql-ts/schema/api-without-context');
var apiWithContext = require('@graphql-ts/schema/api-with-context');
var Decimal = require('decimal.js');
var fields_types_file_utils_dist_keystone = require('../types/file/utils/dist/keystone.cjs.dev.js');
var fields_types_image_utils_dist_keystone = require('../types/image/utils/dist/keystone.cjs.dev.js');
var bcryptjs = require('bcryptjs');
var dumbPasswords = require('dumb-passwords');
var inflection = require('inflection');
require('@graphql-ts/schema');
require('graphql-type-json');
require('graphql-upload/public/GraphQLUpload.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var Path__default = /*#__PURE__*/_interopDefault(Path);
var Decimal__default = /*#__PURE__*/_interopDefault(Decimal);
var bcryptjs__default = /*#__PURE__*/_interopDefault(bcryptjs);
var dumbPasswords__default = /*#__PURE__*/_interopDefault(dumbPasswords);
var inflection__default = /*#__PURE__*/_interopDefault(inflection);

const resolveView = pathname => Path__default['default'].join(packagePath.packagePath, 'fields', 'types', pathname);

const _excluded$d = ["isRequired", "defaultValue", "isIndexed"];
const autoIncrement = (_ref = {}) => {
  let {
    isRequired,
    defaultValue,
    isIndexed
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded$d);

  return meta => {
    return sqlite.fieldType({
      kind: 'scalar',
      mode: 'optional',
      scalar: 'Int',
      default: {
        kind: 'autoincrement'
      },
      index: isIndexed === true ? 'index' : isIndexed || undefined
    })(_objectSpread(_objectSpread({}, config), {}, {
      input: {
        // create
        create: {
          arg: apiWithoutContext.arg({
            type: apiWithoutContext.Int
          })
        },
        // update
        update: {
          arg: apiWithoutContext.arg({
            type: apiWithoutContext.Int
          })
        },
        // filter
        where: {
          arg: apiWithoutContext.arg({
            type: jsonFieldTypePolyfillForSqlite.filters[meta.provider].Int.optional
          }),
          resolve: jsonFieldTypePolyfillForSqlite.resolveCommon
        },
        uniqueWhere: isIndexed === 'unique' ? {
          arg: apiWithoutContext.arg({
            type: apiWithoutContext.Int
          })
        } : undefined,
        // orderBy
        orderBy: {
          arg: apiWithoutContext.arg({
            type: sqlite.orderDirectionEnum
          })
        }
      },
      // read
      output: apiWithContext.field({
        type: apiWithoutContext.Int
      }),
      views: resolveView('integer/views'),
      __legacy: {
        isRequired,
        defaultValue
      }
    }));
  };
};

const _excluded$c = ["isRequired", "defaultValue"];
const checkbox = (_ref = {}) => {
  let {
    isRequired,
    defaultValue
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded$c);

  return meta => {
    if (config.isIndexed === 'unique') {
      throw Error("isIndexed: 'unique' is not a supported option for field type checkbox");
    }

    return sqlite.fieldType({
      kind: 'scalar',
      mode: 'optional',
      scalar: 'Boolean'
    })(_objectSpread(_objectSpread({}, config), {}, {
      input: {
        where: {
          arg: apiWithoutContext.arg({
            type: jsonFieldTypePolyfillForSqlite.filters[meta.provider].Boolean.optional
          }),
          resolve: jsonFieldTypePolyfillForSqlite.resolveCommon
        },
        create: {
          arg: apiWithoutContext.arg({
            type: apiWithoutContext.Boolean
          })
        },
        update: {
          arg: apiWithoutContext.arg({
            type: apiWithoutContext.Boolean
          })
        },
        orderBy: {
          arg: apiWithoutContext.arg({
            type: sqlite.orderDirectionEnum
          })
        }
      },
      output: apiWithContext.field({
        type: apiWithoutContext.Boolean
      }),
      views: resolveView('checkbox/views'),
      __legacy: {
        isRequired,
        defaultValue
      }
    }));
  };
};

const _excluded$b = ["isIndexed", "precision", "scale", "isRequired", "defaultValue"];
const decimal = (_ref = {}) => {
  let {
    isIndexed,
    precision = 18,
    scale = 4,
    isRequired,
    defaultValue
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded$b);

  return meta => {
    if (meta.provider === 'sqlite') {
      throw new Error('The decimal field does not support sqlite');
    }

    if (!Number.isInteger(scale)) {
      throw new Error(`The scale for decimal fields must be an integer but the scale for the decimal field at ${meta.listKey}.${meta.fieldKey} is not an integer`);
    }

    if (!Number.isInteger(precision)) {
      throw new Error(`The precision for decimal fields must be an integer but the precision for the decimal field at ${meta.listKey}.${meta.fieldKey} is not an integer`);
    }

    if (scale > precision) {
      throw new Error(`The scale configured for decimal field at ${meta.listKey}.${meta.fieldKey} (${scale}) ` + `must not be larger than the field's precision (${precision})`);
    }

    const index = isIndexed === true ? 'index' : isIndexed || undefined;
    const dbField = {
      kind: 'scalar',
      mode: 'optional',
      scalar: 'Decimal',
      nativeType: `Decimal(${precision}, ${scale})`,
      index
    };
    return sqlite.fieldType(dbField)(_objectSpread(_objectSpread({}, config), {}, {
      input: {
        where: {
          arg: apiWithoutContext.arg({
            type: jsonFieldTypePolyfillForSqlite.filters[meta.provider].Decimal.optional
          }),
          resolve: jsonFieldTypePolyfillForSqlite.resolveCommon
        },
        create: {
          arg: apiWithoutContext.arg({
            type: apiWithoutContext.String
          }),

          resolve(val) {
            if (val == null) return val;
            return new Decimal__default['default'](val);
          }

        },
        update: {
          arg: apiWithoutContext.arg({
            type: apiWithoutContext.String
          }),

          resolve(val) {
            if (val == null) return val;
            return new Decimal__default['default'](val);
          }

        },
        orderBy: {
          arg: apiWithoutContext.arg({
            type: sqlite.orderDirectionEnum
          })
        }
      },
      output: apiWithContext.field({
        type: apiWithoutContext.String,

        resolve({
          value
        }) {
          if (value === null) return null;
          return value.toFixed(scale);
        }

      }),
      views: resolveView('decimal/views'),
      getAdminMeta: () => ({
        precision,
        scale
      }),
      __legacy: {
        isRequired,
        defaultValue
      }
    }));
  };
};

const _excluded$a = ["isRequired", "defaultValue"];
const FileFieldInput = apiWithoutContext.inputObject({
  name: 'FileFieldInput',
  fields: {
    upload: apiWithoutContext.arg({
      type: sqlite.Upload
    }),
    ref: apiWithoutContext.arg({
      type: apiWithoutContext.String
    })
  }
});
const fileFields = apiWithContext.fields()({
  filename: apiWithContext.field({
    type: apiWithoutContext.nonNull(apiWithoutContext.String)
  }),
  filesize: apiWithContext.field({
    type: apiWithoutContext.nonNull(apiWithoutContext.Int)
  }),
  ref: apiWithContext.field({
    type: apiWithoutContext.nonNull(apiWithoutContext.String),

    resolve(data) {
      return fields_types_file_utils_dist_keystone.getFileRef(data.mode, data.filename);
    }

  }),
  src: apiWithContext.field({
    type: apiWithoutContext.nonNull(apiWithoutContext.String),

    resolve(data, args, context) {
      if (!context.files) {
        throw new Error('File context is undefined, this most likely means that you havent configurd keystone with a file config, see https://keystonejs.com/docs/apis/config#files for details');
      }

      return context.files.getSrc(data.mode, data.filename);
    }

  })
});
const FileFieldOutput = apiWithContext['interface']()({
  name: 'FileFieldOutput',
  fields: fileFields,
  resolveType: () => 'LocalFileFieldOutput'
});
const LocalFileFieldOutput = apiWithContext.object()({
  name: 'LocalFileFieldOutput',
  interfaces: [FileFieldOutput],
  fields: fileFields
});

async function inputResolver$1(data, context) {
  if (data === null || data === undefined) {
    return {
      mode: data,
      filename: data,
      filesize: data
    };
  }

  if (data.ref) {
    if (data.upload) {
      throw new Error('Only one of ref and upload can be passed to FileFieldInput');
    }

    return context.files.getDataFromRef(data.ref);
  }

  if (!data.upload) {
    throw new Error('Either ref or upload must be passed to FileFieldInput');
  }

  const upload = await data.upload;
  return context.files.getDataFromStream(upload.createReadStream(), upload.filename);
}

const file = (_ref = {}) => {
  let {
    isRequired,
    defaultValue
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded$a);

  return () => {
    if (config.isIndexed === 'unique') {
      throw Error("isIndexed: 'unique' is not a supported option for field type file");
    }

    return sqlite.fieldType({
      kind: 'multi',
      fields: {
        filesize: {
          kind: 'scalar',
          scalar: 'Int',
          mode: 'optional'
        },
        mode: {
          kind: 'scalar',
          scalar: 'String',
          mode: 'optional'
        },
        filename: {
          kind: 'scalar',
          scalar: 'String',
          mode: 'optional'
        }
      }
    })(_objectSpread(_objectSpread({}, config), {}, {
      input: {
        create: {
          arg: apiWithoutContext.arg({
            type: FileFieldInput
          }),
          resolve: inputResolver$1
        },
        update: {
          arg: apiWithoutContext.arg({
            type: FileFieldInput
          }),
          resolve: inputResolver$1
        }
      },
      output: apiWithContext.field({
        type: FileFieldOutput,

        resolve({
          value: {
            filesize,
            filename,
            mode
          }
        }) {
          if (filesize === null || filename === null || mode === null || mode !== 'local' && mode !== 'keystone-cloud') {
            return null;
          }

          return {
            mode,
            filename,
            filesize
          };
        }

      }),
      unreferencedConcreteInterfaceImplementations: [LocalFileFieldOutput],
      views: resolveView('file/views'),
      __legacy: {
        isRequired,
        defaultValue
      }
    }));
  };
};

const _excluded$9 = ["isIndexed", "isRequired", "defaultValue"];
const float = (_ref = {}) => {
  let {
    isIndexed,
    isRequired,
    defaultValue
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded$9);

  return meta => sqlite.fieldType({
    kind: 'scalar',
    mode: 'optional',
    scalar: 'Float',
    index: isIndexed === true ? 'index' : isIndexed || undefined
  })(_objectSpread(_objectSpread({}, config), {}, {
    input: {
      where: {
        arg: apiWithoutContext.arg({
          type: jsonFieldTypePolyfillForSqlite.filters[meta.provider].Float.optional
        }),
        resolve: jsonFieldTypePolyfillForSqlite.resolveCommon
      },
      create: {
        arg: apiWithoutContext.arg({
          type: apiWithoutContext.Float
        })
      },
      update: {
        arg: apiWithoutContext.arg({
          type: apiWithoutContext.Float
        })
      },
      orderBy: {
        arg: apiWithoutContext.arg({
          type: sqlite.orderDirectionEnum
        })
      }
    },
    output: apiWithContext.field({
      type: apiWithoutContext.Float
    }),
    views: resolveView('float/views'),
    __legacy: {
      isRequired,
      defaultValue
    }
  }));
};

const _excluded$8 = ["isIndexed", "isRequired", "defaultValue"];
const integer = (_ref = {}) => {
  let {
    isIndexed,
    isRequired,
    defaultValue
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded$8);

  return meta => sqlite.fieldType({
    kind: 'scalar',
    mode: 'optional',
    scalar: 'Int',
    index: isIndexed === true ? 'index' : isIndexed || undefined
  })(_objectSpread(_objectSpread({}, config), {}, {
    input: {
      uniqueWhere: isIndexed === 'unique' ? {
        arg: apiWithoutContext.arg({
          type: apiWithoutContext.Int
        })
      } : undefined,
      where: {
        arg: apiWithoutContext.arg({
          type: jsonFieldTypePolyfillForSqlite.filters[meta.provider].Int.optional
        }),
        resolve: jsonFieldTypePolyfillForSqlite.resolveCommon
      },
      create: {
        arg: apiWithoutContext.arg({
          type: apiWithoutContext.Int
        })
      },
      update: {
        arg: apiWithoutContext.arg({
          type: apiWithoutContext.Int
        })
      },
      orderBy: {
        arg: apiWithoutContext.arg({
          type: sqlite.orderDirectionEnum
        })
      }
    },
    output: apiWithContext.field({
      type: apiWithoutContext.Int
    }),
    views: resolveView('integer/views'),
    __legacy: {
      isRequired,
      defaultValue
    }
  }));
};

const _excluded$7 = ["isRequired", "defaultValue"];
const ImageExtensionEnum = apiWithoutContext['enum']({
  name: 'ImageExtension',
  values: apiWithoutContext.enumValues(fields_types_image_utils_dist_keystone.SUPPORTED_IMAGE_EXTENSIONS)
});
const ImageFieldInput = apiWithoutContext.inputObject({
  name: 'ImageFieldInput',
  fields: {
    upload: apiWithoutContext.arg({
      type: sqlite.Upload
    }),
    ref: apiWithoutContext.arg({
      type: apiWithoutContext.String
    })
  }
});
const imageOutputFields = apiWithContext.fields()({
  id: apiWithContext.field({
    type: apiWithoutContext.nonNull(apiWithoutContext.ID)
  }),
  filesize: apiWithContext.field({
    type: apiWithoutContext.nonNull(apiWithoutContext.Int)
  }),
  width: apiWithContext.field({
    type: apiWithoutContext.nonNull(apiWithoutContext.Int)
  }),
  height: apiWithContext.field({
    type: apiWithoutContext.nonNull(apiWithoutContext.Int)
  }),
  extension: apiWithContext.field({
    type: apiWithoutContext.nonNull(ImageExtensionEnum)
  }),
  ref: apiWithContext.field({
    type: apiWithoutContext.nonNull(apiWithoutContext.String),

    resolve(data) {
      return fields_types_image_utils_dist_keystone.getImageRef(data.mode, data.id, data.extension);
    }

  }),
  src: apiWithContext.field({
    type: apiWithoutContext.nonNull(apiWithoutContext.String),

    resolve(data, args, context) {
      if (!context.images) {
        throw new Error('Image context is undefined');
      }

      return context.images.getSrc(data.mode, data.id, data.extension);
    }

  })
});
const ImageFieldOutput = apiWithContext['interface']()({
  name: 'ImageFieldOutput',
  fields: imageOutputFields,
  resolveType: () => 'LocalImageFieldOutput'
});
const LocalImageFieldOutput = apiWithContext.object()({
  name: 'LocalImageFieldOutput',
  interfaces: [ImageFieldOutput],
  fields: imageOutputFields
});

async function inputResolver(data, context) {
  if (data === null || data === undefined) {
    return {
      extension: data,
      filesize: data,
      height: data,
      id: data,
      mode: data,
      width: data
    };
  }

  if (data.ref) {
    if (data.upload) {
      throw new Error('Only one of ref and upload can be passed to ImageFieldInput');
    }

    return context.images.getDataFromRef(data.ref);
  }

  if (!data.upload) {
    throw new Error('Either ref or upload must be passed to ImageFieldInput');
  }

  return context.images.getDataFromStream((await data.upload).createReadStream());
}

const extensionsSet = new Set(fields_types_image_utils_dist_keystone.SUPPORTED_IMAGE_EXTENSIONS);

function isValidImageExtension(extension) {
  return extensionsSet.has(extension);
}

const image = (_ref = {}) => {
  let {
    isRequired,
    defaultValue
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded$7);

  return () => {
    if (config.isIndexed === 'unique') {
      throw Error("isIndexed: 'unique' is not a supported option for field type image");
    }

    return sqlite.fieldType({
      kind: 'multi',
      fields: {
        filesize: {
          kind: 'scalar',
          scalar: 'Int',
          mode: 'optional'
        },
        extension: {
          kind: 'scalar',
          scalar: 'String',
          mode: 'optional'
        },
        width: {
          kind: 'scalar',
          scalar: 'Int',
          mode: 'optional'
        },
        height: {
          kind: 'scalar',
          scalar: 'Int',
          mode: 'optional'
        },
        mode: {
          kind: 'scalar',
          scalar: 'String',
          mode: 'optional'
        },
        id: {
          kind: 'scalar',
          scalar: 'String',
          mode: 'optional'
        }
      }
    })(_objectSpread(_objectSpread({}, config), {}, {
      input: {
        create: {
          arg: apiWithoutContext.arg({
            type: ImageFieldInput
          }),
          resolve: inputResolver
        },
        update: {
          arg: apiWithoutContext.arg({
            type: ImageFieldInput
          }),
          resolve: inputResolver
        }
      },
      output: apiWithContext.field({
        type: ImageFieldOutput,

        resolve({
          value: {
            extension,
            filesize,
            height,
            id,
            mode,
            width
          }
        }) {
          if (extension === null || !isValidImageExtension(extension) || filesize === null || height === null || width === null || id === null || mode === null || mode !== 'local' && mode !== 'keystone-cloud') {
            return null;
          }

          return {
            mode,
            extension,
            filesize,
            height,
            width,
            id
          };
        }

      }),
      unreferencedConcreteInterfaceImplementations: [LocalImageFieldOutput],
      views: resolveView('image/views'),
      __legacy: {
        isRequired,
        defaultValue
      }
    }));
  };
};

const _excluded$6 = ["isRequired", "defaultValue"];
const json = (_ref = {}) => {
  let {
    isRequired,
    defaultValue
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded$6);

  return meta => {
    if (config.isIndexed === 'unique') {
      throw Error("isIndexed: 'unique' is not a supported option for field type json");
    }

    return jsonFieldTypePolyfillForSqlite.jsonFieldTypePolyfilledForSQLite(meta.provider, _objectSpread(_objectSpread({}, config), {}, {
      input: {
        create: {
          arg: apiWithoutContext.arg({
            type: sqlite.JSON
          })
        },
        update: {
          arg: apiWithoutContext.arg({
            type: sqlite.JSON
          })
        }
      },
      output: apiWithContext.field({
        type: sqlite.JSON
      }),
      views: resolveView('json/views'),
      __legacy: {
        defaultValue,
        isRequired
      }
    }));
  };
};

const _excluded$5 = ["bcrypt", "minLength", "workFactor", "rejectCommon", "isRequired", "defaultValue"];
const PasswordState = apiWithContext.object()({
  name: 'PasswordState',
  fields: {
    isSet: apiWithContext.field({
      type: apiWithoutContext.nonNull(apiWithoutContext.Boolean)
    })
  }
});
const PasswordFilter = apiWithoutContext.inputObject({
  name: 'PasswordFilter',
  fields: {
    isSet: apiWithoutContext.arg({
      type: apiWithoutContext.nonNull(apiWithoutContext.Boolean)
    })
  }
});
const bcryptHashRegex = /^\$2[aby]?\$\d{1,2}\$[.\/A-Za-z0-9]{53}$/;
const password = (_ref = {}) => {
  let {
    bcrypt = bcryptjs__default['default'],
    minLength = 8,
    workFactor = 10,
    rejectCommon = false,
    isRequired,
    defaultValue
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded$5);

  return meta => {
    // TODO: we should just throw not automatically fix it, yeah?
    workFactor = Math.min(Math.max(workFactor, 4), 31);

    if (workFactor < 6) {
      console.warn(`The workFactor for ${meta.listKey}.${meta.fieldKey} is very low! ` + `This will cause weak hashes!`);
    }

    function inputResolver(val) {
      if (val === '') {
        return null;
      }

      if (typeof val === 'string') {
        if (rejectCommon && dumbPasswords__default['default'].check(val)) {
          throw new Error(`[password:rejectCommon:${meta.listKey}:${meta.fieldKey}] Common and frequently-used passwords are not allowed.`);
        }

        if (val.length < minLength) {
          throw new Error(`[password:minLength:${meta.listKey}:${meta.fieldKey}] Value must be at least ${minLength} characters long.`);
        }

        return bcrypt.hash(val, workFactor);
      }

      return val;
    }

    if (config.isIndexed === 'unique') {
      throw Error("isIndexed: 'unique' is not a supported option for field type password");
    }

    return sqlite.fieldType({
      kind: 'scalar',
      scalar: 'String',
      mode: 'optional'
    })(_objectSpread(_objectSpread({}, config), {}, {
      input: {
        where: {
          arg: apiWithoutContext.arg({
            type: PasswordFilter
          }),

          resolve(val) {
            if (val === null) {
              throw new Error('Password filters cannot be set to null');
            }

            if (val.isSet) {
              return {
                not: null
              };
            }

            return null;
          }

        },
        create: {
          arg: apiWithoutContext.arg({
            type: apiWithoutContext.String
          }),
          resolve: inputResolver
        },
        update: {
          arg: apiWithoutContext.arg({
            type: apiWithoutContext.String
          }),
          resolve: inputResolver
        }
      },
      views: resolveView('password/views'),
      getAdminMeta: () => ({
        minLength: minLength
      }),
      output: apiWithContext.field({
        type: PasswordState,

        resolve(val) {
          return {
            isSet: val.value !== null && bcryptHashRegex.test(val.value)
          };
        },

        extensions: {
          keystoneSecretField: {
            generateHash: async secret => {
              return bcrypt.hash(secret, workFactor);
            },
            compare: (secret, hash) => {
              return bcrypt.compare(secret, hash);
            }
          }
        }
      }),
      __legacy: {
        isRequired,
        defaultValue
      }
    }));
  };
};

const _excluded$4 = ["many", "ref", "defaultValue", "withMeta"];

const relationship = _ref => {
  let {
    many = false,
    ref,
    defaultValue,
    withMeta = true
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded$4);

  return meta => {
    const [foreignListKey, foreignFieldKey] = ref.split('.');

    const commonConfig = _objectSpread(_objectSpread({}, config), {}, {
      views: resolveView('relationship/views'),
      getAdminMeta: adminMetaRoot => {
        var _config$ui, _config$ui$hideCreate, _config$ui2, _config$ui3, _config$ui$linkToItem, _config$ui$removeMode, _config$ui$inlineCrea3, _config$ui$inlineEdit3, _config$ui$inlineConn, _config$ui4;

        if (!meta.lists[foreignListKey]) {
          throw new Error(`The ref [${ref}] on relationship [${meta.listKey}.${meta.fieldKey}] is invalid`);
        }

        if (((_config$ui = config.ui) === null || _config$ui === void 0 ? void 0 : _config$ui.displayMode) === 'cards') {
          // we're checking whether the field which will be in the admin meta at the time that getAdminMeta is called.
          // in newer versions of keystone, it will be there and it will not be there for older versions of keystone.
          // this is so that relationship fields doesn't break in confusing ways
          // if people are using a slightly older version of keystone
          const currentField = adminMetaRoot.listsByKey[meta.listKey].fields.find(x => x.path === meta.fieldKey);

          if (currentField) {
            const allForeignFields = new Set(adminMetaRoot.listsByKey[foreignListKey].fields.map(x => x.path));

            for (const [configOption, foreignFields] of [['ui.cardFields', config.ui.cardFields], ['ui.inlineCreate.fields', (_config$ui$inlineCrea = (_config$ui$inlineCrea2 = config.ui.inlineCreate) === null || _config$ui$inlineCrea2 === void 0 ? void 0 : _config$ui$inlineCrea2.fields) !== null && _config$ui$inlineCrea !== void 0 ? _config$ui$inlineCrea : []], ['ui.inlineEdit.fields', (_config$ui$inlineEdit = (_config$ui$inlineEdit2 = config.ui.inlineEdit) === null || _config$ui$inlineEdit2 === void 0 ? void 0 : _config$ui$inlineEdit2.fields) !== null && _config$ui$inlineEdit !== void 0 ? _config$ui$inlineEdit : []]]) {
              var _config$ui$inlineCrea, _config$ui$inlineCrea2, _config$ui$inlineEdit, _config$ui$inlineEdit2;

              for (const foreignField of foreignFields) {
                if (!allForeignFields.has(foreignField)) {
                  throw new Error(`The ${configOption} option on the relationship field at ${meta.listKey}.${meta.fieldKey} includes the "${foreignField}" field but that field does not exist on the "${foreignListKey}" list`);
                }
              }
            }
          }
        }

        return _objectSpread({
          refListKey: foreignListKey,
          many,
          hideCreate: (_config$ui$hideCreate = (_config$ui2 = config.ui) === null || _config$ui2 === void 0 ? void 0 : _config$ui2.hideCreate) !== null && _config$ui$hideCreate !== void 0 ? _config$ui$hideCreate : false
        }, ((_config$ui3 = config.ui) === null || _config$ui3 === void 0 ? void 0 : _config$ui3.displayMode) === 'cards' ? {
          displayMode: 'cards',
          cardFields: config.ui.cardFields,
          linkToItem: (_config$ui$linkToItem = config.ui.linkToItem) !== null && _config$ui$linkToItem !== void 0 ? _config$ui$linkToItem : false,
          removeMode: (_config$ui$removeMode = config.ui.removeMode) !== null && _config$ui$removeMode !== void 0 ? _config$ui$removeMode : 'disconnect',
          inlineCreate: (_config$ui$inlineCrea3 = config.ui.inlineCreate) !== null && _config$ui$inlineCrea3 !== void 0 ? _config$ui$inlineCrea3 : null,
          inlineEdit: (_config$ui$inlineEdit3 = config.ui.inlineEdit) !== null && _config$ui$inlineEdit3 !== void 0 ? _config$ui$inlineEdit3 : null,
          inlineConnect: (_config$ui$inlineConn = config.ui.inlineConnect) !== null && _config$ui$inlineConn !== void 0 ? _config$ui$inlineConn : false,
          refLabelField: adminMetaRoot.listsByKey[foreignListKey].labelField
        } : ((_config$ui4 = config.ui) === null || _config$ui4 === void 0 ? void 0 : _config$ui4.displayMode) === 'count' ? {
          displayMode: 'count'
        } : {
          displayMode: 'select',
          refLabelField: adminMetaRoot.listsByKey[foreignListKey].labelField
        });
      }
    });

    if (!meta.lists[foreignListKey]) {
      throw new Error(`Unable to resolve related list '${foreignListKey}' from ${meta.listKey}.${meta.fieldKey}`);
    }

    const listTypes = meta.lists[foreignListKey].types;

    if (many) {
      return sqlite.fieldType({
        kind: 'relation',
        mode: 'many',
        list: foreignListKey,
        field: foreignFieldKey
      })(_objectSpread(_objectSpread({}, commonConfig), {}, {
        input: {
          where: {
            arg: apiWithoutContext.arg({
              type: listTypes.relateTo.many.where
            }),

            resolve(value, context, resolve) {
              return resolve(value);
            }

          },
          create: listTypes.relateTo.many.create && {
            arg: apiWithoutContext.arg({
              type: listTypes.relateTo.many.create
            }),

            async resolve(value, context, resolve) {
              return resolve(value);
            }

          },
          update: listTypes.relateTo.many.update && {
            arg: apiWithoutContext.arg({
              type: listTypes.relateTo.many.update
            }),

            async resolve(value, context, resolve) {
              return resolve(value);
            }

          }
        },
        output: apiWithContext.field({
          args: listTypes.findManyArgs,
          type: apiWithoutContext.list(apiWithoutContext.nonNull(listTypes.output)),

          resolve({
            value
          }, args) {
            return value.findMany(args);
          }

        }),
        extraOutputFields: withMeta ? {
          [`${meta.fieldKey}Count`]: apiWithContext.field({
            type: apiWithoutContext.Int,
            args: {
              where: apiWithoutContext.arg({
                type: apiWithoutContext.nonNull(listTypes.where),
                defaultValue: {}
              })
            },

            resolve({
              value
            }, args) {
              return value.count({
                where: args.where
              });
            }

          })
        } : {},
        __legacy: {
          defaultValue
        }
      }));
    }

    return sqlite.fieldType({
      kind: 'relation',
      mode: 'one',
      list: foreignListKey,
      field: foreignFieldKey
    })(_objectSpread(_objectSpread({}, commonConfig), {}, {
      input: {
        where: {
          arg: apiWithoutContext.arg({
            type: listTypes.where
          }),

          resolve(value, context, resolve) {
            return resolve(value);
          }

        },
        create: listTypes.relateTo.one.create && {
          arg: apiWithoutContext.arg({
            type: listTypes.relateTo.one.create
          }),

          async resolve(value, context, resolve) {
            return resolve(value);
          }

        },
        update: listTypes.relateTo.one.update && {
          arg: apiWithoutContext.arg({
            type: listTypes.relateTo.one.update
          }),

          async resolve(value, context, resolve) {
            return resolve(value);
          }

        }
      },
      output: apiWithContext.field({
        type: listTypes.output,

        resolve({
          value
        }) {
          return value();
        }

      }),
      __legacy: {
        defaultValue
      }
    }));
  };
};

const _excluded$3 = ["displayMode"],
      _excluded2 = ["isIndexed", "ui", "isRequired", "defaultValue"];
const select = _ref => {
  let {
    isIndexed,
    ui: {
      displayMode = 'select'
    } = {},
    isRequired,
    defaultValue
  } = _ref,
      ui = _objectWithoutProperties(_ref.ui, _excluded$3),
      config = _objectWithoutProperties(_ref, _excluded2);

  return meta => {
    const commonConfig = _objectSpread(_objectSpread({}, config), {}, {
      ui,
      views: resolveView('select/views'),
      getAdminMeta: () => {
        var _config$dataType;

        return {
          options: config.options,
          dataType: (_config$dataType = config.dataType) !== null && _config$dataType !== void 0 ? _config$dataType : 'string',
          displayMode: displayMode
        };
      }
    });

    const index = isIndexed === true ? 'index' : isIndexed || undefined;

    if (config.dataType === 'integer') {
      return sqlite.fieldType({
        kind: 'scalar',
        scalar: 'Int',
        mode: 'optional',
        index
      })(_objectSpread(_objectSpread({}, commonConfig), {}, {
        input: {
          where: {
            arg: apiWithoutContext.arg({
              type: jsonFieldTypePolyfillForSqlite.filters[meta.provider].Int.optional
            }),
            resolve: jsonFieldTypePolyfillForSqlite.resolveCommon
          },
          create: {
            arg: apiWithoutContext.arg({
              type: apiWithoutContext.Int
            })
          },
          update: {
            arg: apiWithoutContext.arg({
              type: apiWithoutContext.Int
            })
          },
          orderBy: {
            arg: apiWithoutContext.arg({
              type: sqlite.orderDirectionEnum
            })
          }
        },
        output: apiWithContext.field({
          type: apiWithoutContext.Int
        }),
        __legacy: {
          defaultValue,
          isRequired
        }
      }));
    }

    if (config.dataType === 'enum') {
      const enumName = `${meta.listKey}${inflection__default['default'].classify(meta.fieldKey)}Type`;
      const graphQLType = apiWithoutContext['enum']({
        name: enumName,
        values: apiWithoutContext.enumValues(config.options.map(x => x.value))
      }); // i do not like this "let's just magically use strings on sqlite"

      return sqlite.fieldType(meta.provider === 'sqlite' ? {
        kind: 'scalar',
        scalar: 'String',
        mode: 'optional',
        index
      } : {
        kind: 'enum',
        values: config.options.map(x => x.value),
        mode: 'optional',
        name: enumName,
        index
      })(_objectSpread(_objectSpread({}, commonConfig), {}, {
        input: {
          where: {
            arg: apiWithoutContext.arg({
              type: jsonFieldTypePolyfillForSqlite.filters[meta.provider].enum(graphQLType).optional
            }),
            resolve: jsonFieldTypePolyfillForSqlite.resolveCommon
          },
          create: {
            arg: apiWithoutContext.arg({
              type: graphQLType
            })
          },
          update: {
            arg: apiWithoutContext.arg({
              type: graphQLType
            })
          },
          orderBy: {
            arg: apiWithoutContext.arg({
              type: sqlite.orderDirectionEnum
            })
          }
        },
        output: apiWithContext.field({
          type: graphQLType
        }),
        __legacy: {
          defaultValue,
          isRequired
        }
      }));
    }

    return sqlite.fieldType({
      kind: 'scalar',
      scalar: 'String',
      mode: 'optional',
      index
    })(_objectSpread(_objectSpread({}, commonConfig), {}, {
      input: {
        where: {
          arg: apiWithoutContext.arg({
            type: jsonFieldTypePolyfillForSqlite.filters[meta.provider].String.optional
          }),
          resolve: jsonFieldTypePolyfillForSqlite.resolveString
        },
        create: {
          arg: apiWithoutContext.arg({
            type: apiWithoutContext.String
          })
        },
        update: {
          arg: apiWithoutContext.arg({
            type: apiWithoutContext.String
          })
        },
        orderBy: {
          arg: apiWithoutContext.arg({
            type: sqlite.orderDirectionEnum
          })
        }
      },
      output: apiWithContext.field({
        type: apiWithoutContext.String
      }),
      __legacy: {
        defaultValue,
        isRequired
      }
    }));
  };
};

const _excluded$2 = ["isIndexed", "isRequired", "defaultValue"];
const text = (_ref = {}) => {
  let {
    isIndexed,
    isRequired,
    defaultValue
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded$2);

  return meta => sqlite.fieldType({
    kind: 'scalar',
    mode: 'optional',
    scalar: 'String',
    index: isIndexed === true ? 'index' : isIndexed || undefined
  })(_objectSpread(_objectSpread({}, config), {}, {
    input: {
      uniqueWhere: isIndexed === 'unique' ? {
        arg: apiWithoutContext.arg({
          type: apiWithoutContext.String
        })
      } : undefined,
      where: {
        arg: apiWithoutContext.arg({
          type: jsonFieldTypePolyfillForSqlite.filters[meta.provider].String.optional
        }),
        resolve: jsonFieldTypePolyfillForSqlite.resolveString
      },
      create: {
        arg: apiWithoutContext.arg({
          type: apiWithoutContext.String
        })
      },
      update: {
        arg: apiWithoutContext.arg({
          type: apiWithoutContext.String
        })
      },
      orderBy: {
        arg: apiWithoutContext.arg({
          type: sqlite.orderDirectionEnum
        })
      }
    },
    output: apiWithContext.field({
      type: apiWithoutContext.String
    }),
    views: resolveView('text/views'),

    getAdminMeta() {
      var _config$ui$displayMod, _config$ui;

      return {
        displayMode: (_config$ui$displayMod = (_config$ui = config.ui) === null || _config$ui === void 0 ? void 0 : _config$ui.displayMode) !== null && _config$ui$displayMod !== void 0 ? _config$ui$displayMod : 'input',
        shouldUseModeInsensitive: meta.provider === 'postgresql'
      };
    },

    __legacy: {
      defaultValue,
      isRequired
    }
  }));
};

const _excluded$1 = ["isIndexed", "isRequired", "defaultValue"];
const timestamp = (_ref = {}) => {
  let {
    isIndexed,
    isRequired,
    defaultValue
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded$1);

  return meta => {
    const inputResolver = value => {
      if (value === null || value === undefined) {
        return value;
      }

      return new Date(value);
    };

    return sqlite.fieldType({
      kind: 'scalar',
      mode: 'optional',
      scalar: 'DateTime',
      index: isIndexed === true ? 'index' : isIndexed || undefined
    })(_objectSpread(_objectSpread({}, config), {}, {
      input: {
        where: {
          arg: apiWithoutContext.arg({
            type: jsonFieldTypePolyfillForSqlite.filters[meta.provider].DateTime.optional
          }),
          resolve: jsonFieldTypePolyfillForSqlite.resolveCommon
        },
        create: {
          arg: apiWithoutContext.arg({
            type: apiWithoutContext.String
          }),
          resolve: inputResolver
        },
        update: {
          arg: apiWithoutContext.arg({
            type: apiWithoutContext.String
          }),
          resolve: inputResolver
        },
        orderBy: {
          arg: apiWithoutContext.arg({
            type: sqlite.orderDirectionEnum
          })
        }
      },
      output: apiWithContext.field({
        type: apiWithoutContext.String,

        resolve({
          value
        }) {
          if (value === null) return null;
          return value.toISOString();
        }

      }),
      views: resolveView('timestamp/views'),
      __legacy: {
        isRequired,
        defaultValue
      }
    }));
  };
};

const _excluded = ["graphQLReturnFragment", "field"];
const virtual = _ref => {
  let {
    graphQLReturnFragment = '',
    field
  } = _ref,
      config = _objectWithoutProperties(_ref, _excluded);

  return meta => {
    const usableField = typeof field === 'function' ? field(meta.lists) : field;
    return sqlite.fieldType({
      kind: 'none'
    })(_objectSpread(_objectSpread({}, config), {}, {
      output: apiWithContext.field(_objectSpread(_objectSpread({}, usableField), {}, {
        resolve({
          item
        }, ...args) {
          return usableField.resolve(item, ...args);
        }

      })),
      views: resolveView('virtual/views'),
      getAdminMeta: () => ({
        graphQLReturnFragment
      })
    }));
  };
};

exports.autoIncrement = autoIncrement;
exports.checkbox = checkbox;
exports.decimal = decimal;
exports.file = file;
exports.float = float;
exports.image = image;
exports.integer = integer;
exports.json = json;
exports.password = password;
exports.relationship = relationship;
exports.select = select;
exports.text = text;
exports.timestamp = timestamp;
exports.virtual = virtual;
