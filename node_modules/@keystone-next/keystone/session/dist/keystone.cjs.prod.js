'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var graphql = require('graphql');
var cookie = require('cookie');
var Iron = require('@hapi/iron');
var uidSafe = require('uid-safe');
require('../../dist/sqlite-bb0466dc.cjs.prod.js');
var apiWithContext = require('@graphql-ts/schema/api-with-context');
var apiWithoutContext = require('@graphql-ts/schema/api-without-context');
require('decimal.js');
require('@graphql-ts/schema');
require('graphql-type-json');
require('graphql-upload/public/GraphQLUpload.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var cookie__namespace = /*#__PURE__*/_interopNamespace(cookie);
var Iron__default = /*#__PURE__*/_interopDefault(Iron);

const _excluded = ["store", "maxAge"];

function generateSessionId() {
  return uidSafe.sync(24);
}

const TOKEN_NAME = 'keystonejs-session';
const MAX_AGE = 60 * 60 * 8; // 8 hours
// should we also accept httpOnly?

function statelessSessions({
  secret,
  maxAge = MAX_AGE,
  path = '/',
  secure =         "production" === 'production',
  ironOptions = Iron__default['default'].defaults,
  domain,
  sameSite = 'lax'
}) {
  if (!secret) {
    throw new Error('You must specify a session secret to use sessions');
  }

  if (secret.length < 32) {
    throw new Error('The session secret must be at least 32 characters long');
  }

  return {
    async get({
      req
    }) {
      var _req$headers$authoriz;

      const cookies = cookie__namespace.parse(req.headers.cookie || '');
      const bearer = (_req$headers$authoriz = req.headers.authorization) === null || _req$headers$authoriz === void 0 ? void 0 : _req$headers$authoriz.replace('Bearer ', '');
      const token = bearer || cookies[TOKEN_NAME];
      if (!token) return;

      try {
        return await Iron__default['default'].unseal(token, secret, ironOptions);
      } catch (err) {}
    },

    async end({
      res
    }) {
      res.setHeader('Set-Cookie', cookie__namespace.serialize(TOKEN_NAME, '', {
        maxAge: 0,
        expires: new Date(),
        httpOnly: true,
        secure,
        path,
        sameSite,
        domain
      }));
    },

    async start({
      res,
      data
    }) {
      let sealedData = await Iron__default['default'].seal(data, secret, _objectSpread(_objectSpread({}, ironOptions), {}, {
        ttl: maxAge * 1000
      }));
      res.setHeader('Set-Cookie', cookie__namespace.serialize(TOKEN_NAME, sealedData, {
        maxAge,
        expires: new Date(Date.now() + maxAge * 1000),
        httpOnly: true,
        secure,
        path,
        sameSite,
        domain
      }));
      return sealedData;
    }

  };
}
function storedSessions(_ref) {
  let {
    store: storeOption,
    maxAge = MAX_AGE
  } = _ref,
      statelessSessionsOptions = _objectWithoutProperties(_ref, _excluded);

  let {
    get,
    start,
    end
  } = statelessSessions(_objectSpread(_objectSpread({}, statelessSessionsOptions), {}, {
    maxAge
  }));
  let store = typeof storeOption === 'function' ? storeOption({
    maxAge
  }) : storeOption;
  let isConnected = false;
  return {
    async get({
      req,
      createContext
    }) {
      const data = await get({
        req,
        createContext
      });
      const sessionId = data === null || data === void 0 ? void 0 : data.sessionId;

      if (typeof sessionId === 'string') {
        if (!isConnected) {
          var _store$connect;

          await ((_store$connect = store.connect) === null || _store$connect === void 0 ? void 0 : _store$connect.call(store));
          isConnected = true;
        }

        return store.get(sessionId);
      }
    },

    async start({
      res,
      data,
      createContext
    }) {
      let sessionId = generateSessionId();

      if (!isConnected) {
        var _store$connect2;

        await ((_store$connect2 = store.connect) === null || _store$connect2 === void 0 ? void 0 : _store$connect2.call(store));
        isConnected = true;
      }

      await store.set(sessionId, data);
      return (start === null || start === void 0 ? void 0 : start({
        res,
        data: {
          sessionId
        },
        createContext
      })) || '';
    },

    async end({
      req,
      res,
      createContext
    }) {
      const data = await get({
        req,
        createContext
      });
      const sessionId = data === null || data === void 0 ? void 0 : data.sessionId;

      if (typeof sessionId === 'string') {
        if (!isConnected) {
          var _store$connect3;

          await ((_store$connect3 = store.connect) === null || _store$connect3 === void 0 ? void 0 : _store$connect3.call(store));
          isConnected = true;
        }

        await store.delete(sessionId);
      }

      await (end === null || end === void 0 ? void 0 : end({
        req,
        res,
        createContext
      }));
    }

  };
}
/**
 * This is the function createSystem uses to implement the session strategy provided
 */

async function createSessionContext(sessionStrategy, req, res, createContext) {
  return {
    session: await sessionStrategy.get({
      req,
      createContext
    }),
    startSession: data => sessionStrategy.start({
      res,
      data,
      createContext
    }),
    endSession: () => sessionStrategy.end({
      req,
      res,
      createContext
    })
  };
}
function sessionSchema(graphQLSchema) {
  const schemaConfig = graphQLSchema.toConfig();
  const mutationTypeConfig = graphQLSchema.getMutationType().toConfig();
  const endSessionField = apiWithContext.field({
    type: apiWithoutContext.nonNull(apiWithoutContext.Boolean),

    async resolve(rootVal, args, context) {
      if (context.endSession) {
        await context.endSession();
      }

      return true;
    }

  });
  const mutationType = new graphql.GraphQLObjectType(_objectSpread(_objectSpread({}, mutationTypeConfig), {}, {
    fields: _objectSpread(_objectSpread({}, mutationTypeConfig.fields), {}, {
      endSession: _objectSpread(_objectSpread({}, endSessionField), {}, {
        type: endSessionField.type.graphQLType
      })
    })
  }));
  return new graphql.GraphQLSchema(_objectSpread(_objectSpread({}, schemaConfig), {}, {
    types: schemaConfig.types.map(x => x.name === 'Mutation' ? mutationType : x),
    mutation: mutationType
  }));
}

exports.createSessionContext = createSessionContext;
exports.sessionSchema = sessionSchema;
exports.statelessSessions = statelessSessions;
exports.storedSessions = storedSessions;
