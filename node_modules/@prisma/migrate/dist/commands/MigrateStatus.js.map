{
  "version": 3,
  "sources": ["../../src/commands/MigrateStatus.ts"],
  "sourcesContent": ["import {\n  arg,\n  Command,\n  format,\n  getSchemaPath,\n  HelpError,\n  isError,\n  getCommandWithExecutor,\n} from '@prisma/sdk'\nimport chalk from 'chalk'\nimport path from 'path'\nimport { ensureCanConnectToDatabase } from '../utils/ensureDatabaseExists'\nimport { Migrate } from '../Migrate'\nimport {\n  ExperimentalFlagWithNewMigrateError,\n  EarlyAccessFeatureFlagWithNewMigrateError,\n} from '../utils/flagErrors'\nimport { HowToBaselineError, NoSchemaFoundError } from '../utils/errors'\nimport Debug from '@prisma/debug'\nimport { throwUpgradeErrorIfOldMigrate } from '../utils/detectOldMigrate'\nimport { printDatasource } from '../utils/printDatasource'\nimport { EngineResults } from '../types'\n\nconst debug = Debug('prisma:migrate:status')\n\nexport class MigrateStatus implements Command {\n  public static new(): MigrateStatus {\n    return new MigrateStatus()\n  }\n\n  private static help = format(`\nCheck the status of your database migrations\n\n  ${chalk.bold('Usage')}\n\n    ${chalk.dim('$')} prisma migrate status [options]\n    \n  ${chalk.bold('Options')}\n\n  -h, --help   Display this help message\n    --schema   Custom path to your Prisma schema\n\n  ${chalk.bold('Examples')}\n\n  Check the status of your database migrations\n  ${chalk.dim('$')} prisma migrate status\n\n  Specify a schema\n  ${chalk.dim('$')} prisma migrate status --schema=./schema.prisma\n`)\n\n  public async parse(argv: string[]): Promise<string | Error> {\n    const args = arg(\n      argv,\n      {\n        '--help': Boolean,\n        '-h': '--help',\n        '--experimental': Boolean,\n        '--early-access-feature': Boolean,\n        '--schema': String,\n        '--telemetry-information': String,\n      },\n      false,\n    )\n\n    if (isError(args)) {\n      return this.help(args.message)\n    }\n\n    if (args['--help']) {\n      return this.help()\n    }\n\n    if (args['--experimental']) {\n      throw new ExperimentalFlagWithNewMigrateError()\n    }\n\n    if (args['--early-access-feature']) {\n      throw new EarlyAccessFeatureFlagWithNewMigrateError()\n    }\n\n    const schemaPath = await getSchemaPath(args['--schema'])\n\n    if (!schemaPath) {\n      throw new NoSchemaFoundError()\n    }\n\n    console.info(\n      chalk.dim(\n        `Prisma schema loaded from ${path.relative(process.cwd(), schemaPath)}`,\n      ),\n    )\n\n    await printDatasource(schemaPath)\n\n    throwUpgradeErrorIfOldMigrate(schemaPath)\n\n    const migrate = new Migrate(schemaPath)\n\n    try {\n      await ensureCanConnectToDatabase(schemaPath)\n    } catch (e) {\n      console.info() // empty line\n      return chalk.red(`Database connection error:\n\n${e.message}`)\n    }\n\n    // This is a *read-only* command (modulo shadow database).\n    // - \u21A9\uFE0F **RPC**: ****`diagnoseMigrationHistory`, then four cases based on the response.\n    //     4. Otherwise, there is no problem migrate is aware of. We could still display:\n    //         - Modified since applied only relevant when using dev, they are ignored for deploy\n    //         - Pending migrations (those in the migrations folder that haven't been applied yet)\n    //         - If there are no pending migrations, tell the user everything looks OK and up to date.\n\n    let diagnoseResult: EngineResults.DiagnoseMigrationHistoryOutput\n    let listMigrationDirectoriesResult: EngineResults.ListMigrationDirectoriesOutput\n\n    try {\n      diagnoseResult = await migrate.diagnoseMigrationHistory({\n        optInToShadowDatabase: false,\n      })\n      debug({ diagnoseResult: JSON.stringify(diagnoseResult, null, 2) })\n\n      listMigrationDirectoriesResult = await migrate.listMigrationDirectories()\n      debug({ listMigrationDirectoriesResult })\n    } finally {\n      migrate.stop()\n    }\n\n    console.log() // empty line\n\n    if (listMigrationDirectoriesResult.migrations.length > 0) {\n      const migrations = listMigrationDirectoriesResult.migrations\n      console.info(\n        `${migrations.length} migration${\n          migrations.length > 1 ? 's' : ''\n        } found in prisma/migrations\\n`,\n      )\n    } else {\n      console.info(`No migration found in prisma/migrations\\n`)\n    }\n\n    let unappliedMigrations: string[] = []\n    if (diagnoseResult.history?.diagnostic === 'databaseIsBehind') {\n      unappliedMigrations = diagnoseResult.history.unappliedMigrationNames\n      console.info(\n        `Following migration${\n          unappliedMigrations.length > 1 ? 's' : ''\n        } have not yet been applied:\n${unappliedMigrations.join('\\n')}\n\nTo apply migrations in development run ${chalk.bold.greenBright(\n          getCommandWithExecutor(`prisma migrate dev`),\n        )}.\nTo apply migrations in production run ${chalk.bold.greenBright(\n          getCommandWithExecutor(`prisma migrate deploy`),\n        )}.`,\n      )\n    } else if (diagnoseResult.history?.diagnostic === 'historiesDiverge') {\n      return `Your local migration history and the migrations table from your database are different:\n\nThe last common migration is: ${diagnoseResult.history.lastCommonMigrationName}\n\nThe migration${\n        diagnoseResult.history.unappliedMigrationNames.length > 1 ? 's' : ''\n      } have not yet been applied:\n${diagnoseResult.history.unappliedMigrationNames.join('\\n')}\n\nThe migration${\n        diagnoseResult.history.unpersistedMigrationNames.length > 1 ? 's' : ''\n      } from the database are not found locally in prisma/migrations:\n${diagnoseResult.history.unpersistedMigrationNames.join('\\n')}`\n    }\n\n    if (!diagnoseResult.hasMigrationsTable) {\n      //         - This is the **baselining** case.\n      //         - Look at the migrations in the migrations folder\n      //             - There is no local migration\n      //                 - ...and there is drift: the user is coming from db push or another migration tool.\n      //                 - Guide the user to an init flow with introspect + SQL schema dump (optionally)\n      //             - There are local migrations\n      //                 - \u21A9\uFE0F **RPC** `listMigrationDirectories` ****Take the first (=oldest) migration.\n      //                 - Suggest calling `prisma migrate resolve --applied <migration-name>`\n\n      if (listMigrationDirectoriesResult.migrations.length === 0) {\n        return new HowToBaselineError().message\n      } else {\n        const migrationId =\n          listMigrationDirectoriesResult.migrations.shift() as string\n        return `The current database is not managed by Prisma Migrate.\n\nIf you want to keep the current database structure and data and create new migrations, baseline this database with the migration \"${migrationId}\":\n${chalk.bold.greenBright(\n  getCommandWithExecutor(`prisma migrate resolve --applied \"${migrationId}\"`),\n)}\n\nRead more about how to baseline an existing production database:\nhttps://pris.ly/d/migrate-baseline`\n      }\n    } else if (diagnoseResult.failedMigrationNames.length > 0) {\n      //         - This is the **recovering from a partially failed migration** case.\n      //         - Inform the user that they can \"close the case\" and mark the failed migration as fixed by calling `prisma migrate resolve`.\n      //             - `prisma migrate resolve --rolled-back <migration-name>` if the migration was rolled back\n      //             - `prisma migrate resolve --applied <migration-name>` if the migration was rolled forward (and completed successfully)\n      const failedMigrations = diagnoseResult.failedMigrationNames\n\n      console.info(\n        `Following migration${\n          failedMigrations.length > 1 ? 's' : ''\n        } have failed:\n${failedMigrations.join('\\n')}\n\nDuring development if the failed migration(s) have not been deployed to a production database you can then fix the migration(s) and run ${chalk.bold.greenBright(\n          getCommandWithExecutor(`prisma migrate dev`),\n        )}.\\n`,\n      )\n\n      return `The failed migration(s) can be marked as rolled back or applied:\n      \n- If you rolled back the migration(s) manually:\n${chalk.bold.greenBright(\n  getCommandWithExecutor(\n    `prisma migrate resolve --rolled-back \"${failedMigrations[0]}\"`,\n  ),\n)}\n\n- If you fixed the database manually (hotfix):\n${chalk.bold.greenBright(\n  getCommandWithExecutor(\n    `prisma migrate resolve --applied \"${failedMigrations[0]}\"`,\n  ),\n)}\n\nRead more about how to resolve migration issues in a production database:\nhttps://pris.ly/d/migrate-resolve`\n    } else {\n      console.info() // empty line\n      if (unappliedMigrations.length > 0) {\n        // state is not up to date\n        return ``\n      } else {\n        return `Database schema is up to date!`\n      }\n    }\n  }\n\n  public help(error?: string): string | HelpError {\n    if (error) {\n      return new HelpError(\n        `\\n${chalk.bold.red(`!`)} ${error}\\n${MigrateStatus.help}`,\n      )\n    }\n    return MigrateStatus.help\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
